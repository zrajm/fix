#!/usr/bin/perl
use strict;
use warnings;
use 5.10.0;
use Test::More;

use Carp 'confess';
$SIG{__DIE__} = \&Carp::confess;

our $name = 'fix';

BEGIN {                                        # load 'fix' as a module
    use Cwd qw/realpath/;
    my $fix = realpath(__FILE__ =~ s{[^/]+$}{fix}r);
    require $fix;
    Module->import();
}

###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

# Return keys in hash, sorted by first by length, then alphabetically.
sub key {
    my %x = @_;
    sort { length($a) <=> length($b) or $a cmp $b } keys %x;
}

sub read_file {
    my ($file) = @_;
    open(my $in, '<', $file)
        or die "Failed to open file '$file' for reading: $!,";
    local $/ = undef;
    return <$in>;
}

sub make_tempdir {
    my ($name) = @_;
    my $tempdir = `mktemp -td $name-XXXXXX`;
    chomp($tempdir);
    return $tempdir;
}

sub serialize {
    my (%x) = @_;
    use Data::Dumper;
    local $Data::Dumper::Indent   = 1;
    local $Data::Dumper::Sortkeys = 1;
    local $Data::Dumper::Terse    = 1;
    return Dumper \%x;
}

###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################

# check if there is an 'exit' statement in this file
my $exit_statement_in_test_script = read_file(__FILE__) =~ /^\s*exit/m;

my $testdir = make_tempdir($name);
chdir($testdir) or die "Failed to cd to '$testdir': $!,";

###############################################################################
##                                                                           ##
##  Tests                                                                    ##
##                                                                           ##
###############################################################################

note 'split_path()';
# FIXME: What *should* split_path('.') return?
my @test = (
    [ qw( a/b/c     a/b     c ) ],
    [ qw( a/b/c/    a/b     c ) ],
    [ qw( a/b/c///  a/b     c ) ],
    [ qw( a/b//c/   a/b     c ) ],
    [ qw( a//b/c    a//b    c ) ],
    [ qw( /a/b/c    /a/b    c ) ],
    [ qw( a         .       a ) ],
    [ qw( /a        /       a ) ],
);
# We run the function twice, because it looks prettier to report basenames and
# dirnames separately in the output.
foreach my $test (@test) {
    my ($path, $expect_dir, undef) = @$test;
    my ($dir_result, undef) = Local::Modulino::split_path($path);
    is ($dir_result, $expect_dir, "Dirname: $path");
}
foreach my $test (@test) {
    my ($path, undef, $expect_file) = @$test;
    my (undef, $file_result) = Local::Modulino::split_path($path);
    is ($file_result, $expect_file, "Basename: $path");
}

note 'default_buildfiles()';
{
    my %tests = (
        'hej.a.b.c' => [
            'default.a.b.c.fix',
            'default.a.b.fix',
            'default.a.fix',
            'default.fix' ],
        'a' => [
            'default.fix' ],
    );
    for (key %tests) {
        my $expect = $tests{$_};
        is_deeply([ Local::Modulino::possible_buildfiles($_) ], $expect,
                  "Files: $_");
    }
}

note 'Local::Paths::clean()';
{
    my @test = (
        './a'        => 'a',
        '../a'       => '../a',
        '../../a'    => '../../a',
        '.'          => '.',
        './.'        => '.',
        './..'       => '..',
        './'         => '.',                   # odd corner case
        '/.'         => '/',                   # odd corner case
        '/'          => '/',
        '/a'         => '/a',
        '/a/..'      => '/',
        '/a/../..'   => '/',
        '/a/b/../..' => '/',
        'a'          => 'a',
        'a/'         => 'a',
        'a/../..'    => '..',
        'a/../../..' => '../..',
        'a/../b/c'   => 'b/c',
        'a/../../c'  => '../c',
        'a/./b'      => 'a/b',
        'a//b'       => 'a/b',
        'a/b'        => 'a/b',
        'a/b/../..'  => '.',
        'a/b/c/..'   => 'a/b',
    );
    while (@test) {
        my ($_, $expect) = splice(@test, 0, 2);
        is(Local::Paths::clean($_), $expect, "Path: $_");
    }
}

note "Local::Store, simple use";
{
    my $test = new Local::Store(dir => 'storage');
    my ($x, $y);

    $x = eval { $test->get('file'); 1 };
    is  ($x, undef, "get() without fields should die");
    like($@, qr/Missing arguments: No field names given/,
                    "get() without fields error message");

    $x = $test->get('file', 'foo');
    is  ($x, undef, "get() on non-existing field");
    $x = $test->set('file', foo => 'bar', apa => 'bepa');
    ok  ($x, "set() return status");
    for ('storage/file') {
        ok  ( -f $_, "set() file existence: $_");
        is  (read_file($_), serialize(foo => 'bar', apa => 'bepa'),
             "set() file content: $_");
    }

    ($x, $y) = $test->get('file', 'foo', 'apa');
    is  ($x, 'bar',  'get() with two existing fields, 1st field');
    is  ($y, 'bepa', 'get() with two existing fields, 2nd field');
    ($x, $y) = $test->get('file', 'apa', 'foo');
    is  ($x, 'bepa', 'get() with two existing fields in opposite order, 1st field');
    is  ($y, 'bar',  'get() with two existing fields in opposite order, 2nd field');

    my %expected = ( foo => 'bar', apa => 'bepa' );
    foreach (qw/foo apa/) {
        $x = $test->get('file', $_);
        is  ($x, $expected{$_}, "get() with one field in scalar context: $_");
    }
}

END {
    done_testing();
    note
        "================================================\n" .
        " NOTA BENE! EXIT STATEMENT FOUND IN TESTSCRIPT!\n" .
        "================================================\n"
            if $exit_statement_in_test_script;
    note
        "Tempdir: $testdir\n",
}

#[eof]
