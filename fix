#!/usr/bin/perl
package Local::Modulino; #[http://www.drdobbs.com/scripts-as-modules/184416165]
use strict;
use warnings;
use encoding::warnings 'FATAL';
use 5.10.0;
use utf8;
use open ':utf8';
binmode(STDOUT, ':utf8');

use File::Path qw/mkpath rmtree/;              # use 'mkpath' and 'rmtree'
use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse    = 1;

###############################################################################
##                                                                           ##
##  Settings                                                                 ##
##                                                                           ##
###############################################################################

our $VERSION = "0.3";
our $YEAR    = "2012-2014";
our ($NAME)  = __FILE__ =~ m#([^/]*)$#;        # last non-slash part of path
our ($Keep, $Run, $Stats);
our %Opt = (
    debug     => !!$ENV{FIX_DEBUG},            # -D/--debug $FIX_DEBUG
    fix_cmd   =>   $ENV{FIX_CMD}       //= Local::Paths::absolute(__FILE__),
    fix_dir   =>   ".$NAME",                   # '.fix' dir
    # force   => !!$ENV{FIX_FORCE},            # -f/--force $FIX_FORCE
    level     =>   $ENV{FIX_LEVEL}     += 1,   # child level (mother = 1)
    parent    =>   $ENV{FIX_PARENT}    // '',  # parent target
    pid       =>   $ENV{FIX_PID}       //= $$, # PID of mother process
    shell     =>   '/bin/dash',
    stats     => !!$ENV{FIX_STATS},            # --stats $FIX_STATS
    xtrace    => !!$ENV{FIX_XTRACE},           # -x/--xtrace $FIX_XTRACE
    verbose   => !!$ENV{FIX_VERBOSE},          # -v/--verbose $FIX_VERBOSE
);

###############################################################################
##                                                                           ##
##  Informational Functions                                                  ##
##                                                                           ##
###############################################################################

sub version {
    print "$NAME $VERSION\n",
        "Written $YEAR by zrajm <zrajm\@klingonska.org>\n",
        "License CC BY-SA 3.0: Creative Commons Attribution-Share Alike 3.0\n",
        "    <http://creativecommons.org/licenses/by-sa/3.0/>\n";
    exit;
}

sub pod2ansi {
    my ($_) = @_;
    return undef unless defined($_);
    my %char = (quot => '"', amp => '&', lt => '<', gt => '>');
    s#E<([^>]*)>#$char{lc $1}#g;     # HTML-like entity
    s#B<([^>]*)>#\e[1m$1\e[0m#g;     # bold
    s#[FI]<([^>]*)>#\e[4m$1\e[0m#g;  # italic / filename
    s#C<([^>]*)>#"$1"#g;             # quoted code
    return $_;
}

# usage(SOURCE, MSG) -- display usage information from SOURCE + display MSG
sub usage {
    my ($_, $msg) = @_;
    my $out;
    $out .= m#^=head1 \s+ SYNOPSIS \s+ (.*)#mx
        ? "Usage: " . pod2ansi($1) . "\n" : "";
    $out .= m#^=head1 \s+ NAME \s+ [-\w]+ \s+-\s+ (.*)#mx ? "\u$1.\n" : "";
    $out .= "\n" if $out;
    { # list --options (from comments) -- sort by longopt name
        my @opt_doc = ();
        my $opt_length = 0;
        while (/^ \s*
                (?: (['"])                     # start quote
                    ([^\n'"=:|]*?)             #   longopt
                    (?:
                           \|([^\n'"=|:]*?)    #   keep first shortopt
                        (?:\| [^\n'"=|:]+)*    #     (ignore more shortopts)
                    )?
                    (?:\+|([:=])[^\n'"=]*)?    #   optarg
                    \1 [^#]*                   # end quote
                |.*?)?(?<!\#)\#\#\#\s+(.*)$/xmg) { # description
            my $long  = $2 ? "--$2"  : "";
            my $short = $3 ?  "-$3," : "";
            my $arg   = $4;
            my $desc  = $5;
            # if option takes arg, and 1st word in description is uppercase,
            # use that uppercase word in long description description
            if ($arg and $desc =~ s/([A-Z0-9]+)\s*//) {
                $long .= $arg eq ":" ? "[=$1]" : "=$1";
            }
            push(@opt_doc, [ $short, $long, pod2ansi($desc) ]);
            my $length = length($long);
            $opt_length = $length if $length > $opt_length;
        }
        # length of longest option name
        if (@opt_doc) {
            $out .= join "", "Options:\n", map {
                sprintf "  %-3s %-${opt_length}s  %s\n", @$_
            } @opt_doc;
        }
    }
    print "$out\n" . pod2ansi($msg);
    exit;
}

sub help {
    usage(read_file(__FILE__), <<'EOF');
EOF
    exit;
}

sub man {
    my $pid = open(STDOUT, '|-', qw/man -l -/);# filter STDOUT through man(1)
    die "Cannot run 'man': $!\n" unless defined $pid;
    system('pod2man', __FILE__);               # output manpage on STDOUT
    if ($? == -1) {                            # on exec FAILURE
        kill 'TERM', $pid;                     #   kill man(1) child and die()
        die "Cannot execute 'pod2man': $!\n";
    };
    close STDOUT;                              # don't make man(1) wait for more
    wait();                                    # wait until user exits man(1)
    exit;
}

###############################################################################
##                                                                           ##
##  State Storage Module                                                     ##
##                                                                           ##
###############################################################################

{
    package Local::Store;
    use Data::Dumper;
    $Data::Dumper::Indent   = 1;
    $Data::Dumper::Sortkeys = 1;
    $Data::Dumper::Terse    = 1;

    # Statedir is created when writing file, rather than up front. (We'll need
    # to create it then anyway, since filenames may contain any number of
    # slashes.)
    sub new {
        my ($class, $dir) = @_;
        return bless ({ dir => $dir, print => {}, state => {} });
    }

    # Read file stat fingerprint. If this is unchanged since a previous check,
    # know the file is unchanged. If fingerprint has changed, then we need to
    # look at the file content to determine whether that has changed or not.
    # The following lstat() properties are used:
    #
    #      1 ino      inode number
    #      2 mode     file mode (type and permissions)
    #      4 uid      numeric user ID of file's owner
    #      5 gid      numeric group ID of file's owner
    #      7 size     total size of file, in bytes
    #      9 mtime    last modify time in seconds since the epoch
    #     10 ctime    inode change time in seconds since the epoch (*)
    #
    # [http://www.kernel.org/pub/software/scm/git/docs/technical/racy-git.txt]
    #
    # Note: We can't use Time::HiRes here, since it only supports lstat() since
    # February 2013. [https://rt.cpan.org/Public/Bug/Display.html?id=83356]
    sub _read_file_fingerprint {
        my ($file) = @_;
        my @stat = lstat($file) or die "Cannot stat file '$file': $!\n";
        return join("-", @stat[1, 2, 4, 5, 7, 9, 10]);
    }

    sub _read_file {
        my ($file) = @_;
        open(my $in, "<:utf8", $file)
            or die "Cannot open file '$file' for reading: $!\n";
        local $/ = undef;
        return <$in>;
    }

    {
        use File::Path qw/mkpath rmtree/;      # use 'mkpath' and 'rmtree'

        sub _write_file {
            my ($file, @data) = @_;
            my $tmpfile = "$file--writing";
            # create full path of file, before writing file
            if (my ($dir) = $tmpfile =~ m#^(.*)/#) {
                die "Cannot create dir '$dir': File already exists\n"
                    if -e $dir and not -d $dir;
                unless (-d $dir or mkpath($dir)) {
                    die "Cannot create dir '$dir'\n";
                }
            }
            open(my $out, ">:utf8", $tmpfile)
                or die "Cannot open tempfile '$tmpfile' for writing: $!\n";
            print $out @data
                or die "Cannot write to tempfile '$tmpfile': $!\n";
            close($out)
                or die "Cannot close tempfile '$tmpfile' after writing: $!\n";
            rename($tmpfile, $file)
                or die "Cannot rename tempfile '$tmpfile' -> '$file': $!\n";
        }

        # Deletes named files. Give argument '' to delete entire storage.
        sub delete {
            my ($self, @file) = @_;
            rmtree("$self->{dir}/$_") foreach @file;
            return $self;
        }
    }

    # Rereads the state file every time, since subprocess may have updated it.
    # FIXME: reread file only when it has been changed
    sub _get_state {
        my ($self, $file) = @_;
        my $full  = "$self->{dir}/$file";
        my $state = $self->{state};
        my $print = $self->{print};
        if (-f $full) {                        # state file exists
            my $print2 = _read_file_fingerprint($full);
            if ($print2 ne ($print->{$file} // '')) {
                $print->{$file} = $print2;     #   read if modified
                $state->{$file} = eval _read_file($full);
            }
        }
        $state->{$file}{deps} //= [];
        return $state->{$file};
    }

    # sub _load_state {
    #     my ($self, $file) = @_;
    #     my $state = $self->{state};
    #     if (not exists $state->{$file}) {
    #         my $full = "$self->{dir}/$file";
    #         $state->{$file} = -f $full ? eval _read_file($full) : {};
    #     }
    #     return $state->{$file};
    # }

    # Return true if arrayref of empty array, or undef.
    sub _empty {
        my ($_) = @_;
        return 1 if (ref($_) eq 'ARRAY') and (@$_ == 0);
        return 1 if $_ ~~ undef;
        return 0;
    }

    sub _save_state {
        my ($self, $file) = @_;
        my $full = "$self->{dir}/$file";
        my $filtered = do {                    # remove empty arrayrefs
            my $data = $self->{state}{$file};  #   and undefs
            my %x = map {
                _empty($data->{$_}) ? () : ($_ => $data->{$_});
            } keys %$data;
            \%x;
        };
        _write_file($full, Dumper($filtered));
        # $self->{print}{file} = _read_file_fingerprint($full);
    }

    sub get {
        my ($self, $file, @field) = @_;
        die "get(): Missing arguments: No field names given," if @field == 0;
        my $state = $self->_get_state($file);
        return wantarray()
            ? map { $state->{$_} // '' } @field
            : $state->{ $field[0] } // '';
    }

    # If a value is a coderef, then that will be invoked with the original
    # value, and whatever it returns will be stored in its stead.
    sub set {
        my ($self, $file, %arg) = @_;
        return if $file eq '';
        my $state = $self->_get_state($file);
        if (exists $arg{add_deps}) {
            push @{ $state->{deps} }, \@{ delete $arg{add_deps} };
        }
        foreach my $field (keys %arg) {
            $state->{$field} =
                ref($arg{$field}) eq 'CODE'    # run callback
                    ? $arg{$field}->($state->{$field}) # run callback
                    : $arg{$field};            #   or use literal value
        }
        $self->_save_state($file);
    }
}

###############################################################################
##                                                                           ##
##  Cwd Wrapper Module                                                       ##
##                                                                           ##
###############################################################################

# Package used here to contain Cwd functions from leaking out into the 'main::'
# namespace, where it would be very easy to accidentaly use it. We don't want
# cwd()! It gives *physical* insteado of *logical* paths! (Bugs ohoy!) :(
{
    package Local::Paths;
    use Cwd;

    # Current working directory. Returns environment variable '$PWD' (= logical
    # path) if available and falls back to returning Perl's cwd() if that
    # fails.
    sub current { $ENV{PWD} // Cwd::cwd() }

    # Clean up a path without looking at the file system.
    sub clean {
        my ($path) = @_;
        my @newpart;
        foreach my $part (split m#/+#, $path) {
            next if $part eq '.';              # skip '.' components
            if ($part eq '..') {               # remove previous component
                if (@newpart > 0               #   unless at beginning
                        and $newpart[-1] ne '..') {# or preceded by '..'
                    pop @newpart;
                    next;
                }
            }
            push(@newpart, $part);
        }
        my $newpath = join '/', @newpart;
        return ($newpath eq '')                # if path is '', then look at
            ? (($path =~ m#^/#) ? '/' : '.')   #   original path to see if it
            : $newpath;                        #   started with '/'
    }

    sub absolute {
        my ($_) = @_;
        clean(m#^/# ? $_ : current() . "/$_");
    }
}

###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

sub TRUE  { 1 }
sub FALSE { 0 }

sub SOURCE { 'source' }
sub TARGET { 'target' }

sub PLAIN { 0 }                                # loglevel for msg()
sub BOLD  { 1 }

sub ERROR   { 4 }                              # red
sub WARN    { 2 }                              # yellow
sub INFO    { 3 }                              # green
sub VERBOSE { 3 }                              # green
sub DEBUG   { 0 }                              # plain

sub is_child { $Opt{parent} ne '' }

# Set value for '--stats'. If value is already set, leave it as-is.
sub did {
    return unless $Opt{stats};
    my ($name, $value) = @_;
    $Run->set($name, build_status => sub { shift() // $value });
}

sub read_file {
    my ($file) = @_;
    open(my $in, "<:utf8", $file)
        or die "Cannot open file '$file' for reading: $!\n";
    local $/ = undef;
    return <$in>;
}

sub write_file {
    my ($file, @data) = @_;
    my $tmpfile = "$file--writing";
    # create full path of file, before writing file
    if (my ($dir) = $tmpfile =~ m#^(.*)/#) {
        die "Cannot create dir '$dir': File already exists\n"
            if -e $dir and not -d $dir;
        unless (-d $dir or mkpath($dir)) {
            warn "Cannot create dir '$dir'\n";
            return undef;
        }
    }
    open(my $out, ">:utf8", $tmpfile)
        or die "Cannot open tempfile '$tmpfile' for writing: $!\n";
    print $out @data
        or die "Cannot write to tempfile '$tmpfile': $!\n";
    close($out)
        or die "Cannot close tempfile '$tmpfile' after writing: $!\n";
    rename($tmpfile, $file)
        or die "Cannot rename tempfile '$tmpfile' -> '$file': $!\n";
}

sub rename_file {
    my ($file1, $file2) = @_;
    rename($file1, $file2) or "Cannot rename '$file1' -> '$file2': $!\n";
}

sub checksum_file {
    my ($file) = @_;
    return '' unless -f $file;
    use Encode qw(encode_utf8);
    use Digest::SHA qw(sha1_hex);
    sha1_hex(encode_utf8(read_file($file)));
}

# Redirect standard output to FILE. Return hashref suitable for passing to
# restore_stdout(), or die() on failure.
sub redirect_stdout {
    my ($file) = @_;
    my $prev = { flush => $|, handle => undef, file => $file };
    open($prev->{handle}, '>&', 'STDOUT')
        or die "Cannot copy old STDOUT before redirect to '$file': $!\n";
    open(STDOUT, '>', $file)
        or die "Cannot redirect STDOUT to file '$file': $!\n";
    select STDOUT;
    local $| = 1;                              # turn off buffering
    return $prev;
}

# Restore standard output after redirect_stdout(). PREV is the hashref returned
# by redirect_stdout(). Die()s on failure.
sub restore_stdout {
    my ($prev) = @_;
    close(STDOUT);
    open(STDOUT, '>&', $prev->{handle})
        or die "Cannot restore STDOUT after redirect to file '$prev->{file}': $!\n";
    close($prev->{handle});
    select STDOUT;
    local $| = $prev->{flush};                 # restore buffering
}

# Redirect standard output to FILE, execute CODEREF, then restore STDOUT.
# CODEREF is passed a single argument containing FILE.
sub redir_stdout {
    my ($file, $coderef) = @_;
    my $oldout = redirect_stdout($file);
    my @result = &$coderef($file);
    restore_stdout($oldout);
    return wantarray() ? @result : $result[0];
}

# Return substrings, or in scalar context, substring count.
sub substrings {
    my ($str, $substr) = @_;
    my @match = $str =~ m/$substr/g;
    return @match;
}

# FIXME: What *should* split_path('.') return?
sub split_path {
    my ($_) = @_;
    my @x = (
        m#^ (.*?) /+ ([^/]+) /* $#x
            ? (($1 eq '' ? '/' : $1), $2)
            : ('.', $_)
    );
    return wantarray() ? @x : $x[0];
}

# Given the basename of a target return a list of possible buildscript
# basenames. The following list will result from 'target.tar.gz' as input:
#
#     default.tar.gz.fix
#     default.tar.fix
#     default.fix
#
sub possible_buildfiles {
    my ($file) = @_;
    my @p = split m#\.+#, $file;
    $p[0] = 'default';
    map { join('.', @p[ 0 .. $_ ]) . ".fix" } reverse 0 .. $#p;
}

# Returns (relative) path of fixfile for the specified target, or empty string
# if no fixfile could be found.
#
# If 'TARGET.fix' couldn't be found, this will look for each possible default
# fixfile, first in the current directory, then in directory above that, etc.
# until we reach root. (The last file looked at is '/default.fix' which is
# probably a bit naive.)
sub find_fixfile {
    my ($target) = @_;
    return "$target.fix" if -e "$target.fix";
    my ($dir, $file) = split_path($target);
    my @fixfile = possible_buildfiles($file);
    my $max = substrings(Local::Paths::current(), qr#[^/]+#);# pwd path depth
    my $dotdot = qr#\Q../\E#;                  # matcher for '../' in path
    while (substrings($dir, $dotdot) < $max) { # while not at max depth
        foreach (@fixfile) {                   #   try each fixfile
            my $fixfile = "$dir/$_";
            return $fixfile if -e $fixfile;
        }
        $dir = Local::Paths::clean("$dir/..");
    }
    return '';
}

# build_target($level, $target);
#
# Builds TARGET by executing its buildfile. Return TRUE if the content of
# TARGET was modified because of the (re)build, FALSE if target was not
# modified. Die()s on error.
#
# NOTE: If a target was rebuilt, but the target content remained the same after
# the rebuild, then that target does not count as updated. (This can happen
# e.g. when the build file was modified in a way that did not change its output
# [e.g. a comment was added to it] or if a deleted target with unmodified
# dependencies was rebuilt.)
sub build_target {
    my ($level, $target) = @_;
    info($target);
    if (-f $target and has_changed($Keep, $target)) {
        $Run->set($target,      ABORT => $target);
        $Run->set($Opt{parent}, ABORT => $target) if is_child();
        did($target, 'wont_overwrite');
        msg(ERROR, "$target: Target externally modified, aborting\n");
        exit 253;
    }
    my ($buildscript, $outfile) = ("$target.fix", "$target--fixing");
    # clear dependency information (rebuilt each run)
    $Keep->set($target,
        type => TARGET,
        deps => [[ $buildscript ]],
    );

    my ($close, $exit, $errno) = redir_stdout($outfile, sub {
        local $ENV{FIX_PARENT} = $target;
        local $ENV{FIX_LEVEL}  = $level;
        my @arg = (
            $Opt{xtrace} ? '-x' : (),
            $Opt{debug}  ? '-v' : (),
        );
        open(my $shell, '|-', $Opt{shell}, '-e', @arg)
            or die "Cannot execute shell '$Opt{shell}': $!\n";
        print $shell read_file($buildscript);

        my $close = close($shell);
        return ($close, $?, $!);
    });
    # NOTE: outfile is kept on failure (so user may inspect it)
    #
    # - Except when a dependency completely failed to run (e.g. its output file
    #   was externally modified) in which case we remove the outfile.
    if (not $close) {
        $exit >>= 8;
        if ($errno != 0) {
            did($target, 'shell_error');
            die "Cannot run buildscript '$buildscript': $errno\n";
        }
        my $aborted_target = $Run->get("$target", 'ABORT');
        if ($aborted_target ne '') {           # a dependency failed to run
            unlink($outfile);                  #   erase outfile and
            $Run->set(                         #     and tell our parent that
                $Opt{parent},                  #     that we failed, too
                ABORT => $aborted_target,
            ) if is_child();
        } else {                               # a buildscript returned non-zero
            msg(ERROR, "$target: exit status $exit\n");
        }
        did($target, 'buildscript_error');
        exit $exit;
    }

    my $old_checksum = $Keep->get($target, 'checksum');
    my $new_checksum = checksum_file($outfile);
    if ($new_checksum eq $old_checksum) {      # target unmodified
        if (-e $target) {                      #   if target exist
            unlink($outfile);
            did($target, 'rebuilt_but_kept_previous');
        } else {                               #   if target was deleted
            rename_file($outfile, $target);
            did($target, 'rebuilt_replaced_deleted');
        }
        return FALSE;
    }
    rename_file($outfile, $target);            # target modified
    $Keep->set($target, checksum => $new_checksum); # store new checksum
    did($target, 'rebuilt_new_content');
    return TRUE;
}

# FIXME: clean up msg()
{
    my @ansi = ("\e[m", "\e[1m", "\e[33m", "\e[32m", "\e[31m");
    sub msg {
        my ($loglevel, $message) = @_;
        die "msg(): missing loglevel" unless defined $ansi[$loglevel];
        chomp $message;
        say STDERR "$ansi[$loglevel]$NAME " . ("  " x ($Opt{level} - 1)) .
            $ansi[BOLD] . $message . $ansi[PLAIN];
    }
}
sub info {
    chomp(my $msg = shift);
    say STDERR "\e[32m$NAME " . ("  " x ($Opt{level} - 1)) . "\e[1m$msg\e[m";
}
# Display verbose msg in mother process, or all processes with --verbose/--debug
sub verb { (is_child() or $Opt{debug} or $Opt{verbose}) and info @_ }
sub debug {
    return unless $Opt{debug};
    chomp(my $msg = shift);
    say STDERR "$NAME " . ("  " x ($Opt{level} - 1)) . $msg;
}
sub _warn { msg WARN, @_ }
sub _die  { msg ERROR, @_; exit 255 }

# NB: $file must exist for has_changed() to give meaningful result
sub has_changed {
    my ($self, $file) = @_;
    my $checksum = $self->get($file, 'checksum');
    return checksum_file($file) eq $checksum ? 0 : 1;
}

# update_targets($level, @target);
#
# Make sure all TARGET(s) are up-to-date, rebuilding them if necessary. Return
# TRUE if the content one or more TARGET(s) was modified because of a rebuild,
# FALSE if no targets were modified. Die()s on error.
#
# NOTE: If a target was rebuilt, but the target content remained the same after
# the rebuild, then that target does not count as updated. (This can happen
# e.g. when the build file was modified in a way that did not change its output
# [e.g. a comment was added to it] or if a deleted target with unmodified
# dependencies was rebuilt.)
sub update_targets {
    my ($level, @target) = @_;
    local $Opt{level} = $level;
    my $changed  = FALSE;
  TARGET: foreach my $target (@target) {
        my ($type, $dep_clusters) = $Keep->get($target, 'type', 'deps');
        if ($type eq '') {                     # target is not known by fix
            my $buildscript = "$target.fix";
            $Keep->set($buildscript,
                checksum => checksum_file($buildscript),
                type     => SOURCE,
            );
            build_target($level, $target)      #   (all target has at least
                and $changed = TRUE;           #   its own buildfile as dep)
        } elsif ($type eq TARGET) {            # file previously seen by fix
            info "$target (previously built)";
            my $deps_changed = FALSE;
            foreach my $deps (@$dep_clusters) {#   check deps
                update_targets($level + 1, @$deps)
                    and $deps_changed = TRUE;
            }
            if ($deps_changed or (not -e $target) or has_changed($Keep, $target)) {
                build_target($level, $target)
                    and $changed = TRUE;
            } else {
                did($target, 'wont_rebuild');
            }
        } elsif ($type eq SOURCE) {            # buildscript
            if (has_changed($Keep, $target)) {
                $Keep->set($target,
                    checksum => checksum_file($target),
                    type     => SOURCE,
                );
                $changed = TRUE;
            }
        } else {
            die "ERROR: Corrupt fix state\n" .
                "Field 'type' for file '$target' must be 'target' or 'source'\n";
        }
    }
    return $changed;
}

###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################

# parse command line options
sub getopts {
    my @arg = @_;
    use Getopt::Long qw(
        GetOptionsFromArray :config
        posix_default bundling gnu_compat no_ignore_case permute
    );

    # Modify Getopt::Long's error messages:
    #   'Option <OPT> requires an argument' and 'Unknown option: <OPT>',
    #   should have "'--option'" or "'-o'" rather than just "option" or "o".
    local $SIG{__WARN__} = sub {
        my ($_) = @_;
        s{(\boption[: ]+)(\S+)}{
            my $x = length($2) == 1 ? '-' : '--';
            "$1'$x$2'";
        }ie;
        warn "$NAME: $_";
    };
    GetOptionsFromArray(\@arg,
        'debug|D'  => sub {       ### debug output + make build shells verbose
            $Opt{debug} = $ENV{FIX_DEBUG} = TRUE;
        },
        # 'force|f'  => sub {       ## overwrite manually edited files
        #     $Opt{force} = $ENV{FIX_FORCE} = TRUE;
        # },
        'help|h|?'  => \&help,    ### display this help and exit
        'man|M'     => \&man,     ### display program manpage and exit
        'stats'     => sub{       ##  save stats in .fix dir
            $Opt{stats} = $ENV{FIX_STATS} = TRUE;
        },
        'verbose|v' => sub {      ### output status info while building
            $Opt{verbose} = $ENV{FIX_VERBOSE} = TRUE;
        },
        'version|V' => \&version, ### output version information and exit
        'xtrace|x'  => sub {      ### use xtrace for build shells
            $Opt{xtrace} = $ENV{FIX_XTRACE} = TRUE;
        },
    ) or exit 254;
    if (@arg == 0) {
        warn "No target specified\n" .
            "Try '$NAME --help' for more information.\n";
        exit 254;
    }
    $Run   = new Local::Store("$Opt{fix_dir}/run");
    $Stats = new Local::Store($Opt{fix_dir});
    $Keep  = new Local::Store("$Opt{fix_dir}/keep");
    if ($Opt{stats}) {                         # write child counter
        $Stats->delete('stats')                #   mother deletes earlier stats
            unless is_child();
        $Stats->set('stats',                   #   count fix invocations
            run_count   => sub { (shift() // 0) + 1 },
            run_targets => sub {               #   save args for each call
                my ($x) = (shift() // []);
                push(@$x, \@arg);
                return $x;
            },
        );
    }
    return @arg;
}

###############################################################################
##                                                                           ##
##  Main                                                                     ##
##                                                                           ##
###############################################################################

# run after all globals etc. has been set up properly
__PACKAGE__->run(@ARGV) unless caller();

sub run {
    my ($class, @target) = @_;
    @target = getopts(@target);

    %SIG = (__WARN__ => \&_warn, __DIE__  => \&_die);

    # die on missing buildscripts
    if (my @missing = grep { ! -f "$_.fix" } @target) {
        warn join "", map { "No rule to make '$_'.\n" } @missing;
        exit 254;
    }
    if (is_child()) {                          # CHILD PROCESSES
        $Keep->set($Opt{parent},               #   targets are deps to parent
            add_deps => \@target);
    } else {                                   # MOTHER PROCESS
        $Run->delete('');                      #   delete previous runstate
        # Add the currently running 'fix' command first in $PATH (which is
        # inherited by all child processes). -- This makes sure that all
        # buildscripts that invoke 'fix' find it, even if 'fix' wasn't in the
        # invoking user's $PATH to begin with.
        #
        # We achieve this by creating a '.fix/bin' directory, add a symlink to the
        # 'fix' command there, and tuck that directory name onto the beginning of
        # the $PATH environment variable that gets inherited by our children.
        my $bindir = "$Opt{fix_dir}/bin";
        my $link   = "$Opt{fix_dir}/bin/$NAME";# name of link to create
        if (not -l $link) {                    # if missing '.fix/bin/fix'
            if (not -d $bindir) {              #   make sure '.fix/bin' exists
                mkpath($bindir)
                    or die "$NAME: Cannot create dir '$bindir'\n";
            }
            symlink($Opt{fix_cmd}, $link)
                or die "$NAME: Cannot create symlink '$link': $!\n";
        }
        my $full = Local::Paths::absolute($bindir);
        # FIXME: A directory in $PATH *cannot* contain a colon (stupid, I know).
        # Therefore the cwd cannot contain a colon (we could fix this this by
        # having this stuff in /tmp, I guess).
        if ($full =~ /:/) {                    # guard for stupid system bug
            die "$NAME: Colon not allowed in current dir path ('" .
                Local::Paths::Current() . "')\n";
        }
        $ENV{PATH} = "$full:$ENV{PATH}";       # add dir to path
    }
    update_targets($Opt{level}, @target);
}

__END__

=head1 NAME

fix - Efficiently build (and rebuild) TARGET(s) based on dependencies

=head1 SYNOPSIS

B<fix> [I<OPTION>]... I<TARGET>...

=head1 DESCRIPTION

B<Fix> is a build system. As such, it uses B<buildscripts> to generate output
B<target>s (automatically keeping track said targets' dependencies), and when
invoked it performs the minimal action required to make sure the specified
targets are up-to-date, taking into account any changes in dependencies, or
buildscripts since last invocation.

If that sounds vague, it is simply because a build system can do B<so much> -
it can be used to compile large software projects, generate HTML for a web page
(e.g. using Markdown source code, and template pages), or just about anything
else where you need to keep track of a long chain of dependencies, and B<update
I<only> those parts of the project which currently I<need> updating>.

=head1 OPTIONS

=cut

# Mandatory arguments for long options are mandatory for short options too.

=over 8

=cut

# =item B<--basedir>=I<PATH> (default: Dir in which B<$FIX_CONFDIR> resides)
#
# Set the path to the working tree root. This can also be controlled by setting
# the B<$FIX_BASEDIR> environment variable. It can be an absolute path or a path
# relative to the current working directory.
#
# This does not affect behavior of B<--confdir> (which will work as usual, i.e.
# if unspecified the first encountered B<.fix> dir above the current directory
# will be used).

# =item B<--confdir>=I<PATH> (default: F<.fix> dir in root of current work
# tree)
#
# Set the path to the F<.fix> build metadata directory. This can also be
# controlled by setting the B<$FIX_CONFDIR> environment variable. It can be an
# absolute path or a path relative to the current working directory.
#
# Setting B<$FIX_CONFDIR> will set B<$FIX_BASEDIR> to current dir (unless
# B<$FIX_BASEDIR> is also explicitly set by user).

# =item B<-a>, B<--always>
#
# Assume that all dependencies are dirty, and rebuild B<everything>.

# =item B<-c>, B<--clean>
#
# Remove all generated targets (except manually modified ones). Manually
# modified targets are listed separately, so that you might take care of them.
# If used with B<--force> files are clean regardless of whether or not they
# have been updated.

=item B<-D>, B<--debug>

Enable debug mode. This makes B<fix> to print quite a lot of diagnostics
messages throughout its run (more than B<--verbose>).

This will also pass the option C<-v> to the shell of each buildscript. (This
usually causes the shell to print each I<line> of the script before running it.
The output usually I<unexpanded>; i.e. variables are shown by name, not by
content.) Useful when debugging. See also B<--verbose>.

This option can also be enabled by setting the environment variable
B<$FIX_DEBUG> (to anything except empty or zero). Regardless of whether
B<--debug> or B<$FIX_DEBUG> was used, this causes the B<$FIX_DEBUG> to be
set inside all run buildscripts (which is how this setting is passed down to
all child instances of B<fix> run from within those buildscripts).

=cut

# =item B<-f>, B<--force>
#
# Normally, if you have edited (or otherwise modified) a file that B<fix> is
# trying to rebuild, you'll get an error and the build is interrupted. When you
# use B<--force>, B<fix> will be a lot less careful, and will overwrite these
# files instead. This is useful when you just don't care about these previous
# files for some reason. (Maybe you're doing fully automated rebuilds on a
# continuous integration server?)
#
# If you want to be careful about such cleanups, take a look at B<--clean> and
# B<--list> instead.

=item B<-h>, B<--help>

Output a brief description of options etc on standard output, then exit.

=cut

# =item B<--init>
#
# Create new confdir for build metadata storage. Unless otherwise specified the
# confdir will be created in the current directory.
#
# If B<--base-dir> (or B<$FIX_BASEDIR>) is given then the confdir will be created
# in that directory (so that using C<--base-dir=example> will cause a confdir
# called F<example/.fix> to be created).
#
# Finally, B<--conf-dir> (or B<$FIX_CONFDIR>) can be used to specify the I<exact>
# name of the confdir to be created (so that using C<--conf-dir=example/.fix>
# will cause a confdir called F<example/.fix> to be created). This alternative
# will override the two above.

=item B<-M>, B<--manpage>

Display this manpage, then exit. This option extracts the Perl POD (Plain Old
Documentation) documentation from the program and displays it using man(1).

=item B<--stats>

Write some global build statistics to F<.fix/stats>, and also add
'build_status' information for each processed file in the runstate directory
(F<.fix/run/>). This is primarily intended for testing, and should not normally
be used. (For brevity this option is not included in the B<--help> info.)

=item B<-v>, B<--verbose>

Enable verbose mode, causing B<fix> to print some diagnostics messages
throughout its run (less than B<--debug>).

This option can also be enabled by setting the environment variable
B<$FIX_VERBOSE> (to anything except empty or zero). Regardless of whether
B<--verbose> or B<$FIX_VERBOSE> was used, this causes the B<$FIX_VERBOSE> to be
set inside all run buildscripts (which is how this setting is passed down to
all child instances of B<fix> run from within those buildscripts).

=item B<-V>, B<--version>

Output program version information on standard output, then exit.

=item B<-x>, B<--xtrace>

Pass the option C<-x> to the shell of each buildscript. (This usually causes
the shell to print, preceded by C<+ >, each I<command> of the script before
running it. The output usually I<expanded>; i.e. variables are replaced by
their content.) Useful when debugging. See also B<--verbose>.

This option can also be enabled by setting the environment variable
B<$FIX_XTRACE> (to anything but the empty string or zero). Regardless of
whether B<--xtrace> or B<$FIX_XTRACE> was used, this causes the B<$FIX_XTRACE>
to be set inside all run buildscripts (which is how this setting is passed down
to all child instances of B<fix> run from within those buildscripts).

=back

=head1 DISCUSSION

=head2 Buildscripts

For building to be atomic, build files should produce output by either

=over 3

=item a)

writing to standard output (preferred method), or

=item b)

writing to a tempfile (the name is determined by B<fix> and passed in as the
third argument, B<$3>, to the buildscript). When using this method anything
written to standard output will be ignored.

=back

=cut

# FIXME: Method B is required when generating anything but a standard file
# (i.e. when a buildscript generate a pipe, symlink or directory). Also note
# that target updating will only be atomic when generating a single file.

=head1 EXIT STATUS

B<NOTE: Any buildscript can terminate with exit status 253-255, in which case
its return code is indistinguishable from the below cases!>

=over 4

=item B<0>

All targets and their dependencies were successfully built. (This is the only
exit status which is 100% reliable.)

=item B<E<gt>0>

Build failed. This usually means than one or more target failed to build. The
exact exit status will be the same as the exit status of the failing
buildscript.

=item B<253>

One or more targets were externally modified, and were not overwritten by
B<fix>.

=cut

# (You run the command again with the option B<--force> to force the targets
# overwritten).

=item B<254>

An early error occurred before even attempting to build. (Command line option
parsing error, a non-existing target specified on the command line etc.)

=item B<255>

Some basic file operation failed, e.g. a file could not be renamed, standard
output could not be redirected, a new shell could not be executed, or a
statefile was found to contain unintelligible data etc.

=back

=head1 USAGE

=cut

# =head2 About Target Files
#
# When a target file is built B<fix> records a SHA1 sum of the generated file.
# Upon rebuilding the same target B<fix> uses this SHA1 sum to determine if it
# is okay to overwrite the previous file as follows:
#
# =over 4
#
# =item B<Target file is non-existing or unmodified since last built>
#
# If a previously built target already exist but was written by B<fix> (and has
# not been modified since), B<fix> will do whatever it pleases with the file
# (delete it, overwrite it, whatever).
#
# =item B<Target file has been modified since last built>
#
# If a target file already exists but is unknown to B<fix>, or if the file is
# known but the content of the file has been modified in some way after B<fix>
# wrote it, then B<fix> will refuse to modify it and abort with an error
# message. (Use B<--force> to override this, and have B<fix> overwrite all
# target files.)
#
# B<NOTE:> B<fix> never cares about file timestamps, but only the I<content>.
# (So if you modify the timestamp, will not influence B<fix>'s decision of
# whether or not to overwrite the file.)
#
# =back

=head2 Tips on Debugging

If you enable B<--xtrace> or B<--verbose> for an entire project, the output can
be quite a mess. The trick is to re-invoke B<fix>, after your build has died
with an error message, and build only the failing file using B<--xtrace> or
B<--verbose>. Because the file has previously failed to build, B<fix> is
guaranteed to try to rebuild it, and because B<fix> is bottom-up, the build is
guaranteed to be exactly identical to whatever you would've gotten by building
the entire tree of dependencies.

=cut

# =head1 DIAGNOSTICS
#
# [[ FIXME: The general rule of thumb is that errors printed to C<STDOUT> or
# C<STDERR> and intended for the end user are documented in DIAGNOSTICS while
# errors passed internal to the calling program and intended for other
# programmers are documented in ERRORS. When documenting a function that sets
# errno, a full list of the possible errno values should be given here. ]]

# =head1 EXAMPLES
#
# FIXME: Should include some useful examples!

=head1 ENVIRONMENT VARIABLES

The following variables are exported by B<fix> and are available for use by the
buildscripts. B<A buildscript should never change the content of these
variables> - though in most cases (all but B<$FIX_PARENT>) it is fine to set these
variables from the command line when invoking B<fix>.

=over 6

=item B<$FIX_CMD>

Normally, you do not need to use this environment variable, since B<fix>, when
invoked, always makes sure that that it's binary is first in B<$PATH>, but this
variable contains the name, and full path, of the currently running B<fix>
instance.

You can use this as a command in your buildscripts, to recursively invoke
B<fix>. A buildscript could, for example, look like this:

    $FIX_CMD a b
    cat a b | sed 's/^/>/'

The first line invokes C<fix a b> (thereby declaring F<a> and F<b> to be
dependencies of this script). The second line outputs the content of F<a> and
F<b>, and adds a C<E<gt>> sign to the beginning of each line.

If you started B<fix> by executing a symlink to B<fix>, rather than the actual
B<fix> program, then the name of the symlink will be the name in this variable.

=cut

# =item B<$FIX_BASEDIR>
#
# FIXME: Not yet implemented
#
# Root path of the working tree. This can also be controlled by the
# B<--basedir> command line option. It can be an absolute path or a path
# relative to the current working directory.
#
# This does not affect behavior of B<--confdir> (which will work as usual, i.e.
# if unspecified the first encountered B<.fix> dir above the current directory
# will be used).

# =item B<$FIX_CONFDIR>
#
# FIXME: Not yet implemented
#
# If the B<$FIX_CONFDIR> environment variable is set then it specifies a path to
# use instead of the default F<.fix> for the build metadata directory. It can
# be an absolute path or relative path to current working directory. This can
# also be controlled by the B<--confdir> command line option.
#
# If B<$FIX_CONFDIR> is specified, without B<$FIX_BASEDIR> being set, then the
# current directory will be used as the base dir of the work tree.

=item B<$FIX_DEBUG>

See B<--debug>.

=item B<$FIX_LEVEL>

Incremented by one each time a build process is invoked (a dependency is
built). This is chiefly used to indent the output messages the proper amount.
(Analogous to the shell's B<$SHLVL>.)

=item B<$FIX_PARENT>

The name of the parent target. All dependencies (i.e. all but the mother
process) will have this variable set to the name of its parent target.

=cut

=item B<$FIX_PID>

The process identification number of the mother process.

=item B<$FIX_VERBOSE>

See B<--verbose>.

=item B<$FIX_XTRACE>

See B<--xtrace>.

=back

=head1 FILES

=head2 Buildscripts

A buildscript is simply a small shell script, which outputs something to
standard output.

=cut

# FIXME: Flesh this out

# [[FIXME: All files used by the program or function, normally presented as a
# list, and what it uses them for. File names should be enclosed in F<>.
# It's particularly important to document files that will be potentially
# modified. ]]

# =head1 CAVEATS
#
# [[ FIXME: Things to take special care with, sometimes called WARNINGS. ]]

# =head1 BUGS
#
# [[ FIXME: Things that are broken or just don't work quite right. ]]

# =head1 RESTRICTIONS
#
# [[ FIXME: Bugs you don't plan to fix.  :-) ]]

# =head1 NOTES
#
# [[ FIXME: Miscellaneous commentary. ]]

=head1 GLOSSARY

=over 4

=item B<buildscript>

A buildscript is a small shell script, whose name ends in C<.fix>. Each
buildscript is responsible for producing one B<target>, and declaring its
dependencies. The target as always called the same as the buildscript, but
without the C<.fix> ending.

=item B<build tree>

A build tree is a B<target> plus all of its dependencies. It is B<fix>'s job to
update a target's entire build tree, and make sure that both the target and all
of its dependencies are up-to-date. - This means that all missing dependencies
will be rebuilt, even if they are not directly mentioned on the command line.
Don't worry, if a rebuilt target hasn't changed since its last build, it will
not cause any of its parent targets to rebuild.

=item B<dependency>

A buildscript may declare any number of dependencies for its target (the
buildscript itself always considered a dependency of its own target, too). If a
dependency change then all targets depends on it will be considered B<dirty>,
until they are rebuilt.

=item B<dirty>

A state of unupdatedness in a target or dependency. That a target is C<dirty>,
then it means that content of that file disagrees with what B<fix> thinks it
should be, and the file will be rebuilt next time you invoke B<fix> on it.

=item B<mother process>

This is the process started by the user. The B<mother process> in turn, spawn
off subprocesses (one for each buildscript being run). The mother process is
the only process for which B<$FIX_PARENT> is not set.

In the ideal case, where the entire build tree is already up-to-date, the
mother process is the only process started.

=item B<parent>

The opposite of a B<dependency>. If target F<a> depends on F<b>, then F<b> is
the dependency of F<a>, and F<a> is the parent of F<b>.

=item B<target>

A target, or a target file, is a file generated by a B<buildscript>. A target
can be a B<dependency> or a B<parent> (or both) of another target. Dependencies
can be both other targets (which need to be declared), and B<buildscripts>
(which are automatically figured out by B<fix>).

=back

=head1 AUTHOR

Written by Zrajm C Akfohg <zrajm@klingonska.org>, 2012-2014.

This program is distributed under a Creative Commons Attribution-ShareAlike 3.0
license (CC BY-SA 3.0) [http://creativecommons.org/licenses/by-sa/3.0/].

This means that you may copy, sell and change the program in any way you like,
as long as you still give attribute it to this author, B<zrajm>, and release
your version under the same license. - If you do this, zrajm would love to hear
from you, though!

=head1 HISTORY

My main reasons for writing B<fix> is that I wanted:

=over 2

=item *

Something small, self contained and fast - a single script file, easy move
about. Test suite, docs, everything should be in one file, so that one can
easily include it in any project (in my case for B<Klingonska Akademien>'s web
site [http://klingonska.org]).

=item *

Few dependencies. Everything you need come pre-installed on a standard
GNU/Linux system.

=item *

B<Git>-like behavior. As long as B<fix> is in your path, it works anywhere in
your build tree, it will find its own statedir and generally Just Work[TM], so
that you can write a thing like C<fix ../index.html> and it'll figure out what
to do.

=cut

# [[ FIXME: Make sure this is true. -- You can run it in any subdir under the
# build tree root (your rules will always run with the build tree root as the
# current dir). This is how B<git> works and I wanted my build tool and my
# versioning system to behave the same way. ]]

=back

=head1 SEE ALSO

B<Fix> is heavily inspired by djb's B<redo>, which has been a source of
inspiration for many others as well. I've tried to learn from all of the
implementations I could find, so it's not more than fair that I try to list
them here.

List is in chronological order, and dates are the first date of activity I
could find for each of the projects (date of first git commit, unless
explicitly stated below).

=over 4

=item djb B<redo> (October 13, 2003)

Daniel J. Bernstein's redo has never been released to the public, so all that
exists of it (outside of djb's own computer) are a couple of web pages
describing some of its properties, but nevertheless this has been enough to
fire the imagination of several other (including me). C<Rebuilding target files
when source files have changed> [http://cr.yp.to/redo.html].

=item Grosskurth B<redo> (April 10, 2006)

Alan Grosskurth's B<redo> is written in B<Bourne shell>, consists of 250 lines
of code, and was part of his master's thesis C<Purely top-down software
rebuilding> [http://grosskurth.ca/papers.html]. He also did a slide
presentation before that, C<Reliable software rebuilding>
[http://grosskurth.ca/talks.html]. (Date from slides.)

=item B<tup> (February 14, 2008)

Mike Shal's B<tup> is written in B<C>. It is a top-down building tool, but
differs from most other B<redo> inspired systems in that it uses a single
buildscript for all targets. He has written a paper on B<tup> called C<Build
System Rules and Algorithms> [http://gittup.org/tup/]. Source available on
GitHub [https://github.com/gittup/tup].

=item Apenwarr B<redo> (November 12, 2010)

Avery Pennarun's B<redo> is written in B<Python>, it is well documented and
feature-rich, and implements parallel builds and some other of that fine stuff.
Usually when I wanted to refresh my knowledge about some particular detail of
B<redo> I go to Apenwarr's documentation. Source available on GitHub
[https://github.com/apenwarr/redo].

=item Jekor B<redo> (March 31, 2013)

Chris Forno's B<redo> is written C<on-camera> in Haskell, videos of him writing
it is available on YouTube [http://youtu.be/zZ_nI9E9g0I], and source is
available on GitHub [https://github.com/jekor/redo]. It is written mostly as an
introduction to programming in Haskell, and is not the most feature rich
version of B<redo> out there, it is however instructive to listen to Jekor's
reasoning while he's writing it.

=item B<gup> (November 2, 2013)

Tim Cuthbertson's B<gup> is written in B<Python>, and tries to solve the
problem that B<redo> can be somewhat brittle at times, and fail to rebuild
stuff that it ought to rebuild [http://gfxmonk.net/]. Source available on
GitHub [https://github.com/gfxmonk/gup].

=back

=cut

#[eof]
