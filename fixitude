#!/usr/bin/perl
use strict;
use warnings;
use encoding::warnings 'FATAL';
use 5.10.0;
use utf8;
use open ':utf8';
binmode(STDOUT, ':utf8');

use Cwd qw/cwd realpath/;
use File::Path qw/mkpath rmtree/;              # use 'mkpath' and 'rmtree'
use Encode qw(encode_utf8);
use Digest::SHA qw(sha1_hex);
use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse    = 1;

###############################################################################
##                                                                           ##
##  Settings                                                                 ##
##                                                                           ##
###############################################################################

use vars qw($NAME $VERSION $YEAR);
$VERSION = "0.3";
$YEAR    = "2012-2014";
($NAME)  = __FILE__ =~ m#([^/]*)$#;            # last non-slash part of path

my %opt = (
    shell       => '/bin/dash',
    parent_name => $ENV{FIX_PARENT} // '',     # parent target (set when called by fix itself)
    fix_dir     => ".$NAME",
    level       => $ENV{FIX_LEVEL} += 1,       # child level (mother = 1)
    debug       => $ENV{FIX_DEBUG} ? 1 : 0,    # -D/--debug $FIX_DEBUG
    force       => $ENV{FIX_FORCE} ? 1 : 0,    # -f/--force $FIX_FORCE
);

###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

sub TRUE  { 1 }
sub FALSE { 0 }

sub PLAIN { 0 }                                # loglevel for msg()
sub BOLD  { 1 }

sub ERROR   { 4 }                              # red
sub WARN    { 2 }                              # yellow
sub INFO    { 3 }                              # green
sub VERBOSE { 3 }                              # green
sub DEBUG   { 0 }                              # plain

# Read file stat fingerprint. If this is unchanged since a previous check, know
# the file is unchanged. If fingerprint has changed, then we need to look at
# the file content to determine whether that has changed or not. The following
# lstat() properties are used:
#
#      1 ino      inode number
#      2 mode     file mode (type and permissions)
#      4 uid      numeric user ID of file's owner
#      5 gid      numeric group ID of file's owner
#      7 size     total size of file, in bytes
#      9 mtime    last modify time in seconds since the epoch
#     10 ctime    inode change time in seconds since the epoch (*)
#
# (See: http://www.kernel.org/pub/software/scm/git/docs/technical/racy-git.txt)
sub read_file_fingerprint {
    my ($file) = @_;
    my @stat = lstat($file)
        or die "Failed to stat file '$file': $!\n";
    return join("-", @stat[1, 2, 4, 5, 7, 9, 10]);
}

sub read_file {
    my ($file) = @_;
    open(my $in, "<:utf8", $file)
        or die "Failed to open file '$file' for reading: $!\n";
    local $/ = undef;
    return <$in>;
}

sub rename_file {
    my ($file1, $file2) = @_;
    rename($file1, $file2) or "Failed to rename '$file1' -> '$file2': $!\n";
}

sub write_file {
    my ($outfile, @data) = @_;
    my $tmpfile = "$outfile--writing";
    my $out;
    if (my ($dir) = $tmpfile =~ m#^(.*)/#) {
        if (-e $dir and not -d $dir) {
            warn "$NAME: Failed to create dir '$dir': File exists\n";
            return undef;
        }
        unless (-d $dir or mkpath($dir)) {
            warn "$NAME: Failed to create dir '$dir'\n";
            return undef;
        }
    }
    unless (open $out, ">:utf8", $tmpfile) {
        warn "$NAME: Failed to open tempfile '$tmpfile' for writing: $!\n";
        return undef;
    }
    unless (print $out @data) {
        warn "$NAME: Failed to write data to tempfile '$tmpfile': $!\n";
        return undef;
    }
    unless (close $out) {
        warn "$NAME: Failed to close tempfile '$tmpfile' after writing: $!\n";
        return undef;
    }
    unless (rename($tmpfile, $outfile)) {
        warn "$NAME: Failed rename tempfile '$tmpfile' -> '$outfile' after writing: $!\n";
        return undef;
    }
    return TRUE;
}

# Replace FILE2 with FILE1. If both files are identical (in permissions and
# content), then the old FILE2 is kept as-is (and FILE1 is deleted).
sub replace_file {
    my ($file1, $file2) = @_;
    if (not -f $file1) {
        die "Tempfile '$file1' does not exist, cannot replace target '$file2'\n";
    }
    my ($stat1, $stat2) = map {
        join('-', (lstat($_))[2, 4, 5, 7]);    # (permissions, uid, gid, size)
    } ($file1, $file2);
    # FIXME: Compare files in chunks (to use less RAM usage on big files)
    if ($stat1 eq $stat2                       # files are the same
            and read_file($file1) eq read_file($file2)) {
        unlink $file1                          #   keep old file
            or die "Failed to remove tempfile '$file1' identical to target '$file2': $!\n";
        return 1;
    }
    rename $file1, $file2
        or die "Failed to replace target '$file2' with tempfile '$file1': $!\n";
}

sub sha1 {
    my ($file) = @_;
    return '' unless -f $file;
    sha1_hex(encode_utf8(read_file($file)));
}

# Redirect standard output to FILE. Return hashref suitable for passing to
# restore_stdout(), or die() on failure.
sub redirect_stdout {
    my ($file) = @_;
    my $prev = { flush => $|, handle => undef, file => $file };
    open($prev->{handle}, '>&', 'STDOUT')
        or die "Failed to copy STDOUT before redirect to '$file': $!\n";
    open(STDOUT, '>', $file)
        or die "Failed to redirect STDOUT to file '$file': $!\n";
    select STDOUT;
    local $| = 1;                              # turn off buffering
    return $prev;
}

# Restore standard output after redirect_stdout(). PREV is the hashref returned
# by redirect_stdout(). Die()s on failure.
sub restore_stdout {
    my ($prev) = @_;
    close(STDOUT);
    open(STDOUT, '>&', $prev->{handle})
        or die "Failed to restore STDOUT after redirect to file '$prev->{file}': $!\n";
    close($prev->{handle});
    select STDOUT;
    local $| = $prev->{flush};                 # restore buffering
}

# Redirect standard output to FILE, execute CODEREF, then restore STDOUT.
# CODEREF is passed a single argument containing FILE.
sub redir_stdout {
    my ($file, $coderef) = @_;
    my $oldout = redirect_stdout($file);
    my @result = &$coderef($file);
    restore_stdout($oldout);
    return wantarray() ? @result : $result[0];
}

# build_target($level, $target);
#
# Builds TARGET by executing its buildfile. Return TRUE if the content of
# TARGET was modified because of the (re)build, FALSE if target was not
# modified. Die()s on error.
#
# NOTE: If a target was rebuilt, but the target content remained the same after
# the rebuild, then that target does not count as updated. (This can happen
# e.g. when the build file was modified in a way that did not change its output
# [e.g. a comment was added to it] or if a deleted target with unmodified
# dependencies was rebuilt.)
sub build_target {
    my ($level, $target) = @_;
    info($target);
    if (-f $target and has_changed($target)) {
        set("ABORT/$target",           ABORT => $target);
        set("ABORT/$opt{parent_name}", ABORT => $target)
            if $opt{parent_name};
        msg(ERROR, "$target: Target externally modified, aborting\n");
        exit 1;
    }

    my $buildscript = "$target.fix";
    my $outfile     = "$target--fixing";
    # clear dependency information (rebuilt each run)
    set($target,
        type => 'target',
        deps => [[ $buildscript ]],
    );
    my ($exit_code, $exit, $errno) = redir_stdout($outfile, sub {
        local $ENV{FIX_PARENT} = $target;
        local $ENV{FIX_LEVEL}  = $level;

        # FIXME: Should we allow #! in buildscripts?
        open(my $shell, '|-', $opt{shell}, '-e')
            or die "Failed to execute shell '$opt{shell}': $!\n";
        print $shell read_file($buildscript);

        my $close = close($shell);
        return ($close, $?, $!);
    });

    # NOTE: outfile is kept on failure (so user may inspect it)
    #
    # - Except when a dependency completely failed to run (e.g. its output file
    #   was externally modified) in which case we remove the outfile.
    $exit_code or do {
        $exit >>= 8;
        if ($errno != 0) {
            die "Failed to run buildscript '$buildscript': $errno\n";
        }
        my $aborted = get("ABORT/$target", 'ABORT');
        if ($aborted ne '') {                  # a dependency failed to run
            unlink($outfile);                  #   erase outfile and
            set(                               #     and tell our parent that
                "ABORT/$opt{parent_name}",     #     that we failed, too
                ABORT => $aborted,
            ) if $opt{parent_name};
        } else {                               # a buildscript returned non-zero
            msg(ERROR, "$target: exit status $exit\n");
        }
        exit $exit;
    };

    my $old_checksum = get($target, 'checksum');
    my $new_checksum = sha1($outfile);
    if ($new_checksum eq $old_checksum) {      # target unmodified
        if (-e $target) {                      #   if target exist
            unlink($outfile);
        } else {                               #   if target was deleted
            rename_file($outfile, $target);
        }
        return FALSE;
    }
    rename_file($outfile, $target);            # target modified
    set($target, checksum => $new_checksum);   #   store new checksum
    return TRUE;
}

# FIXME: clean up msg()
{
    my @ansi = ("\e[m", "\e[1m", "\e[33m", "\e[32m", "\e[31m");
    sub msg {
        my ($loglevel, $message) = @_;
        die "msg(): missing loglevel" unless defined $ansi[$loglevel];
        chomp $message;
        say STDERR "$ansi[$loglevel]$NAME " . ("  " x ($opt{level} - 1)) .
            $ansi[BOLD] . $message . $ansi[PLAIN];
    }
}
sub info {
    chomp(my $msg = shift);
    say STDERR "\e[32m$NAME " . ("  " x ($opt{level} - 1)) . "\e[1m$msg\e[m";
}
# Display verbose msg in mother process, or all processes with --verbose/--debug
sub verb { (!$opt{parent} or $opt{debug} or $opt{verbose}) and info @_ }
sub debug {
    return unless $opt{debug};
    chomp(my $msg = shift);
    say STDERR "$NAME " . ("  " x ($opt{level} - 1)) . $msg;
}
sub _warn { msg WARN, @_ }
sub _die  { msg ERROR, @_; exit 255 }

###############################################################################
##                                                                           ##
##  State Storage                                                            ##
##                                                                           ##
###############################################################################

{
    my (%state, %print);
    my $state_dir;

    sub init_state {
        my ($fix_dir) = @_;
        $state_dir = "$fix_dir/state";
        if (not -d $state_dir) {
            mkpath($state_dir)
                or die "$NAME: Failed to create state dir '$state_dir'\n";
        }
    }

    sub delete_state {
        my ($file) = @_;
        my $full = "$state_dir/$file";
        rmtree($full);
    }

    # Rereads the state file every time, since subprocess may have updated it.
    # FIXME: reread file only when it has been changed
    sub get_state {
        my ($file) = @_;
        my $full = "$state_dir/$file";
        if (-f $full) {                        # state file exists
            my $print = read_file_fingerprint($full);
            if ($print ne ($print{$file} // '')) {
                $print{$file} = $print;        #   read if modified
                $state{$file} = eval read_file($full);
            }
        } else {                               # no state file exists
            $state{$file} = { deps => [] };
        }
        return $state{$file};
    }

    # sub load_state {
    #     my ($file) = @_;
    #     if (not exists $state{$file}) {
    #         my $full = "$state_dir/$file";
    #         $state{$file} = -f $full ? eval read_file($full) : {};
    #     }
    #     return $state{$file};
    # }

    sub save_state {
        my ($file) = @_;
        my $full = "$state_dir/$file";
        write_file($full, Dumper $state{$file});
        $print{file} = read_file_fingerprint($full);
    }
}

sub get {
    my ($file, @field) = @_;
    my $state = get_state($file);
    return wantarray()
        ? map { $state->{$_} // '' } @field
        : $state->{ $field[0] } // '';
}

sub set {
    my ($file, %arg) = @_;
    return if $file eq '';
    my $state = get_state($file);
    if (exists $arg{add_deps}) {
        push @{ $state->{deps} }, \@{ delete $arg{add_deps} };
    }
    foreach my $field (keys %arg) {
        $state->{$field} = $arg{$field};
    }
    save_state($file);
}

# NB: $file must exist for has_changed() to give meaningful result
sub has_changed {
    my ($file) = @_;
    my $checksum = get($file, 'checksum');
    return sha1($file) eq $checksum ? FALSE : TRUE;
}

# update_targets($level, @target);
#
# Make sure all TARGET(s) are up-to-date, rebuilding them if necessary. Return
# TRUE if the content one or more TARGET(s) was modified because of a rebuild,
# FALSE if no targets were modified. Die()s on error.
#
# NOTE: If a target was rebuilt, but the target content remained the same after
# the rebuild, then that target does not count as updated. (This can happen
# e.g. when the build file was modified in a way that did not change its output
# [e.g. a comment was added to it] or if a deleted target with unmodified
# dependencies was rebuilt.)
sub update_targets {
    my ($level, @target) = @_;
    local $opt{level} = $level;
    my $changed  = FALSE;
  TARGET: foreach my $target (@target) {
        my ($type, $dep_clusters) = get($target, 'type', 'deps');
        if ($type eq '') {                     # target is not known by fix
            my $buildscript = "$target.fix";
            set($buildscript,
                checksum => sha1($buildscript),
                type     => 'source',
            );
            build_target($level, $target)      #   (all target has at least
                and $changed = TRUE;           #   its own buildfile as dep)
        } elsif ($type eq 'target') {          # file previously seen by fix
            info "$target (previously built)";
            my $deps_changed = FALSE;
            foreach my $deps (@$dep_clusters) {#   check deps
                update_targets($level + 1, @$deps)
                    and $deps_changed = TRUE;
            }
            if ($deps_changed or (not -e $target) or has_changed($target)) {
                build_target($level, $target)
                    and $changed = TRUE;
            }
        } elsif ($type eq 'source') {          # buildscript
            if (has_changed($target)) { $changed = TRUE }
        } else {
            die "ERROR: Corrupt fix state\n" .
                "Field 'type' for file '$target' must be 'target' or 'source'\n";
        }
    }
    return $changed;
}

###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################

# parse command line options
use Getopt::Long qw(
    :config posix_default bundling gnu_compat no_ignore_case permute
);
GetOptions(              # info displayed by help()
    'debug|D'   => sub {             ### enable debugging mode
        $opt{debug} = $ENV{FIX_DEBUG} = 1 },
    'no-debug'   => sub {
        $opt{debug} = $ENV{FIX_DEBUG} = 0 },
    'force|f'   => sub {  ### force overwrite, even when target has changed
        $opt{force} = $ENV{FIX_FORCE} = 1 },
    'no-force'   => sub {  ### force overwrite, even when target has changed
        $opt{force} = $ENV{FIX_FORCE} = 0 },
    #'help|h',            ### display this help and exit
    #'manpage|M',         ### display program manpage and exit
    #'version|V',         ### output version information and exit
) or exit 2;

die "$NAME: No target specified\n\n" .
    "Usage: $NAME [OPTION]... TARGET...\n" .
    "Build the specified TARGET(s).\n"
    unless @ARGV;

%SIG = (__WARN__ => \&_warn, __DIE__  => \&_die);

# die on missing buildscripts
if (my @missing = grep { ! -f "$_.fix" } @ARGV) {
    warn join "", map { "No rule to make '$_'.\n" } @missing;
    exit 2;
}

init_state($opt{fix_dir});

if ($opt{parent_name} eq '') {                 # only mother process
    $ENV{FIX_CMD} = realpath(__FILE__);
    # Add the currently running 'fix' command first in $PATH (which is
    # inherited by all child processes). -- This makes sure that all build
    # scripts that invoke 'fix' find it, even if 'fix' wasn't in the invoking
    # user's $PATH to begin with.
    #
    # We achieve this by creating a '.fix/bin' directory, add a symlink to the
    # 'fix' command there, and tuck that directory name onto the beginning of
    # the $PATH environment variable that gets inherited by our children.
    my $bindir = "$opt{fix_dir}/bin";
    my $link   = "$opt{fix_dir}/bin/$NAME";    # name of link to create
    if (not -l $link) {                        # if missing '.fix/bin/fix'
        if (not -d $bindir) {                  #   make sure '.fix/bin' exists
            mkpath($bindir)
                or die "$NAME: Failed to create dir '$bindir'\n";
        }
        symlink(realpath(__FILE__), $link)
            or die "$NAME: Failed to create symlink '$link': $!\n";
    }
    my $full = realpath($bindir);
    # FIXME: A directory in $PATH *cannot* contain a colon (stupid, I know).
    # Therefore the cwd cannot contain a colon (we could fix this this by
    # having this stuff in /tmp, I guess).
    if ($full =~ /:/) {                        # guard for stupid system bug
        die "$NAME: Colon not allowed in current dir path ('" .
            cwd() . "')\n";
    }
    $ENV{PATH} = "$full:$ENV{PATH}";           # add dir to path
}

###############################################################################
##                                                                           ##
##  Main                                                                     ##
##                                                                           ##
###############################################################################

# delete runstate from previous run
if ($opt{parent_name}) {
    delete_state('ABORT');
    set($opt{parent_name}, add_deps => \@ARGV );
}

update_targets($opt{level}, @ARGV);

__END__

=head1 PRINCIPLES

=head2 About Target Files

When a target file is built B<fix> records a SHA1 sum of the generated file.
Upon rebuilding the same target B<fix> uses this SHA1 sum to determine if it is
okay to overwrite the previous file as follows:

=over 4

=item B<Target file is non-existing or unmodified since last built>

If a previously built target already exist but was written by B<fix> (and has
not been modified since), B<fix> will do whatever it pleases with the file
(delete it, overwrite it, whatever).

=item B<Target file has been modified since last built>

If a target file already exists but is unknown to B<fix>, or if the file is
known but the content of the file has been modified in some way after B<fix>
wrote it, then B<fix> will refuse to modify it and abort with an error message.
(Use B<--force> to override this, and have B<fix> overwrite all target files.)

B<NOTE:> B<fix> never cares about file timestamps, but only the I<content>. (So
if you modify the timestamp, will not influence B<fix>'s decision of whether or
not to overwrite the file.)

=back

=cut

#[eof]
