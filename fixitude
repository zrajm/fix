#!/usr/bin/perl
use strict;
use warnings;
use encoding::warnings 'FATAL';
use 5.10.0;
use utf8;
use open ':utf8';
binmode(STDOUT, ':utf8');

use Cwd qw/cwd realpath/;
#use File::Path qw(mkpath rmtree); # use 'mkpath' and 'rmtree'
use File::Path 'mkpath';
use Encode qw(encode_utf8);
use Digest::SHA qw(sha1_hex);
use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse    = 1;

$ENV{FIX_CMD} = realpath(__FILE__);

#
# FIXME: Unit tests of some kind
#
# FIXME: When a re-compiled target turns out identical to previous one, we
# shouldn't recompile all the stuff that depends on it.
#
# HMMM. Apenwarr redo generates no output file if nothing was written by a
# rule. Is this good? Should we do this too? (Note, however, that apenwarr redo
# also does not attempt to regenerate the non-existing output, unless any
# dependencies have changed. 'redo-ifchange target' works to build the target
# the first time, but after that it does not run unless changes were made in
# the dependencies.)
#
# This in itself is good for a target like 'all', but how about something like
# 'clean'?
#
# FIXME: Replace 'mkpath' with own function.
#
# FIXME: Build test cases
#   o Zero size output should not result in file

###############################################################################
##                                                                           ##
##  Settings                                                                 ##
##                                                                           ##
###############################################################################

use vars qw($NAME $VERSION $YEAR);
$VERSION = "0.2a";
$YEAR    = "2013";
($NAME)  = __FILE__ =~ m#([^/]*)$#;            # last non-slash part of path

my %opt = (
    shell       => '/bin/dash',
    parent_name => $ENV{FIX_PARENT} // "",   # parent target (set when called by fix itself)
    fix_dir     => ".$NAME",
    level       => $ENV{FIX_LEVEL}  += 1,    # child level (mother = 1)
    debug       => 1,
);


###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

sub TRUE { 1 }
sub FALSE { 0 }

sub PLAIN  { 0 } # loglevel for msg()
sub BOLD   { 1 }

sub ERROR   { 4 }   # red
sub WARN    { 2 }   # yellow
sub INFO    { 3 }   # green
sub VERBOSE { 3 }   # green
sub DEBUG   { 0 }   # plain

sub read_file {
    my ($file) = @_;
    open(my $in, "<:utf8", $file)
        or die "Failed to open file '$file' for reading: $!\n";
    local $/ = undef;
    return <$in>;
}

sub write_file {
    my ($outfile, @data) = @_;
    my $tmpfile = "$outfile--writing";
    my $out;
    my $tmpdir = ($tmpfile =~ m#^(.*[^/])/# )[0];
    unless (-d $tmpdir or mkpath($tmpdir)) {
        warn "$NAME: Failed to create dir '$tmpdir'\n";
        return undef;
    }
    unless (open $out, ">:utf8", $tmpfile) {
        warn "$NAME: Failed to open tempfile '$tmpfile' for writing: $!\n";
        return undef;
    }
    unless (print $out @data) {
        warn "$NAME: Failed to write data to tempfile '$tmpfile': $!\n";
        return undef;
    }
    unless (close $out) {
        warn "$NAME: Failed to close tempfile '$tmpfile' after writing: $!\n";
        return undef;
    }
    unless (rename $tmpfile, $outfile) {
        warn "$NAME: Failed rename tempfile '$tmpfile' -> '$outfile' after writing: $!\n";
        return undef;
    }
    return TRUE;
}

sub sha1 {
    my ($file) = @_;
    return '' unless -f $file;
    sha1_hex(encode_utf8(read_file($file)));
}

sub run {
    my ($fixfile, $target) = @_;
    my $do = read_file($fixfile);
    my $tmpfile = "$target--fixing";

    # before running fixfile, clear dependency information
    # (will be rebuilt in the run)
    clear_deps($target);

    my $exit_code;
    {
        open my $oldout, ">&", "STDOUT"
            or die "Failed to copy STDIN before running build script '$fixfile': $!\n";
        open STDOUT, ">", $tmpfile
            or die "Failed to redirect build script STDOUT to tempfile '$tmpfile': $!\n";
        select STDOUT;
        local $| = 1;                          # turn off buffering

        local $ENV{FIX_PARENT} = "$target";

        if (open(my $pipe, '|-', $opt{shell}, '-e')) {
            print $pipe $do;
            if ($exit_code = close($pipe)) {
                if (rename $tmpfile, $target) {
                    set_checksum($target, sha1($target));
                    set_type($target, 'target');
                    add_dep($target, $fixfile);
                    set_checksum($fixfile, sha1($fixfile));
                    set_type($fixfile, 'source');
                } else {
                    warn "Failed to replace '$target' with tempfile '$tmpfile'\n";
                }
            } else {
                warn ($! > 0 ? "Could not run buildscript: $!\n"
                          : "Buildscript failed with exit status: $?\n");
            }
        } else {
            warn "failed to execute shell '$opt{shell}': $!\n";
        };
        close STDOUT;
        open STDOUT, '>&', $oldout
            or die "Failed to reconnect old STDIN after running build script '$fixfile': $!\n";
        close $oldout;
    }
    return $exit_code;
}

# FIXME: clean up msg()
{
    my @ansi = ("\e[m", "\e[1m", "\e[33m", "\e[32m", "\e[31m");
    sub msg {
        my ($loglevel, $message) = @_;
        die "msg(): missing loglevel" unless defined $ansi[$loglevel];
        chomp $message;
        say STDERR "$ansi[$loglevel]$NAME " . ("  " x ($opt{level} - 1)) .
            $ansi[BOLD] . $message . $ansi[PLAIN];
        exit 255 if $loglevel == ERROR;
    }
}
sub info {
    chomp(my $msg = shift);
    say STDERR "\e[32m$NAME " . ("  " x ($opt{level} - 1)) . "\e[1m$msg\e[m";
}
# Display verbose msg in mother process, or all processes with --verbose/--debug
sub verb { (!$opt{parent} or $opt{debug} or $opt{verbose}) and info @_ }
sub debug {
    return unless $opt{debug};
    chomp(my $msg = shift);
    say STDERR "$NAME " . ("  " x ($opt{level} - 1)) . $msg;
}
sub _warn { msg WARN, @_ }
sub _die { msg ERROR, @_ }


###############################################################################
##                                                                           ##
##  State Storage                                                            ##
##                                                                           ##
###############################################################################

{
    my $state = {};
    my $state_dir;

    sub init_state {
        my ($fix_dir) = @_;
        $state_dir = "$fix_dir/state";
        use File::Path 'mkpath';
        if (not -d $state_dir) {
            mkpath($state_dir)
                or die "$NAME: Failed to create state dir '$state_dir'\n";
        }
    }

    # Rereads the state file every time, since subprocess may have updated it.
    sub get_state {
        my ($file) = @_;
        # FIXME: reread file only when it has been changed
        my $full = "$state_dir/$file";
        $state->{$file} = -f $full ? eval read_file($full) : {};
        return $state->{$file};
    }


    sub load_state {
        my ($file) = @_;
        if (not exists $state->{$file}) {
            my $full = "$state_dir/$file";
            $state->{$file} = -f $full ? eval read_file($full) : {};
        }
        return $state->{$file};
    }

    sub save_state {
        my ($file) = @_;
        return write_file("$state_dir/$file", Dumper $state->{$file});
    }
}

sub set_checksum {
    my ($file, $checksum) = @_;
    my $state = get_state($file);
    $state->{checksum} = $checksum;
    save_state($file);
}

sub set_type {
    my ($file, $type) = @_;
    my $state = get_state($file);
    $state->{type} = $type;
    save_state($file);
}

sub clear_deps {
    my ($file, $dep) = @_;
    my $state = get_state($file);
    delete $state->{deps};
    save_state($file);
}

sub add_dep {
    my ($file, @dep) = @_;
    my $state = get_state($file);
    push @{ $state->{deps} }, @dep;
    save_state($file);
}

# NB: $file must exist for has_changed() to give meaningful result
sub has_changed {
    my ($file) = @_;
    my $state = get_state($file);
    return sha1($file) ne $state->{checksum} ? TRUE : FALSE;
}


###############################################################################
##                                                                           ##
##  Main                                                                     ##
##                                                                           ##
###############################################################################

sub xx {
    return;
    my ($indent, $txt) = @_;
    my $spc = "    " x $indent;
    $txt =~ s/^/$spc/me;
    warn $txt;
}

# rebuilds that do not require dependency updates
{
    my (@deleted) = ();
    sub check_deps {
        my ($indent, $targets) = @_;
        $indent += 1;
        my $rebuild_parent = FALSE;
        foreach my $target (@$targets) {
            my $state = get_state($target);

            if (keys %$state == 0) {           # previously unbuilt file
                die "Build script '$target.fix' does not exist\n"
                    unless -f "$target.fix";
                xx $indent, "$target previously unbuilt file";
                $rebuild_parent = TRUE;
                $state->{rebuild} = TRUE;
                next;
            }
            if (not exists $state->{deps}) {   # (no deps) = build file
                if (sha1($target) ne $state->{checksum}) { # build file modified
                    xx $indent, "build file $target HAS CHANGED\n";
                    $rebuild_parent   = TRUE;  #   rebuild parent targets
                } else {
                    xx $indent, "build file $target IS UNCHANGED\n";
                }
                $state->{rebuild} = FALSE;     # never rebuild a build file
                next;
            }

            my $deps_changed = check_deps($indent, $state->{deps});
            xx $indent, "TARGET: $target\n";

            if ($deps_changed) {               # a dependency changed
                xx $indent, "$target \e[42mDEP CHANGED\e[m -- rebuild\n";
                $rebuild_parent   = TRUE;      #   rebuild parents
                $state->{rebuild} = TRUE;      #   rebuild this target
                next;
            }
            if (not -e $target) {              # target deleted (but unchanged)
                # When we get here, we *know* that we have a deleted file with
                # unchanged dependencies. This file when recreated will be
                # identical to the previous file, and so nothing that depends on it
                # will have to be rebuilt.
                xx $indent, "$target \e[42mDELETED\e[m -- rebuild w/o rebuilding deps\n";
                push @deleted, $target;
                $state->{rebuild} = TRUE;      #   rebuild this target
                next;
            }

            if (sha1($target) eq $state->{checksum}) { # target unchanged
                xx $indent, "$target UNCHANGED\n";
                $state->{rebuild} = FALSE;     #   don't rebuild this target
                next;
            } else {                           # target changed
                xx $indent, "$target \e[42mCHANGED\e[m -- rebuild\n";
                $rebuild_parent   = TRUE;      #   rebuild parents
                $state->{rebuild} = TRUE;      #   rebuild this target
                next;
            }
        } continue {
            save_state($target);
        }
        xx $indent, "RETURN \e[7m$rebuild_parent\e[m\n";
        return $rebuild_parent;
    }

    sub deleted {
        return @deleted;
    }
}

die "$NAME: No target specified\n\n" .
    "Usage: $NAME [OPTION]... TARGET...\n" .
    "Build the specified TARGET(s).\n"
    unless @ARGV;
if (my @non_existing = grep { ! -f "$_.fix" } @ARGV) {
    die join "", map {
        "$NAME: Build script '$_.fix' does not exist.\n";
    } @non_existing;
}

init_state($opt{fix_dir});

if (not $opt{parent_name}) {
    # Add the currently running 'fix' command first in $PATH (which is
    # inherited by all child processes). -- This makes sure that all build
    # scripts that invoke 'fix' find it, even if 'fix' wasn't in the invoking
    # user's $PATH to begin with.
    #
    # We achieve this by creating a '.fix/bin' directory, add a symlink to the
    # 'fix' command there, and tuck that directory name onto the beginning of
    # the $PATH environment variable that gets inherited by our children.
    {
        use Cwd 'realpath';
        my $bindir = "$opt{fix_dir}/bin";
        if (not -d $bindir) {                   # make sure '.fix/bin' exists
            mkpath($bindir)
                or die "$NAME: Failed to create dir '$bindir'\n";
        }
        my $link = "$opt{fix_dir}/bin/$NAME";   # name of link to create
        unless (-e $link) {                     # make sure fix symlink exists
            symlink(realpath($0), $link)
                or die "$NAME: Failed to create symlink '$link': $!\n";
        }
        my $full = realpath($bindir);
        if ($full =~ /:/) {                     # guard for stupid system bug
            # FIXME: A directory in $PATH *cannot* contain a colon (stupid, I
            # know). Therefore the cwd cannot contain a colon (we could fix
            # this this by having this stuff in /tmp, I guess).
            die "$NAME: Colon not allowed in current dir path ('" .
                cwd() . "')\n",
        }
        $ENV{PATH} = "$full:$ENV{PATH}";       # add dir to path
    }

    # go through everything and calculate which targets to run

    # walk through dependency storage and mark which targets to 'rebuild'
    if (check_deps(0, \@ARGV)) {
        warn "Dependencies has changed, will rebuild stuff.\n";
    }

    if (my @deleted = deleted()) {
        warn "Deleted files with unchanged dependencies (in build order):\n";
        warn "    $_\n" foreach @deleted;
    }
}

%SIG = (__WARN__ => \&_warn, __DIE__  => \&_die);

foreach my $target (@ARGV) {
    warn "$target\n";
    my $fixfile = "$target.fix";
    unless (-f $fixfile) {                     # ERROR: no build file
        debug "$NAME: Build script '$fixfile' does not exist\n";
        next;
    }
    if (-f $target) {
        if (has_changed($target)) {             # ERROR: target modified
            # FIXME: '--force' option to overwrite changed target files
            die "Target file externally modified, won't overwrite.\n";
        }
        my $state = get_state($target);
        if (not $state->{rebuild}) {            # 
            debug "Target is up-to-date.\n";
            next;
        }
    }

    debug "Modified dependencies, rebuilding\n";
    run $fixfile, $target;
    save_state($target);
}

# add current args as dependency for parent
if ($opt{parent_name}) {
    add_dep($opt{parent_name}, @ARGV);
}

#[eof]


__END__


=head1 PRINCIPLES

=head2 About Target Files

When a target file is built B<fix> records a SHA1 sum of the generated file.
Upon rebuilding the same target B<fix> uses this SHA1 sum to determine if it is
okay to overwrite the previous file as follows:

=over 4

=item B<Target file is non-existing or unmodified since last built>

If a previously built target already exist but was written by B<fix> (and has
not been modified since), B<fix> will do whatever it pleases with the file
(delete it, overwrite it, whatever).

=item B<Target file has been modified since last built>

If a target file already exists but is unknown to B<fix>, or if the file is
known but the content of the file has been modified in some way after B<fix>
wrote it, then B<fix> will refuse to modify it and abort with an error message.
(Use B<--force> to override this, and have B<fix> overwrite all target files.)

B<NOTE:> B<fix> never cares about file timestamps, but only the I<content>. (So
if you modify the timestamp, will not influence B<fix>'s decision of whether or
not to overwrite the file.)

=back

=cut

#[eof]
