#!/usr/bin/perl
use strict;
use warnings;
use encoding::warnings 'FATAL';
use 5.10.0;
use utf8;
use open ':utf8';
binmode(STDOUT, ':utf8');

use Cwd qw/cwd realpath/;
use File::Path qw(mkpath rmtree); # use 'mkpath' and 'rmtree'
use Encode qw(encode_utf8);
use Digest::SHA qw(sha1_hex);
use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse    = 1;

#
# FIXME: Unit tests of some kind
#
# FIXME: When a re-compiled target turns out identical to previous one, we
# shouldn't recompile all the stuff that depends on it.
#
# HMMM. Apenwarr redo generates no output file if nothing was written by a
# rule. Is this good? Should we do this too? (Note, however, that apenwarr redo
# also does not attempt to regenerate the non-existing output, unless any
# dependencies have changed. 'redo-ifchange target' works to build the target
# the first time, but after that it does not run unless changes were made in
# the dependencies.)
#
# This in itself is good for a target like 'all', but how about something like
# 'clean'?

###############################################################################
##                                                                           ##
##  Settings                                                                 ##
##                                                                           ##
###############################################################################

use vars qw($NAME $VERSION $YEAR);
$VERSION = "0.2a";
$YEAR    = "2013";
$NAME    = ($0 =~ m#([^/]*)$#)[0];

my %opt = (
    shell       => '/bin/dash',
    parent_name => $ENV{FIX_PARENT} // "",   # parent target (set when called by fix itself)
    state_file  => '.fix/state',
    level       => $ENV{FIX_LEVEL}  += 1,    # child level (mother = 1)
    debug       => 1,
);


###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

sub TRUE { 1 }
sub FALSE { 0 }

sub PLAIN  { 0 } # loglevel for msg()
sub BOLD   { 1 }

sub ERROR   { 4 }   # red
sub WARN    { 2 }   # yellow
sub INFO    { 3 }   # green
sub VERBOSE { 3 }   # green
sub DEBUG   { 0 }   # plain

sub read_file {
    my ($file) = @_;
    open(my $in, "<:utf8", $file)
        or die "Failed to open file '$file' for reading: $!\n";
    local $/ = undef;
    return <$in>;
}

sub write_file {
    my ($outfile, @data) = @_;
    my $tmpfile = "$outfile--writing";
    my $out;
    unless (open $out, ">:utf8", $tmpfile) {
        warn "Failed to open tempfile '$tmpfile' for writing: $!\n";
        return undef;
    }
    unless (print $out @data) {
        warn "Failed to write data to tempfile '$tmpfile': $!\n";
        return undef;
    }
    unless (close $out) {
        warn "Failed to close tempfile '$tmpfile' after writing: $!\n";
        return undef;
    }
    unless (rename $tmpfile, $outfile) {
        warn "Failed rename tempfile '$tmpfile' -> '$outfile' after writing: $!\n";
        return undef;
    }
    return TRUE;
}

sub sha1 {
    my ($file) = @_;
    return '' unless -f $file;
    sha1_hex(encode_utf8(read_file($file)));
}

sub run {
    my ($fixfile, $target) = @_;
    my $do = read_file($fixfile);
    my $tmpfile = "$target--fixing";

    # before running fixfile, clear dependency information
    # (will be rebuilt in the run)
    clear_deps($target);

    my $exit_code;
    {
        open my $oldout, ">&", "STDOUT"
            or die "Failed to copy STDIN before running build script '$fixfile': $!\n";
        open STDOUT, ">", $tmpfile
            or die "Failed to redirect build script STDOUT to tempfile '$tmpfile': $!\n";
        select STDOUT;
        local $| = 1;                          # turn off buffering

        local $ENV{FIX_PARENT} = "$target";

        if (open(my $pipe, '|-', $opt{shell}, '-e')) {
            print $pipe $do;
            if ($exit_code = close($pipe)) {
                if (rename $tmpfile, $target) {
                    set_checksum($target, sha1($target));
                    set_type($target, 'target');
                    add_dep($target, $fixfile);
                    set_checksum($fixfile, sha1($fixfile));
                    set_type($fixfile, 'source');
                } else {
                    warn "Failed to replace '$target' with tempfile '$tmpfile'\n";
                }
            } else {
                warn ($! > 0 ? "Could not run buildscript: $!\n"
                          : "Buildscript failed with exit status: $?\n");
            }
        } else {
            warn "failed to execute shell '$opt{shell}': $!\n";
        };
        close STDOUT;
        open STDOUT, '>&', $oldout
            or die "Failed to reconnect old STDIN after running build script '$fixfile': $!\n";
        close $oldout;
    }
    return $exit_code;
}

# FIXME: clean up msg()
{
    my @ansi = ("\e[m", "\e[1m", "\e[33m", "\e[32m", "\e[31m");
    sub msg {
        my ($loglevel, $message) = @_;
        die "msg(): missing loglevel" unless defined $ansi[$loglevel];
        chomp $message;
        say STDERR "$ansi[$loglevel]$NAME " . ("  " x ($opt{level} - 1)) .
            $ansi[BOLD] . $message . $ansi[PLAIN];
        exit 255 if $loglevel == ERROR;
    }
}
sub info {
    chomp(my $msg = shift);
    say STDERR "\e[32m$NAME " . ("  " x ($opt{level} - 1)) . "\e[1m$msg\e[m";
}
# Display verbose msg in mother process, or all processes with --verbose/--debug
sub verb { (!$opt{parent} or $opt{debug} or $opt{verbose}) and info @_ }
sub debug {
    return unless $opt{debug};
    chomp(my $msg = shift);
    say STDERR "$NAME " . ("  " x ($opt{level} - 1)) . $msg;
}
sub _warn { msg WARN, @_ }
sub _die { msg ERROR, @_ }


###############################################################################
##                                                                           ##
##  State Storage                                                            ##
##                                                                           ##
###############################################################################

{
    my $state = {};
    my $basedir;

    sub init_state {
        ($basedir) = @_ ? @_ : $basedir;
        use File::Path 'make_path';
        if (not -d $basedir) {
            make_path($basedir)
                or die "Failed to create state dir '$basedir'\n";
        }
    }

    # Rereads the state file every time, since subprocess may have updated it.
    sub get_state {
        my ($file) = @_;
        # FIXME: reread file only when it has been changed
        my $full = "$basedir/$file";
        $state->{$file} = -f $full ? eval read_file($full) : {};
        return $state->{$file};
    }


    sub load_state {
        my ($file) = @_;
        if (not exists $state->{$file}) {
            my $full = "$basedir/$file";
            $state->{$file} = -f $full ? eval read_file($full) : {};
        }
        return $state->{$file};
    }

    sub save_state {
        my ($file) = @_;
        return write_file("$basedir/$file", Dumper $state->{$file});
    }

}

sub set_checksum {
    my ($file, $checksum) = @_;
    my $state = get_state($file);
    $state->{checksum} = $checksum;
    save_state($file);
}

sub set_type {
    my ($file, $type) = @_;
    my $state = get_state($file);
    $state->{type} = $type;
    save_state($file);
}

sub clear_deps {
    my ($file, $dep) = @_;
    my $state = get_state($file);
    delete $state->{deps};
    save_state($file);
}

sub add_dep {
    my ($file, @dep) = @_;
    my $state = get_state($file);
    push @{ $state->{deps} }, @dep;
    save_state($file);
}

# NB: $file must exist for has_changed() to give meaningful result
sub has_changed {
    my ($file) = @_;
    my $state = get_state($file);
    return sha1($file) ne $state->{checksum} ? TRUE : FALSE;
}


###############################################################################
##                                                                           ##
##  Main                                                                     ##
##                                                                           ##
###############################################################################

sub xx {
    return;
    my ($indent, $txt) = @_;
    my $spc = "    " x $indent;
    $txt =~ s/^/$spc/me;
    warn $txt;
}

# rebuilds that do not require dependency updates
{
    my (@deleted) = ();
    sub check_deps {
        my ($indent, $targets) = @_;
        $indent += 1;
        my $rebuild_parent = FALSE;
        foreach my $target (@$targets) {
            my $state = get_state($target);

            if (keys %$state == 0) {           # previously unbuilt file
                die "Build script '$target.fix' does not exist\n"
                    unless -f "$target.fix";
                xx $indent, "$target previously unbuilt file";
                $rebuild_parent = TRUE;
                $state->{rebuild} = TRUE;
                next;
            }
            if (not exists $state->{deps}) {   # (no deps) = build file
                if (sha1($target) ne $state->{checksum}) { # build file modified
                    xx $indent, "build file $target HAS CHANGED\n";
                    $rebuild_parent   = TRUE;  #   rebuild parent targets
                } else {
                    xx $indent, "build file $target IS UNCHANGED\n";
                }
                $state->{rebuild} = FALSE;     # never rebuild a build file
                next;
            }

            my $deps_changed = check_deps($indent, $state->{deps});
            xx $indent, "TARGET: $target\n";

            if ($deps_changed) {               # a dependency changed
                xx $indent, "$target \e[42mDEP CHANGED\e[m -- rebuild\n";
                $rebuild_parent   = TRUE;      #   rebuild parents
                $state->{rebuild} = TRUE;      #   rebuild this target
                next;
            }
            if (not -e $target) {              # target deleted (but unchanged)
                # When we get here, we *know* that we have a deleted file with
                # unchanged dependencies. This file when recreated will be
                # identical to the previous file, and so nothing that depends on it
                # will have to be rebuilt.
                xx $indent, "$target \e[42mDELETED\e[m -- rebuild w/o rebuilding deps\n";
                push @deleted, $target;
                $state->{rebuild} = TRUE;      #   rebuild this target
                next;
            }

            if (sha1($target) eq $state->{checksum}) { # target unchanged
                xx $indent, "$target UNCHANGED\n";
                $state->{rebuild} = FALSE;     #   don't rebuild this target
                next;
            } else {                           # target changed
                xx $indent, "$target \e[42mCHANGED\e[m -- rebuild\n";
                $rebuild_parent   = TRUE;      #   rebuild parents
                $state->{rebuild} = TRUE;      #   rebuild this target
                next;
            }
        } continue {
            save_state($target);
        }
        xx $indent, "RETURN \e[7m$rebuild_parent\e[m\n";
        return $rebuild_parent;
    }

    sub deleted {
        return @deleted;
    }
}

if (my @non_existing = grep { ! -f $_ } @ARGV) {
    die join "", map {
        "$NAME: Build script '$_.fix' does not exist.\n";
    } @non_existing;
}


init_state $opt{state_file};
if (not $opt{parent_name}) {
    # go through everything and calculate which targets to run

    # walk through dependency storage and mark which targets to 'rebuild'

    if (check_deps(0, \@ARGV)) {
        warn "Dependencies has changed, will rebuild stuff.\n";
    }

    if (my @deleted = deleted()) {
        warn "Deleted files with unchanged dependencies (in build order):\n";
        warn "    $_\n" foreach @deleted;
    }
}

%SIG = (__WARN__ => \&_warn, __DIE__  => \&_die);

foreach my $target (@ARGV) {
    warn "$target\n";
    my $fixfile = "$target.fix";
    unless (-f $fixfile) {                     # ERROR: no build file
        debug "Build script '$fixfile' does not exist\n";
        next;
    }
    if (-f $target) {
        if (has_changed($target)) {             # ERROR: target modified
            # FIXME: '--force' option to overwrite changed target files
            die "Target file externally modified, won't overwrite.\n";
        }
        my $state = get_state($target);
        if (not $state->{rebuild}) {            # 
            debug "Target is up-to-date.\n";
            next;
        }
    }

    debug "Modified dependencies, rebuilding\n";
    run $fixfile, $target;
    save_state($target);
}

# add current args as dependency for parent
if ($opt{parent_name}) {
    add_dep($opt{parent_name}, @ARGV);
}

#[eof]
