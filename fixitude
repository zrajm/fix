#!/usr/bin/perl
use strict;
use warnings;
use encoding::warnings 'FATAL';
use 5.10.0;
use utf8;
use open ':utf8';
binmode(STDOUT, ':utf8');

use Cwd qw/cwd realpath/;
use File::Path 'mkpath';                       # use 'mkpath' and 'rmtree'
use Encode qw(encode_utf8);
use Digest::SHA qw(sha1_hex);
use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse    = 1;

#
# FIXME: Unit tests of some kind
#
# FIXME: When a re-compiled target turns out identical to previous one, we
# shouldn't recompile all the stuff that depends on it.
#
# HMMM. Apenwarr redo generates no output file if nothing was written by a
# rule. Is this good? Should we do this too? (Note, however, that apenwarr redo
# also does not attempt to regenerate the non-existing output, unless any
# dependencies have changed. 'redo-ifchange target' works to build the target
# the first time, but after that it does not run unless changes were made in
# the dependencies.)
#
# This in itself is good for a target like 'all', but how about something like
# 'clean'?
#
# FIXME: Replace 'mkpath' with own function.
#
# FIXME: Build test cases
#   o Zero size output should not result in file

###############################################################################
##                                                                           ##
##  Settings                                                                 ##
##                                                                           ##
###############################################################################

use vars qw($NAME $VERSION $YEAR);
$VERSION = "0.2a";
$YEAR    = "2013";
($NAME)  = __FILE__ =~ m#([^/]*)$#;            # last non-slash part of path

my %opt = (
    shell       => '/bin/dash',
    parent_name => $ENV{FIX_PARENT} // '',   # parent target (set when called by fix itself)
    fix_dir     => ".$NAME",
    level       => $ENV{FIX_LEVEL} += 1,     # child level (mother = 1)
    debug       => $ENV{FIX_DEBUG} ? 1 : 0,  # -D/--debug $FIX_DEBUG
    force       => $ENV{FIX_FORCE} ? 1 : 0,  # -f/--force $FIX_FORCE
);

###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

sub TRUE { 1 }
sub FALSE { 0 }

sub PLAIN  { 0 } # loglevel for msg()
sub BOLD   { 1 }

sub ERROR   { 4 }   # red
sub WARN    { 2 }   # yellow
sub INFO    { 3 }   # green
sub VERBOSE { 3 }   # green
sub DEBUG   { 0 }   # plain

# Read file stat fingerprint. If this is unchanged since a previous check, know
# the file is unchanged. If fingerprint has changed, then we need to look at
# the file content to determine whether that has changed or not. The following
# lstat() properties are used:
#
#      1 ino      inode number
#      2 mode     file mode (type and permissions)
#      4 uid      numeric user ID of file's owner
#      5 gid      numeric group ID of file's owner
#      7 size     total size of file, in bytes
#      9 mtime    last modify time in seconds since the epoch
#     10 ctime    inode change time in seconds since the epoch (*)
#
# (See: http://www.kernel.org/pub/software/scm/git/docs/technical/racy-git.txt)
sub read_file_fingerprint {
    my ($file) = @_;
    my @stat = lstat($file)
        or die "Failed to stat file '$file': $!\n";
    return join("-", @stat[1, 2, 4, 5, 7, 9, 10]);
}

sub read_file {
    my ($file) = @_;
    open(my $in, "<:utf8", $file)
        or die "Failed to open file '$file' for reading: $!\n";
    local $/ = undef;
    return <$in>;
}

sub write_file {
    my ($outfile, @data) = @_;
    my $tmpfile = "$outfile--writing";
    my $out;
    my $tmpdir = ($tmpfile =~ m#^(.*[^/])/# )[0];
    unless (-d $tmpdir or mkpath($tmpdir)) {
        warn "$NAME: Failed to create dir '$tmpdir'\n";
        return undef;
    }
    unless (open $out, ">:utf8", $tmpfile) {
        warn "$NAME: Failed to open tempfile '$tmpfile' for writing: $!\n";
        return undef;
    }
    unless (print $out @data) {
        warn "$NAME: Failed to write data to tempfile '$tmpfile': $!\n";
        return undef;
    }
    unless (close $out) {
        warn "$NAME: Failed to close tempfile '$tmpfile' after writing: $!\n";
        return undef;
    }
    unless (rename($tmpfile, $outfile)) {
        warn "$NAME: Failed rename tempfile '$tmpfile' -> '$outfile' after writing: $!\n";
        return undef;
    }
    return TRUE;
}

# Replace FILE2 with FILE1. If both files are identical (in permissions and
# content), then the old FILE2 is kept as-is (and FILE1 is deleted).
sub replace_file {
    my ($file1, $file2) = @_;
    if (not -f $file1) {
        die "Tempfile '$file1' does not exist, cannot replace target '$file2'\n";
    }
    my ($stat1, $stat2) = map {
        join('-', (lstat($_))[2, 4, 5, 7]);    # (permissions, uid, gid, size)
    } ($file1, $file2);
    # FIXME: Compare files in chunks (to use less RAM usage on big files)
    if ($stat1 eq $stat2                       # files are the same
            and read_file($file1) eq read_file($file2)) {
        unlink $file1                          #   keep old file
            or die "Failed to remove tempfile '$file1' identical to target '$file2': $!\n";
        return 1;
    }
    rename $file1, $file2
        or die "Failed to replace target '$file2' with tempfile '$file1': $!\n";
}

sub sha1 {
    my ($file) = @_;
    return '' unless -f $file;
    sha1_hex(encode_utf8(read_file($file)));
}

# Redirect standard output to FILE. Return hashref suitable for passing to
# restore_stdout(), or die() on failure.
sub redirect_stdout {
    my ($file) = @_;
    my $prev = { flush => $|, handle => undef, file => $file };
    open($prev->{handle}, '>&', 'STDOUT')
        or die "Failed to copy STDOUT before redirect to '$file': $!\n";
    open(STDOUT, '>', $file)
        or die "Failed to redirect STDOUT to file '$file': $!\n";
    select STDOUT;
    local $| = 1;                              # turn off buffering
    return $prev;
}

# Restore standard output after redirect_stdout(). PREV is the hashref returned
# by redirect_stdout(). Die()s on failure.
sub restore_stdout {
    my ($prev) = @_;
    close(STDOUT);
    open(STDOUT, '>&', $prev->{handle})
        or die "Failed to restore STDOUT after redirect to file '$prev->{file}': $!\n";
    close($prev->{handle});
    select STDOUT;
    local $| = $prev->{flush};                 # restore buffering
}

# Redirect standard output to FILE, execute CODEREF, then restore STDOUT.
# CODEREF is passed a single argument containing FILE.
sub redir_stdout {
    my ($file, $coderef) = @_;
    my $oldout = redirect_stdout($file);
    &$coderef($file);
    restore_stdout($oldout);
}

# build_target($target);
#
# Builds TARGET by executing its buildfile. Return TRUE if build succeeded.
sub build_target {
    my ($target) = @_;
    my $exit_code;
    my $outfile = "$target--fixing";
    my $buildscript = "$target.fix";
    redir_stdout($outfile, sub {

        local $ENV{FIX_PARENT} = $target;

        # FIXME: Should we allow #! in buildscripts?
        open(my $shell, '|-', $opt{shell}, '-e')
            or die "Failed to execute shell '$opt{shell}': $!\n";
        print $shell read_file($buildscript);

        # NB: outfile is kept on failure (so user may inspect it)
        $exit_code = close($shell) or do {
            my $errno = $!;
            if ($errno != 0) {
                die "Failed to run buildscript '$buildscript': $errno\n";
            }
            my $exit = $? >> 8;
            msg(ERROR, "$target: exit status $exit\n");
            exit $exit;
        };
    });
    replace_file($outfile, $target);
    return $exit_code;
}

# Run a buildscript, return its exit code.
sub run {
    my ($target) = @_;
    my $buildscript = "$target.fix";
    my $do = read_file($buildscript);

    if (not -f $buildscript) {
        warn("$NAME: Buildscript '$buildscript' does not exist.\n");
        exit 2;
    }
    if (-f $target and has_changed($target)) {
        warn("Target '$target' externally modified, won't overwrite.\n");
        exit 1;
    }

    # clear dependency information (is rebuilt each run)
    set($target, deps => []);

    my $exit_code = build_target($target);
    set($target,
        checksum => sha1($target),
        type     => 'target',
        add_deps => [ $buildscript ],
    );
    set($buildscript,
        checksum => sha1($buildscript),
        type     => 'source',
    );

    return $exit_code;
}

# FIXME: clean up msg()
{
    my @ansi = ("\e[m", "\e[1m", "\e[33m", "\e[32m", "\e[31m");
    sub msg {
        my ($loglevel, $message) = @_;
        die "msg(): missing loglevel" unless defined $ansi[$loglevel];
        chomp $message;
        say STDERR "$ansi[$loglevel]$NAME " . ("  " x ($opt{level} - 1)) .
            $ansi[BOLD] . $message . $ansi[PLAIN];
    }
}
sub info {
    chomp(my $msg = shift);
    say STDERR "\e[32m$NAME " . ("  " x ($opt{level} - 1)) . "\e[1m$msg\e[m";
}
# Display verbose msg in mother process, or all processes with --verbose/--debug
sub verb { (!$opt{parent} or $opt{debug} or $opt{verbose}) and info @_ }
sub debug {
    return unless $opt{debug};
    chomp(my $msg = shift);
    say STDERR "$NAME " . ("  " x ($opt{level} - 1)) . $msg;
}
sub _warn { msg WARN, @_ }
sub _die { msg ERROR, @_; exit 255 }

###############################################################################
##                                                                           ##
##  State Storage                                                            ##
##                                                                           ##
###############################################################################

{
    my (%state, %print);
    my $state_dir;

    sub init_state {
        my ($fix_dir) = @_;
        $state_dir = "$fix_dir/state";
        use File::Path 'mkpath';
        if (not -d $state_dir) {
            mkpath($state_dir)
                or die "$NAME: Failed to create state dir '$state_dir'\n";
        }
    }

    # Rereads the state file every time, since subprocess may have updated it.
    # FIXME: reread file only when it has been changed
    sub get_state {
        my ($file) = @_;
        my $full  = "$state_dir/$file";
        if (-f $full) {                        # state file exists
            my $print = read_file_fingerprint($full);
            if ($print ne ($print{$file} // '')) {
                $print{$file} = $print;        #   read if modified
                $state{$file} = eval read_file($full);
            }
        } else {                               # no state file exists
            $state{$file} = {
                deps => [], type => '',
            };
        }
        return $state{$file};
    }

    # sub load_state {
    #     my ($file) = @_;
    #     if (not exists $state{$file}) {
    #         my $full = "$state_dir/$file";
    #         $state{$file} = -f $full ? eval read_file($full) : {};
    #     }
    #     return $state{$file};
    # }

    sub save_state {
        my ($file) = @_;
        my $full = "$state_dir/$file";
        write_file($full, Dumper $state{$file});
        $print{file} = read_file_fingerprint($full);
    }
}

sub get {
    my ($file, @field) = @_;
    my $state = get_state($file);
    return wantarray()
        ? map { $state->{$_} } @field
        : $state->{ $field[0] };
}

sub set {
    my ($file, %arg) = @_;
    my $state = get_state($file);
    if (exists $arg{add_deps}) {
        push @{ $state->{deps} }, @{ delete $arg{add_deps} };
    }
    foreach my $field (keys %arg) {
        $state->{$field} = $arg{$field};
    }
    save_state($file);
}

# NB: $file must exist for has_changed() to give meaningful result
sub has_changed {
    my ($file) = @_;
    my $checksum = get($file, 'checksum');
    return sha1($file) ne $checksum ? TRUE : FALSE;
}

sub xx {
    return;
    my ($indent, $txt) = @_;
    my $spc = "    " x $indent;
    $txt =~ s/^/$spc/me;
    warn $txt;
}

# rebuilds that do not require dependency updates
{
    my @deleted;
    sub check_deps {
        my ($indent, $targets) = @_;
        $indent += 1;
        my $rebuild_parent = FALSE;
        foreach my $target (@$targets) {
            my $state = get_state($target);

            if (keys %$state == 0) {           # previously unbuilt file
                die "Buildscript '$target.fix' does not exist\n"
                    unless -f "$target.fix";
                xx $indent, "$target previously unbuilt file";
                $rebuild_parent = TRUE;
                $state->{rebuild} = TRUE;
                next;
            }
            if (not exists $state->{deps}) {   # (no deps) = build file
                if (sha1($target) ne $state->{checksum}) { # build file modified
                    xx $indent, "build file $target HAS CHANGED\n";
                    $rebuild_parent   = TRUE;  #   rebuild parent targets
                } else {
                    xx $indent, "build file $target IS UNCHANGED\n";
                }
                $state->{rebuild} = FALSE;     # never rebuild a build file
                next;
            }

            my $deps_changed = check_deps($indent, $state->{deps});
            xx $indent, "TARGET: $target\n";

            if ($deps_changed) {               # a dependency changed
                xx $indent, "$target \e[42mDEP CHANGED\e[m -- rebuild\n";
                $rebuild_parent   = TRUE;      #   rebuild parents
                $state->{rebuild} = TRUE;      #   rebuild this target
                next;
            }
            if (not -e $target) {              # target deleted (but unchanged)
                # When we get here, we *know* that we have a deleted file with
                # unchanged dependencies. This file when recreated will be
                # identical to the previous file, and so nothing that depends on it
                # will have to be rebuilt.
                xx $indent, "$target \e[42mDELETED\e[m -- rebuild w/o rebuilding deps\n";
                push @deleted, $target;
                $state->{rebuild} = TRUE;      #   rebuild this target
                next;
            }

            if (sha1($target) eq $state->{checksum}) { # target unchanged
                xx $indent, "$target UNCHANGED\n";
                $state->{rebuild} = FALSE;     #   don't rebuild this target
                next;
            } else {                           # target changed
                xx $indent, "$target \e[42mCHANGED\e[m -- rebuild\n";
                $rebuild_parent   = TRUE;      #   rebuild parents
                $state->{rebuild} = TRUE;      #   rebuild this target
                next;
            }
        } continue {
            save_state($target);
        }
        xx $indent, "RETURN \e[7m$rebuild_parent\e[m\n";
        return $rebuild_parent;
    }

    sub deleted { @deleted }
}

###############################################################################
##                                                                           ##
##  Initialisation                                                           ##
##                                                                           ##
###############################################################################

# parse command line options
use Getopt::Long qw(
    GetOptionsFromArray :config posix_default bundling gnu_compat
    no_ignore_case permute pass_through
);
GetOptions(              # info displayed by help()
    \%opt,               # ========================
    'debug|D'   => sub {             ### enable debugging mode
        $opt{debug} = $ENV{FIX_DEBUG} = 1 },
    'no-debug'   => sub {
        $opt{debug} = $ENV{FIX_DEBUG} = 0 },
    'force|f'   => sub {  ### force overwrite, even when target has changed
        $opt{force} = $ENV{FIX_FORCE} = 1 },
    'no-force'   => sub {  ### force overwrite, even when target has changed
        $opt{force} = $ENV{FIX_FORCE} = 0 },

    #'help|h',            ### display this help and exit
    #'manpage|M',         ### display program manpage and exit
    #'version|V',         ### output version information and exit
) or exit 2;

die "$NAME: No target specified\n\n" .
    "Usage: $NAME [OPTION]... TARGET...\n" .
    "Build the specified TARGET(s).\n"
    unless @ARGV;

%SIG = (__WARN__ => \&_warn, __DIE__  => \&_die);

# die on missing buildscripts
if (my @missing = grep { ! -f "$_.fix" } @ARGV) {
    warn join "", map { "No rule to make '$_'.\n" } @missing;
    exit 2;
}

init_state($opt{fix_dir});

if ($opt{parent_name} eq '') {                 # only mother process
    $ENV{FIX_CMD} = realpath(__FILE__);

    # Add the currently running 'fix' command first in $PATH (which is
    # inherited by all child processes). -- This makes sure that all build
    # scripts that invoke 'fix' find it, even if 'fix' wasn't in the invoking
    # user's $PATH to begin with.
    #
    # We achieve this by creating a '.fix/bin' directory, add a symlink to the
    # 'fix' command there, and tuck that directory name onto the beginning of
    # the $PATH environment variable that gets inherited by our children.
    {
        my $bindir = "$opt{fix_dir}/bin";
        my $link   = "$opt{fix_dir}/bin/$NAME"; # name of link to create
        if (not -l $link) {                     # if missing '.fix/bin/fix'
            if (not -d $bindir) {               #   make sure '.fix/bin' exists
                mkpath($bindir)
                    or die "$NAME: Failed to create dir '$bindir'\n";
            }
            symlink(realpath(__FILE__), $link)
                or die "$NAME: Failed to create symlink '$link': $!\n";
        }
        my $full = realpath($bindir);
        if ($full =~ /:/) {                     # guard for stupid system bug
            # FIXME: A directory in $PATH *cannot* contain a colon (stupid, I
            # know). Therefore the cwd cannot contain a colon (we could fix
            # this this by having this stuff in /tmp, I guess).
            die "$NAME: Colon not allowed in current dir path ('" .
                cwd() . "')\n",
        }
        $ENV{PATH} = "$full:$ENV{PATH}";       # add dir to path
    }

    # go through everything and calculate which targets to run

    # walk through dependency storage and mark which targets to 'rebuild'
    if (check_deps(0, \@ARGV)) {
        warn "Dependencies has changed, will rebuild stuff.\n";
    }

    if (my @deleted = deleted()) {
        print STDERR "Deleted files with unchanged dependencies (in build order):\n";
        print STDERR "    $_\n" foreach @deleted;
    }
}

###############################################################################
##                                                                           ##
##  Main                                                                     ##
##                                                                           ##
###############################################################################

foreach my $target (@ARGV) {
    warn "$target\n";
    if (-f $target) {
        if (has_changed($target)) {             # ERROR: target modified
            # FIXME: '--force' option to overwrite changed target files
            msg ERROR, "Target file '$target' externally modified, won't overwrite.\n";
            exit 1;
        }
        if (not get($target, 'rebuild')) {
            debug "Target file '$target' is up-to-date.\n";
            next;
        }
    }

    debug "Modified dependencies, rebuilding\n";
    run($target);
    save_state($target);
}

# add current args as dependency for parent
if ($opt{parent_name}) {
    set($opt{parent_name}, add_deps => \@ARGV);
}

__END__

=head1 PRINCIPLES

=head2 About Target Files

When a target file is built B<fix> records a SHA1 sum of the generated file.
Upon rebuilding the same target B<fix> uses this SHA1 sum to determine if it is
okay to overwrite the previous file as follows:

=over 4

=item B<Target file is non-existing or unmodified since last built>

If a previously built target already exist but was written by B<fix> (and has
not been modified since), B<fix> will do whatever it pleases with the file
(delete it, overwrite it, whatever).

=item B<Target file has been modified since last built>

If a target file already exists but is unknown to B<fix>, or if the file is
known but the content of the file has been modified in some way after B<fix>
wrote it, then B<fix> will refuse to modify it and abort with an error message.
(Use B<--force> to override this, and have B<fix> overwrite all target files.)

B<NOTE:> B<fix> never cares about file timestamps, but only the I<content>. (So
if you modify the timestamp, will not influence B<fix>'s decision of whether or
not to overwrite the file.)

=back

=cut

#[eof]
