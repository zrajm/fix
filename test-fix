#!/usr/bin/perl
use strict;
use warnings;
use 5.10.0;
use Test::More;
use Cwd qw/cwd realpath/;
use File::Path 'rmtree';

use Carp 'confess';
$SIG{__DIE__} = \&Carp::confess;

our $name  = 'fix';
our $keep  = ".$name/keep";                     # keepstate directory
our $run   = ".$name/run";                      # runstate directory
our $stats = ".$name/stats";
our $fix   = realpath(__FILE__ =~ s#[^/]+$#$name#r);

BEGIN {                                        # load 'fix' as a module
    use Cwd qw/realpath/;
    $fix = realpath(__FILE__ =~ s#[^/]+$#fix#r);
    require $fix;
    Module->import();
}

###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

# Delete file(s). Ignore errors if file is gone in the end.
sub delete_file {
    my (@file) = @_;
    foreach my $file (@file) {
        unlink($file) or do {
            my $msg = $!;
            die "Failed to delete file '$file': $msg," if -e $file;
        };
    }
}

# Write to a temporary file, so that we know the inode number will change when
# a file is rewritten (which guarantees that a newly written file will have a
# different stat fingerprint, even if it have the same content). Thus we know
# don't have to use Time::HiRes to get sub-second resolution in the
# fingerprinting.
sub write_file {
    my %arg = @_;
    foreach my $file (keys %arg) {
        my $outfile = "$file--tmp";
        open(my $out, '>', $outfile)
            or die "Cannot open file '$outfile' for writing: $!,";
        print $out $arg{$file};
        close($out)
            or die "Cannot close file '$outfile' after writing: $!,";
        rename($outfile, $file)
            or die "Cannot rename file '$outfile' -> '$file' after writing: $!,";
    }
}

sub read_file {
    my ($file) = @_;
    open(my $in, '<', $file)
        or die "Failed to open file '$file' for reading: $!,";
    local $/ = undef;
    return <$in>;
}

# Return stat fingerprint (or empty string if file doesn't exist).
#
# Note: We can't use Time::HiRes here, since it only supports lstat() since
# February 2013. [https://rt.cpan.org/Public/Bug/Display.html?id=83356]
sub read_file_fingerprint {
    my ($file) = @_;
    my @stat = lstat($file);
    return join("-", @stat ? @stat[1, 2, 4, 5, 7, 9, 10] : ());
}

# Return hash of filenames (as keys) and stat fingerprints (as values).
sub fingerprints {
    my (@file) = @_;
    return map {
        $_ => read_file_fingerprint($_);
    } @file;
}

sub make_tempdir {
    my ($name) = @_;
    my $tempdir = `mktemp -td $name-XXXXXX`;
    chomp($tempdir);
    return $tempdir;
}

sub enter_dir {
    my ($dir) = @_;
    mkdir($dir) or die "Cannot create '$dir': $!,";
    chdir($dir) or die "Cannot cd to '$dir': $!,";
    $ENV{PWD} = $dir;
}

sub nl { join "", map "$_\n", @_ }

sub sha1 {
    my ($data) = @_;
    use Digest::SHA qw(sha1_hex);
    use Encode qw(encode_utf8);
    sha1_hex(encode_utf8($data));
}

# Return keys in hash, sorted by first by length, then alphabetically.
sub key {
    my %x = @_;
    sort { length($a) <=> length($b) or $a cmp $b } keys %x;
}

sub serialize {
    my (%x) = @_;
    use Data::Dumper;
    local $Data::Dumper::Indent   = 1;
    local $Data::Dumper::Sortkeys = 1;
    local $Data::Dumper::Terse    = 1;
    return Dumper \%x;
}

# for use with keepstate()
sub SOURCE { 'source' }
sub TARGET { 'target' }
sub keepstate {
    my ($type, $content, @deps) = @_;
    my %x;
    $x{type}     = $type;
    $x{deps}     = [ @deps ] if @deps;
    $x{checksum} = sha1($content) if defined $content;
    return serialize(%x);
}

# for use with status()
sub SAME_DEPS   { 'wont_rebuild' }
sub WONT_OVERWR { 'wont_overwrite' }
sub SHELL_FAIL  { 'shell_error' }
sub BUILD_FAIL  { 'buildscript_error' }
sub KEPT_PREV   { 'rebuilt_but_kept_previous' }
sub REPL_ERASED { 'rebuilt_replaced_deleted' }
sub NEW_CONTENT { 'rebuilt_new_content' }
sub runstate {
    my ($build_status, $abort_status, $abort_target) = @_;
    my %x;
    $x{ABORT}        = $abort_target if defined($abort_status);
    $x{build_status} = $build_status if defined($build_status);
    return serialize(%x);
}

sub run_fix {
    my ($args, $files, $before, $after) = @_;
    $files  //= [];
    $before //= sub {};
    $after  //= sub {};
    die 'run_fix() $args must be plain string,' if ref($args)   ne '';
    die 'run_fix() $files must be arrayref,'    if ref($files)  ne 'ARRAY';
    die 'run_fix() $before must be coderef,'    if ref($before) ne 'CODE';
    die 'run_fix() $after must be coderef,'     if ref($after)  ne 'CODE';
    my %pre = fingerprints(@$files);

    $before->();

    # run command
    note("Run: fix $args");
    note("Dir: $ENV{PWD}");
    my $exit = system("$fix $args 2> stderr.txt");
    # check output for Perl errors/warnings
    unlike(read_file('stderr.txt'), qr/Use of uninitialized value/,
           "No Perl warning 'uninitialized value'");
    delete_file('stderr.txt');

    $after->();

    my %post = fingerprints(@$files);
    return ($exit, \%pre, \%post);
}

sub execcount {
    my $data = eval read_file($stats);
    return $data->{run_count};
}

###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################

# check if there is an 'exit' statement in this file
my $exit_statement_in_test_script = read_file(__FILE__) =~ /^\s*exit/m;

my $testdir = make_tempdir($name);

###############################################################################
##                                                                           ##
##  Internal Tests (Testing Functions in the Program)                        ##
##                                                                           ##
###############################################################################
note
    "====================================\n" .
    " Internal Tests (Testing Functions)\n" .
    "====================================";

enter_dir("$testdir/internal-tests");

note 'split_path()';
# FIXME: What *should* split_path('.') return?
my @test = (
    [ qw( a/b/c     a/b     c ) ],
    [ qw( a/b/c/    a/b     c ) ],
    [ qw( a/b/c///  a/b     c ) ],
    [ qw( a/b//c/   a/b     c ) ],
    [ qw( a//b/c    a//b    c ) ],
    [ qw( /a/b/c    /a/b    c ) ],
    [ qw( a         .       a ) ],
    [ qw( /a        /       a ) ],
);
# We run the function twice, because it looks prettier to report basenames and
# dirnames separately in the output.
foreach my $test (@test) {
    my ($path, $expect_dir, undef) = @$test;
    my ($dir_result, undef) = Local::Modulino::split_path($path);
    is ($dir_result, $expect_dir, "Dirname: $path");
}
foreach my $test (@test) {
    my ($path, undef, $expect_file) = @$test;
    my (undef, $file_result) = Local::Modulino::split_path($path);
    is ($file_result, $expect_file, "Basename: $path");
}

note 'default_buildfiles()';
{
    my %tests = (
        'hej.a.b.c' => [
            'default.a.b.c.fix',
            'default.a.b.fix',
            'default.a.fix',
            'default.fix' ],
        'a' => [
            'default.fix' ],
    );
    for (key %tests) {
        my $expect = $tests{$_};
        is_deeply([ Local::Modulino::possible_buildfiles($_) ], $expect,
                  "Files: $_");
    }
}

note 'Local::Paths::clean()';
{
    my @test = (
        './a'        => 'a',
        '../a'       => '../a',
        '../../a'    => '../../a',
        '.'          => '.',
        './.'        => '.',
        './..'       => '..',
        './'         => '.',                   # odd corner case
        '/.'         => '/',                   # odd corner case
        '/'          => '/',
        '/a'         => '/a',
        '/a/..'      => '/',
        '/a/../..'   => '/',
        '/a/b/../..' => '/',
        'a'          => 'a',
        'a/'         => 'a',
        'a/../..'    => '..',
        'a/../../..' => '../..',
        'a/../b/c'   => 'b/c',
        'a/../../c'  => '../c',
        'a/./b'      => 'a/b',
        'a//b'       => 'a/b',
        'a/b'        => 'a/b',
        'a/b/../..'  => '.',
        'a/b/c/..'   => 'a/b',
    );
    while (@test) {
        my ($_, $expect) = splice(@test, 0, 2);
        is(Local::Paths::clean($_), $expect, "Path: $_");
    }
}

note "Local::Store, simple use";
{
    my $test = new Local::Store(dir => 'storage');
    my ($x, $y);

    $x = eval { $test->get('file'); 1 };
    is  ($x, undef, "get() without fields should die");
    like($@, qr/Missing arguments: No field names given/,
                    "get() without fields error message");

    $x = $test->get('file', 'foo');
    is  ($x, undef, "get() on non-existing field");
    $x = $test->set('file', foo => 'bar', apa => 'bepa');
    ok  ($x, "set() return status");
    for ('storage/file') {
        ok  ( -f $_, "set() file existence: $_");
        is  (read_file($_), serialize(foo => 'bar', apa => 'bepa'),
             "set() file content: $_");
    }

    ($x, $y) = $test->get('file', 'foo', 'apa');
    is  ($x, 'bar',  'get() with two existing fields, 1st field');
    is  ($y, 'bepa', 'get() with two existing fields, 2nd field');
    ($x, $y) = $test->get('file', 'apa', 'foo');
    is  ($x, 'bepa', 'get() with two existing fields in opposite order, 1st field');
    is  ($y, 'bar',  'get() with two existing fields in opposite order, 2nd field');

    my %expected = ( foo => 'bar', apa => 'bepa' );
    foreach (qw/foo apa/) {
        $x = $test->get('file', $_);
        is  ($x, $expected{$_}, "get() with one field in scalar context: $_");
    }
}

###############################################################################
##                                                                           ##
##  External Tests (Running the Program, Testing Build Results)              ##
##                                                                           ##
###############################################################################
note
    "========================================\n" .
    " External Tests (Testing Build Results)\n" .
    "========================================";

my %c;                                         # Mnemonic: 'content'
enter_dir("$testdir/external-tests");

note "No '.fixrc'";
{
    my ($r) = run_fix(
        '--stats 1',
    );

    is  ($r >> 8,      254, "Exit status");
    ok  (! -e $stats,       "Statsfile non-existing");
    ok  (! -e $run,         "Runstate dir non-existing");
    ok  (! -e $keep,        "Keepstate dir non-existing");
}

write_file('.fixrc' => '');

note "No argument given";
{
    my ($r) = run_fix(
        '--stats',
    );

    is  ($r >> 8,      254, "Exit status");
    ok  (! -e $stats,       "Statsfile non-existing");
    ok  (! -e $run,         "Runstate dir non-existing");
    ok  (! -e $keep,        "Keepstate dir non-existing");
}

note "Bad command line option";
{
    my ($r) = run_fix(
        '--stats --BAD-OPTION',
    );

    is  ($r >> 8,      254, "Exit status");
    ok  (! -e $stats,       "Statsfile non-existing");
    ok  (! -e $run,         "Runstate dir non-existing");
    ok  (! -e $keep,        "Keepstate dir non-existing");
}

note "Non-existing buildscript";
{
    my ($r) = run_fix(
        '--stats NON-EXISTING-TARGET',
    );

    is  ($r >> 8,           254,             "Exit status");
    is  (execcount(),         1,             "Run count");
    ok  (! -f 'NON-EXISTING-TARGET.fix',     "Buildfile non-existing");
    ok  (! -f 'NON-EXISTING-TARGET--fixing', "Tempfile non-existing");
    ok  (! -f 'NON-EXISTING-TARGET',         "Target non-existing");
    ok  (! -e $run,                          "Runstate dir non-existing");
    ok  (! -e $keep,                         "Keepstate dir non-existing");
}

write_file('../outside.fix', '');

note "Buildscript outside work tree";
{
    my ($r) = run_fix(
        '--stats ../outside',
    );

    is  ($r >> 8,           254,     "Exit status");
    is  (execcount(),         1,     "Run count");
    ok  (  -f '../outside.fix',      "Buildfile existing");
    ok  (! -f '../outside--fixing',  "Tempfile non-existing");
    ok  (! -f '../outside',          "Target non-existing");
    ok  (! -e $run,                  "Runstate dir non-existing");
    ok  (! -e $keep,                 "Keepstate dir non-existing");
}

$c{'1.fix'} = nl('echo FIRST', 'exit 1', 'echo SECOND');
write_file('1.fix', $c{'1.fix'});

note "Buildscript with exit status = 1";
{
    delete_file('1--fixing');

    my ($r, $a, $b) = run_fix(
        '--stats 1',
        [qw( 1.fix 1--fixing )],
    );
    my %a = %$a;
    my %b = %$b;

    is  ($r >> 8,                1,               "Exit status");
    is  (execcount(),            1,               "Run count");
    is  ($a{'1.fix'},            $b{'1.fix'},     "Buildscript unchanged");
    ok  (  -f '1--fixing',                        "Tempfile existing");
    isnt($a{'1--fixing'},        $b{'1--fixing'}, "Tempfile updated");
    is  (read_file('1--fixing'), nl('FIRST'),     "Tempfile content");
    ok  (! -f '1',                                "Target non-existing");
    ok  (  -e $run,                               "Runstate dir existing");
    is  (read_file("$run/1"), runstate(BUILD_FAIL),
                                                  "Runstate content: 1");
    ok  (  -e $keep,                              "Keepstate dir existing");
    is  (read_file("$keep/1"), keepstate(TARGET, undef, [ '1.fix' ]),
                                                  "Keepstate content: 1");
    is  (read_file("$keep/1.fix"), keepstate(SOURCE, $c{'1.fix'}),
                                                  "Keepstate content: 1.fix");
}

$c{'1.fix'} = nl('echo FIRST', 'exit 2', 'echo SECOND');
write_file('1.fix', $c{'1.fix'});

note "Buildscript with exit status = 2";
{
    delete_file('1--fixing');

    my ($r, $a, $b) = run_fix(
        '--stats 1',
        [qw( 1.fix 1--fixing )],
    );
    my %a = %$a;
    my %b = %$b;

    is  ($r >> 8,                2,               "Exit status");
    is  (execcount(),            1,               "Run count");
    is  ($a{'1.fix'},            $b{'1.fix'},     "Buildscript unchanged");
    ok  (  -f '1--fixing',                        "Tempfile existing");
    isnt($a{'1--fixing'},        $b{'1--fixing'}, "Tempfile updated");
    is  (read_file('1--fixing'), nl('FIRST'),     "Tempfile content");
    ok  (! -f '1',                                "Target non-existing");
    ok  (  -e $run,                               "Runstate dir existing");
    is  (read_file("$run/1"), runstate(BUILD_FAIL),
                                                  "Runstate content: 1");
    ok  (  -e $keep,                              "Keepstate dir existing");
    is  (read_file("$keep/1"), keepstate(TARGET, undef, [ '1.fix' ]),
                                                  "Keepstate content: 1");
    is  (read_file("$keep/1.fix"), keepstate(SOURCE, $c{'1.fix'}),
                                                  "Keepstate content: 1.fix");
}

$c{'1.fix'} = nl('echo FIRST', 'false', 'echo SECOND');
write_file('1.fix', $c{'1.fix'});

note "Buildscript with command returning false";
{
    delete_file('1--fixing');

    my ($r, $a, $b) = run_fix(
        '--stats 1',
        [qw( 1.fix 1--fixing )],
    );
    my %a = %$a;
    my %b = %$b;

    is  ($r >> 8,                1,               "Exit status");
    is  (execcount(),            1,               "Run count");
    is  ($a{'1.fix'},            $b{'1.fix'},     "Buildscript unchanged");
    ok  (  -f '1--fixing',                        "Tempfile existing");
    isnt($a{'1--fixing'},        $b{'1--fixing'}, "Tempfile updated");
    is  (read_file('1--fixing'), nl('FIRST'),     "Tempfile content");
    ok  (! -f '1',                                "Target non-existing");
    ok  (  -e $run,                               "Runstate dir existing");
    is  (read_file("$run/1"), runstate(BUILD_FAIL),
                                                  "Runstate content: 1");
    ok  (  -e $keep,                              "Keepstate dir existing");
    is  (read_file("$keep/1"), keepstate(TARGET, undef, [ '1.fix' ]),
                                                  "Keepstate content: 1");
    is  (read_file("$keep/1.fix"), keepstate(SOURCE, $c{'1.fix'}),
                                                  "Keepstate content: 1.fix");
}

$c{'1.fix'} = nl("NONEXISTING-SHELL-COMMAND");
write_file('1.fix', $c{'1.fix'});

note "Buildscript with non-existing command";
{
    delete_file('1--fixing');

    my ($r, $a, $b) = run_fix(
        '--stats 1',
        [qw( 1.fix 1--fixing )],
    );
    my %a = %$a;
    my %b = %$b;

    is  ($r >> 8,                127,             "Exit status");
    is  (execcount(),            1,               "Run count");
    is  ($a{'1.fix'},            $b{'1.fix'},     "Buildscript unchanged");
    ok  (-f '1--fixing',                          "Tempfile existing");
    isnt($a{'1--fixing'},        $b{'1--fixing'}, "Tempfile updated");
    is  (read_file('1--fixing'), '',              "Tempfile content");
    ok  (! -f '1',                                "Target non-existing");
    ok  (  -e $run,                               "Runstate dir existing");
    is  (read_file("$run/1"), runstate(BUILD_FAIL),
                                                  "Runstate content: 1");
    ok  (  -e $keep,                              "Keepstate dir existing");
    is  (read_file("$keep/1"), keepstate(TARGET, undef, [ '1.fix' ]),
                                                  "Keepstate content: 1");
    is  (read_file("$keep/1.fix"), keepstate(SOURCE, $c{'1.fix'}),
                                                  "Keepstate content: 1.fix");
}

$c{'1.fix'} = nl('echo $1', 'echo $2');
$c{'1'}     = nl("$ENV{PWD}/1--fixing", "$ENV{PWD}/1");
write_file('1.fix', $c{'1.fix'});

note 'First run of (working) buildscript + $1 and $2';
{
    my ($r, $a, $b) = run_fix(
        '--stats 1',
        [qw( 1.fix 1 )],
    );
    my %a = %$a;
    my %b = %$b;

    is  ($r >> 8,           0,           "Exit status");
    is  (execcount(),       1,           "Run count");
    is  ($a{'1.fix'},       $b{'1.fix'}, "Buildscript unchanged");
    ok  (! -f '1--fixing',               "Tempfile non-existing");
    ok  (  -f '1',                       "Target existing");
    isnt($a{'1'},           $b{'1'},     "Target updated");
    is  (read_file('1'),    $c{'1'},     "Target content");
    ok  (  -e $run,                      "Runstate dir existing");
    is  (read_file("$run/1"), runstate(NEW_CONTENT),
                                                  "Runstate content: 1");
    ok  (  -e $keep,                     "Keepstate dir existing");
    is  (read_file("$keep/1"), keepstate(TARGET, $c{'1'}, [ '1.fix' ]),
                                         "Keepstate content: 1");
    is  (read_file("$keep/1.fix"), keepstate(SOURCE, $c{'1.fix'}),
                                         "Keepstate content: 1.fix");
}

note "Rerun without changes";
{
    my ($r, $a, $b) = run_fix(
        '--stats 1',
        [qw( 1.fix 1 )],
    );
    my %a = %$a;
    my %b = %$b;

    is  ($r >> 8,           0,           "Exit status");
    is  (execcount(),       1,           "Run count");
    is  ($a{'1.fix'},       $b{'1.fix'}, "Buildscript unchanged");
    ok  (! -f '1--fixing',               "Tempfile non-existing");
    ok  (  -f '1',                       "Target existing");
    is  ($a{'1'},           $b{'1'},     "Target unchanged");
    is  (read_file('1'),    $c{'1'},     "Target content");
    ok  (  -e $run,                      "Runstate dir existing");
    is  (read_file("$run/1"), runstate(SAME_DEPS),
                                                  "Runstate content: 1");
    ok  (  -e $keep,                     "Keepstate dir existing");
    is  (read_file("$keep/1"), keepstate(TARGET, $c{'1'}, [ '1.fix' ]),
                                         "Keepstate content: 1");
    is  (read_file("$keep/1.fix"), keepstate(SOURCE, $c{'1.fix'}),
                                         "Keepstate content: 1.fix");
}

note "Rerun after target was externally modified";
{
    write_file('1', nl('XXX'));    # modify target file

    my ($r, $a, $b) = run_fix(
        '--stats 1',
        [qw( 1.fix 1 )],
    );
    my %a = %$a;
    my %b = %$b;

    is  ($r >> 8,           253,         "Exit status");
    is  (execcount(),         1,         "Run count");
    is  ($a{'1.fix'},       $b{'1.fix'}, "Buildscript unchanged");
    ok  (! -f '1--fixing',               "Tempfile non-existing");
    ok  (  -f '1',                       "Target existing");
    is  ($a{'1'},           $b{'1'},     "Target unchanged");
    is  (read_file('1'),    nl('XXX'),   "Target content");
    ok  (  -e $run,                      "Runstate dir existing");
    is  (read_file("$run/1"), runstate(WONT_OVERWR, ABORT => '1'),
                                         "Runstate content: 1");
    ok  (  -e $keep,                     "Keepstate dir existing");
    is  (read_file("$keep/1"), keepstate(TARGET, $c{'1'}, [ '1.fix' ]),
                                         "Keepstate content: 1");
    is  (read_file("$keep/1.fix"), keepstate(SOURCE, $c{'1.fix'}),
                                         "Keepstate content: 1.fix");
}

note "Rerun after target was deleted";
{
    delete_file('1');

    my ($r, $a, $b) = run_fix(
        '--stats 1',
        [qw( 1.fix 1 )],
    );
    my %a = %$a;
    my %b = %$b;

    is  ($r >> 8,           0,           "Exit status");
    is  (execcount(),       1,           "Run count");
    is  ($a{'1.fix'},       $b{'1.fix'}, "Buildscript unchanged");
    ok  (! -f '1--fixing',               "Tempfile non-existing");
    ok  (  -f '1',                       "Target existing");
    isnt($a{'1'},           $b{'1'},     "Target updated");
    is  (read_file('1'),    $c{'1'},     "Target content");
    ok  (  -e $run,                      "Runstate dir existing");
    is  (read_file("$run/1"), runstate(REPL_ERASED),
                                         "Runstate content: 1");
    ok  (  -e $keep,                     "Keepstate dir existing");
    is  (read_file("$keep/1"), keepstate(TARGET, $c{'1'}, [ '1.fix' ]),
                                         "Keepstate content: 1");
    is  (read_file("$keep/1.fix"), keepstate(SOURCE, $c{'1.fix'}),
                                         "Keepstate content: 1.fix");
}

$c{'1.fix'} = nl('# COMMENT', 'echo $1', 'echo $2');
$c{'1'}     = nl("$ENV{PWD}/1--fixing", "$ENV{PWD}/1");
write_file('1.fix', $c{'1.fix'});

note "Rerun after buildscript was changed, but give same output";
{
    my ($r, $a, $b) = run_fix(
        '--stats 1',
        [qw( 1.fix 1 )],
    );
    my %a = %$a;
    my %b = %$b;

    is  ($r >> 8,           0,           "Exit status");
    is  (execcount(),       1,           "Run count");
    is  ($a{'1.fix'},       $b{'1.fix'}, "Buildscript unchanged");
    ok  (! -f '1--fixing',               "Tempfile non-existing");
    ok  (  -f '1',                       "Target existing");
    is  ($a{'1'},           $b{'1'},     "Target unchanged");
    is  (read_file('1'),    $c{'1'},     "Target content");
    ok  (  -e $run,                      "Runstate dir existing");
    is  (read_file("$run/1"), runstate(KEPT_PREV),
                                         "Runstate content: 1");
    ok  (  -e $keep,                     "Keepstate dir existing");
    is  (read_file("$keep/1"), keepstate(TARGET, $c{'1'}, [ '1.fix' ]),
                                         "Keepstate content: 1");
    is  (read_file("$keep/1.fix"), keepstate(SOURCE, $c{'1.fix'}),
                                         "Keepstate content: 1.fix");
}

note "Rerun after buildscript was changed, and give new output";
$c{'1.fix'} = nl('echo 1');
$c{'1'}     = nl('1');
write_file('1.fix', $c{'1.fix'});
{
    my ($r, $a, $b) = run_fix(
        '--stats 1',
        [qw( 1.fix 1 )],
    );
    my %a = %$a;
    my %b = %$b;

    is  ($r >> 8,           0,           "Exit status");
    is  (execcount(),       1,           "Run count");
    is  ($a{'1.fix'},       $b{'1.fix'}, "Buildscript unchanged");
    ok  (! -f '1--fixing',               "Tempfile non-existing");
    ok  (  -f '1',                       "Target existing");
    isnt($a{'1'},           $b{'1'},     "Target updated");
    is  (read_file('1'),    nl('1'),     "Target content");
    ok  (  -e $run,                      "Runstate dir existing");
    is  (read_file("$run/1"), runstate(NEW_CONTENT),
                                         "Runstate content: 1");
    ok  (  -e $keep,                     "Keepstate dir existing");
    is  (read_file("$keep/1"), keepstate(TARGET, $c{'1'}, [ '1.fix' ]),
                                         "Keepstate content: 1");
    is  (read_file("$keep/1.fix"), keepstate(SOURCE, $c{'1.fix'}),
                                         "Keepstate content: 1.fix");
}

mkdir("a");
$c{'a/1.fix'} = nl('echo 1');
$c{'a/1'}     = nl('1');
write_file('a/1.fix', $c{'1.fix'});

note "Buildscript creating target in subdir";
{
    my ($r, $a, $b) = run_fix(
        '--stats a/1',
        [qw( a/1.fix a/1 )],
    );
    my %a = %$a;
    my %b = %$b;

    is  ($r >> 8,            0,             "Exit status");
    is  (execcount(),        1,             "Run count");
    is  ($a{'a/1.fix'},      $b{'a/1.fix'}, "Buildscript unchanged");
    ok  (! -f 'a/1--fixing',                "Tempfile non-existing");
    ok  (  -f 'a/1',                        "Target existing");
    isnt($a{'a/1'},          $b{'a/1'},     "Target updated");
    is  (read_file('a/1'),   nl('1'),       "Target content");
    ok  (  -e $run,                         "Runstate dir existing");
    is  (read_file("$run/a/1"), runstate(NEW_CONTENT),
                                            "Runstate content: 1");
    ok  (  -e $keep,                        "Keepstate dir existing");
    is  (read_file("$keep/a/1"), keepstate(TARGET, $c{'1'}, [ 'a/1.fix' ]),
                                             "Keepstate content: 1");
    is  (read_file("$keep/a/1.fix"), keepstate(SOURCE, $c{'1.fix'}),
                                             "Keepstate content: 1.fix");
}

# clear heretofore generated files
rmtree([ ".$name", qw/ 1 1.fix a / ]);
write_file(my %source = (
    'a.fix'    => nl('echo a'),
    'b.fix'    => nl('echo b'),
    '1.fix'    => nl('echo 1'),
    '2.fix'    => nl('echo 2'),
    '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat 1 2 | sed "s/^/>/"'),
    'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat a b | sed "s/^/>/"'),
    'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
));
my %target = (                                 # expected target content
    a    => nl(qw/           a                 /),
    b    => nl(qw/               b             /),
    1    => nl(qw/                       1     /),
    2    => nl(qw/                           2 /),
    ab   => nl(qw/      ab  >a  >b             /),
    12   => nl(qw/                  12  >1  >2 /),
    ab12 => nl(qw/ab12 >ab >>a >>b >12 >>1 >>2 /),
);
my %target_deps = (
    1    => [[ '1.fix'    ]],
    2    => [[ '2.fix'    ]],
    a    => [[ 'a.fix'    ]],
    b    => [[ 'b.fix'    ]],
    ab   => [[ 'ab.fix'   ], [qw/  a  b /]],
    12   => [[ '12.fix'   ], [qw/  1  2 /]],
    ab12 => [[ 'ab12.fix' ], [qw/ ab 12 /]],
);

note "First run of buildscript with dependencies";
{
    my ($exit, $pre, $post) = run_fix(
        '--stats ab12',
        [ key(%source, %target) ],
    );
    my %pre  = %$pre;
    my %post = %$post;

    is  ($exit >> 8,        0,           "Exit status");
    is  (execcount(),       4,           "Run count");
    is  ($pre{$_},          $post{$_},   "Buildscript unchanged: $_")
        for key %source;
    ok  (! -f "$_--fixing",              "Tempfile non-existing: $_--fixing")
        for key %target;
    ok  (  -f $_,                        "Target existing: $_") for key %target;
    isnt($pre{$_},          $post{$_},   "Target updated: $_")  for key %target;
    is  (read_file($_),     $target{$_}, "Target content: $_")  for key %target;
    ok  (  -e $run,                      "Runstate dir existing");
    is  (read_file("$run/$_"), runstate(NEW_CONTENT),
                                         "Runstate content: $_") for key %target;
    ok  (  -e $keep,                     "Keepstate dir existing");
    is  (read_file("$keep/$_"), keepstate(SOURCE, $source{$_}),
                                         "Keepstate content: $_") for key %source;
    is  (read_file("$keep/$_"), keepstate(TARGET, $target{$_}, @{ $target_deps{$_} }),
                                         "Keepstate content: $_") for key %target;
}

note "Rerun without change";
{
    my ($exit, $pre, $post) = run_fix(
        '--stats ab12',
        [ key(%source, %target) ],
    );
    my %pre  = %$pre;
    my %post = %$post;

    is  ($exit >> 8,    0,           "Exit status");
    is  (execcount(),   1,           "Run count");
    is  ($pre{$_},      $post{$_},   "Buildscript unchanged: $_") for key %source;
    ok  (! -f "$_--fixing",          "Tempfile non-existing: $_--fixing") for key %target;
    ok  (  -f $_,                    "Target existing: $_")   for key %target;
    is  ($pre{$_},      $post{$_},   "Target unchanged: $_")  for key %target;
    is  (read_file($_), $target{$_}, "Target content: $_")    for key %target;
    ok  (  -e $run,                  "Runstate dir existing");
    is  (read_file("$run/$_"), runstate(SAME_DEPS),
                                     "Runstate content: $_") for key %target;
    ok  (  -e $keep,                 "Keepstate dir existing");
    is  (read_file("$keep/$_"), keepstate(SOURCE, $source{$_}),
                                     "Keepstate content: $_") for key %source;
    is  (read_file("$keep/$_"), keepstate(TARGET, $target{$_}, @{ $target_deps{$_} }),
                                     "Keepstate content: $_") for key %target;
}

$source{'2.fix'} = nl('echo 22');
write_file('2.fix', $source{'2.fix'});

# changes in expected target content
$target{2}    = nl(qw/                           22 /);
$target{12}   = nl(qw/                  12  >1  >22 /);
$target{ab12} = nl(qw/ab12 >ab >>a >>b >12 >>1 >>22 /);

note "Rerun after change of subtarget '2'";
{
    my ($exit, $pre, $post) = run_fix(
        '--stats ab12',
        [ key(%source, %target) ],
    );
    my %pre  = %$pre;
    my %post = %$post;

    is  ($exit >> 8,    0,           "Exit status");
    is  (execcount(),   3,           "Run count");
    is  ($pre{$_},      $post{$_},   "Buildscript unchanged: $_") for key %source;
    ok  (! -f "$_--fixing",          "Tempfile non-existing: $_--fixing") for key %target;
    ok  (  -f $_,                    "Target existing: $_")   for key %target;
    isnt($pre{$_},      $post{$_},   "Target updated: $_")    for qw/2 12 ab12/;
    is  ($pre{$_},      $post{$_},   "Target unchanged: $_")  for qw/a b 1 ab/;
    is  (read_file($_), $target{$_}, "Target content: $_")    for key %target;
    ok  (  -e $run,                  "Runstate dir existing");
    is  (read_file("$run/$_"), runstate(SAME_DEPS),
                                     "Runstate content: $_") for qw/a b 1 ab/;
    is  (read_file("$run/$_"), runstate(NEW_CONTENT),
                                     "Runstate content: $_") for qw/2 12 ab12/;
    ok  (  -e $keep,                 "Keepstate dir existing");
    is  (read_file("$keep/$_"), keepstate(SOURCE, $source{$_}),
                                     "Keepstate content: $_") for key %source;
    is  (read_file("$keep/$_"), keepstate(TARGET, $target{$_}, @{ $target_deps{$_} }),
                                     "Keepstate content: $_") for key %target;
}

note "Rerun after a dependency '12' was deleted";
{
    delete_file('12');

    my ($exit, $pre, $post) = run_fix(
        '--stats ab12',
        [ key(%source, %target) ],
    );
    my %pre  = %$pre;
    my %post = %$post;

    is  ($exit >> 8,    0,           "Exit status");
    is  (execcount(),   2,           "Run count");
    is  ($pre{$_},      $post{$_},   "Buildscript unchanged: $_") for key %source;
    ok  (! -f "$_--fixing",          "Tempfile non-existing: $_--fixing") for key %target;
    ok  (  -f $_,                    "Target existing: $_")   for key %target;
    isnt($pre{$_},      $post{$_},   "Target updated: $_")    for qw/12/;
    is  ($pre{$_},      $post{$_},   "Target unchanged: $_")  for qw/a b 1 2 ab ab12/;
    is  (read_file($_), $target{$_}, "Target content: $_")    for key %target;
    ok  (  -e $run,                  "Runstate dir existing");
    is  (read_file("$run/$_"), runstate(SAME_DEPS),
                                     "Runstate content: $_") for qw/a b 1 2 ab ab12/;
    is  (read_file("$run/$_"), runstate(REPL_ERASED),
                                     "Runstate content: $_") for qw/12/;
    ok  (  -e $keep,                 "Keepstate dir existing");
    is  (read_file("$keep/$_"), keepstate(SOURCE, $source{$_}),
                                     "Keepstate content: $_") for key %source;
    is  (read_file("$keep/$_"), keepstate(TARGET, $target{$_}, @{ $target_deps{$_} }),
                                     "Keepstate content: $_") for key %target;
}

note "Rerun after a dependency '1' was deleted";
{
    delete_file('1');

    my ($exit, $pre, $post) = run_fix(
        '--stats ab12',
        [ key(%source, %target) ],
    );
    my %pre  = %$pre;
    my %post = %$post;

    is  ($exit >> 8,    0,           "Exit status");
    is  (execcount(),   1,           "Run count");
    is  ($pre{$_},      $post{$_},   "Buildscript unchanged: $_") for key %source;
    ok  (! -f "$_--fixing",          "Tempfile non-existing: $_--fixing") for key %target;
    ok  (  -f $_,                    "Target existing: $_")   for key %target;
    isnt($pre{$_},      $post{$_},   "Target updated: $_")    for qw/1/;
    is  ($pre{$_},      $post{$_},   "Target unchanged: $_")  for qw/a b 2 ab 12 ab12/;
    is  (read_file($_), $target{$_}, "Target content: $_")    for key %target;
    ok  (  -e $run,                  "Runstate dir existing");
    is  (read_file("$run/$_"), runstate(SAME_DEPS),
                                     "Runstate content: $_") for qw/a b 2 ab 12 ab12/;
    is  (read_file("$run/$_"), runstate(REPL_ERASED),
                                     "Runstate content: $_") for qw/1/;
    ok  (  -e $keep,                 "Keepstate dir existing");
    is  (read_file("$keep/$_"), keepstate(SOURCE, $source{$_}),
                                     "Keepstate content: $_") for key %source;
    is  (read_file("$keep/$_"), keepstate(TARGET, $target{$_}, @{ $target_deps{$_} }),
                                     "Keepstate content: $_") for key %target;
}

note "Rerun after dependency target '1' externally modified";
{
    local $target{'1'} = nl('XXX');            # 'externally' modify target file
    write_file('1', $target{'1'});

    my ($exit, $pre, $post) = run_fix(
        '--stats ab12',
        [ key(%source, %target) ],
    );
    my %pre  = %$pre;
    my %post = %$post;

    is  ($exit >> 8,    253,         "Exit status");
    is  (execcount(),   1,           "Run count");
    is  ($pre{$_},      $post{$_},   "Buildscript unchanged: $_") for key %source;
    ok  (! -f "$_--fixing",          "Tempfile non-existing: $_--fixing") for key %target;
    ok  (  -f $_,                    "Target existing: $_")   for key %target;
    is  ($pre{$_},      $post{$_},   "Target unchanged: $_")  for key %target;
    is  (read_file($_), $target{$_}, "Target content: $_")    for key %target;
    is  (read_file($_), $target{$_}, "Target content: $_")    for key %target;
} {
    # $target{'1'} == 'XXX' above, but in state we're expecting to see old values
    ok  (  -e $run,                  "Runstate dir existing");
    is  (read_file("$run/$_"), runstate(WONT_OVERWR, ABORT => $_),
                                     "Runstate content: $_") for qw/1/;
    # When build is aborted, stats become unreliable for the other files.
    # is  (read_file("$run/$_"), runstate(SAME_DEPS),
    #                                  "Runstate content: $_") for qw/a b 2 12 ab ab12/;
    ok  (  -e $keep,                 "Keepstate dir existing");
    is  (read_file("$keep/$_"), keepstate(SOURCE, $source{$_}),
                                     "Keepstate content: $_") for key %source;
    is  (read_file("$keep/$_"), keepstate(TARGET, $target{$_}, @{ $target_deps{$_} }),
                                     "Keepstate content: $_") for key %target;
}

note "Building target in parent dir";
{
    delete_file('1');

    my ($exit, $pre, $post) = run_fix(
        '--stats ../ab12',
        [ key(%source, %target) ],
        sub { mkdir('abc') && chdir('abc') || die "cannot cd to 'abc'," },
        sub {                 chdir('..')  || die "cannot cd back from 'abc'," },
    );
    my %pre  = %$pre;
    my %post = %$post;

    is  ($exit >> 8,    0,           "Exit status");
    is  (execcount(),   1,           "Run count");
    is  ($pre{$_},      $post{$_},   "Buildscript unchanged: $_") for key %source;
    ok  (! -f "$_--fixing",          "Tempfile non-existing: $_--fixing") for key %target;
    ok  (  -f $_,                    "Target existing: $_")   for key %target;
    isnt($pre{$_},      $post{$_},   "Target updated: $_")    for qw/1/;
    is  ($pre{$_},      $post{$_},   "Target unchanged: $_")  for qw/a b 2 ab 12 ab12/;
    is  (read_file($_), $target{$_}, "Target content: $_")    for key %target;
    ok  (  -e $run,                  "Runstate dir existing");
    is  (read_file("$run/$_"), runstate(SAME_DEPS),
                                     "Runstate content: $_") for qw/a b 2 ab 12 ab12/;
    is  (read_file("$run/$_"), runstate(REPL_ERASED),
                                     "Runstate content: $_") for qw/1/;
    ok  (  -e $keep,                 "Keepstate dir existing");
    is  (read_file("$keep/$_"), keepstate(SOURCE, $source{$_}),
                                     "Keepstate content: $_") for key %source;
    is  (read_file("$keep/$_"), keepstate(TARGET, $target{$_}, @{ $target_deps{$_} }),
                                     "Keepstate content: $_") for key %target;
}

# rewrite filenames to include subdir name
%source = map { ("abc/$_" => $source{$_}) } keys %source;
%target = map { ("abc/$_" => $target{$_}) } keys %target;
%target_deps = map {
    my $value = [ map { [ map { "abc/$_" } @$_ ] } @{ $target_deps{$_} } ];
    ("abc/$_" => $value);
} keys %target_deps;
write_file(%source);

note "Building target in subdir";
{
    delete_file('1');

    my ($exit, $pre, $post) = run_fix(
        '--stats abc/ab12',
        [ key(%source, %target) ],
    );
    my %pre  = %$pre;
    my %post = %$post;

    is  ($exit >> 8,    0,           "Exit status");
    is  (execcount(),   4,           "Run count");
    is  ($pre{$_},      $post{$_},   "Buildscript unchanged: $_") for key %source;
    ok  (! -f "$_--fixing",          "Tempfile non-existing: $_--fixing") for key %target;
    ok  (  -f $_,                    "Target existing: $_")   for key %target;
    isnt($pre{$_},      $post{$_},   "Target updated: $_")    for key %target;
    is  (read_file($_), $target{$_}, "Target content: $_")    for key %target;
    ok  (! -e "abc/.fix",            "Statedir non-existing in subdir");
    ok  (  -e $run,                  "Runstate dir existing");
    is  (read_file("$run/$_"), runstate(NEW_CONTENT),
                                     "Runstate content: $_") for key %target;
    ok  (  -e $keep,                 "Keepstate dir existing");
    is  (read_file("$keep/$_"), keepstate(SOURCE, $source{$_}),
                                     "Keepstate content: $_") for key %source;
    is  (read_file("$keep/$_"), keepstate(TARGET, $target{$_}, @{ $target_deps{$_} }),
                                     "Keepstate content: $_") for key %target;
}

END {
    done_testing();
    note
        "================================================\n" .
        " NOTA BENE! EXIT STATEMENT FOUND IN TESTSCRIPT!\n" .
        "================================================\n"
            if $exit_statement_in_test_script;
    note
        "Testdir: $testdir\n",
}

#[eof]
