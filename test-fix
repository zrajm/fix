#!/usr/bin/perl
use strict;
use warnings;
use 5.10.0;
END {
    warn
        "# #################################\n" .
        "# ##  THERE WERE FAILING TESTS!  ##\n" .
        "# #################################\n" if $?;
}
use Test::More;
use Cwd qw/cwd realpath/;
use File::Path 'rmtree';

use Carp 'confess';
$SIG{__DIE__} = \&Carp::confess;

our $name  = 'fix';
our $keep  = ".$name/keep";                     # keepstate directory
our $run   = ".$name/run";                      # runstate directory
our $stats = ".$name/stats";
(our $fix  = realpath(__FILE__)) =~ s#[^/]+$#$name#;

BEGIN {                                        # load 'fix' as a module
    use Cwd qw/realpath/;
    ($fix = realpath(__FILE__)) =~ s#[^/]+$#fix#;
    require $fix;
    Module->import();
}

###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

# Delete file(s). Ignore errors if file is gone in the end.
sub delete_file {
    my (@file) = @_;
    foreach my $file (@file) {
        next unless -e $file;
        unlink($file) or die "Failed to delete file '$file': $!,";
    }
}

# Write to a temporary file, so that we know the inode number will change when
# a file is rewritten (which guarantees that a newly written file will have a
# different stat fingerprint, even if it have the same content). Thus we know
# don't have to use Time::HiRes to get sub-second resolution in the
# fingerprinting.
sub write_file {
    my %arg = @_;
    foreach my $file (keys %arg) {
        my $outfile = "$file--tmp";
        open(my $out, '>', $outfile)
            or die "Cannot open file '$outfile' for writing: $!,";
        print $out $arg{$file};
        close($out)
            or die "Cannot close file '$outfile' after writing: $!,";
        rename($outfile, $file)
            or die "Cannot rename file '$outfile' -> '$file' after writing: $!,";
    }
}

sub read_file {
    my ($file) = @_;
    open(my $in, '<', $file)
        or die "Failed to open file '$file' for reading: $!,";
    local $/ = undef;
    return <$in>;
}

# Return stat fingerprint (or empty string if file doesn't exist).
#
# Note: We can't use Time::HiRes here, since it only supports lstat() since
# February 2013. [https://rt.cpan.org/Public/Bug/Display.html?id=83356]
sub read_file_fingerprint {
    my ($file) = @_;
    my @stat = lstat($file);
    return join("-", @stat ? @stat[1, 2, 4, 5, 7, 9, 10] : ());
}

# Return hash of filenames (as keys) and stat fingerprints (as values).
sub fingerprints {
    my (@file) = @_;
    return map {
        $_ => read_file_fingerprint($_);
    } @file;
}

sub make_tempdir {
    my ($name) = @_;
    my $tempdir = `mktemp -td $name-XXXXXX`;
    chomp($tempdir);
    return $tempdir;
}

sub enter_dir {
    my ($dir) = @_;
    mkdir($dir) or die "Cannot create '$dir': $!,";
    chdir($dir) or die "Cannot cd to '$dir': $!,";
    $ENV{PWD} = $dir;
}

sub nl { join "", map "$_\n", @_ }

sub sha1 {
    my ($data) = @_;
    use Digest::SHA qw(sha1_hex);
    use Encode qw(encode_utf8);
    sha1_hex(encode_utf8($data));
}

# Return keys in hash, sorted by first by length, then alphabetically.
sub key(\%) {
    sort { length($a) <=> length($b) or $a cmp $b } keys %{ shift() };
}

sub serialize {
    my (%x) = @_;
    use Data::Dumper;
    local $Data::Dumper::Indent   = 1;
    local $Data::Dumper::Sortkeys = 1;
    local $Data::Dumper::Terse    = 1;
    return Dumper \%x;
}

# for use with keepstate()
sub SOURCE { 'source' }
sub TARGET { 'target' }
sub keepstate {
    my ($type, $content, @deps) = @_;
    my %x;
    $x{type}     = $type;
    $x{deps}     = [ @deps ] if @deps;
    $x{checksum} = sha1($content) if defined $content;
    return serialize(%x);
}

# for use with run_fix_test() and runstate()
sub ABORTED     { 'aborted' }
sub UNCHANGED   { 'wont_rebuild' }
sub WONT_OVERWR { 'wont_overwrite' }
sub SHELL_FAIL  { 'shell_error' }
sub BUILD_FAIL  { 'buildscript_error' }
sub KEPT_PREV   { 'rebuilt_but_kept_previous' }
sub REPL_ERASED { 'rebuilt_replaced_deleted' }
sub NEW_CONTENT { 'rebuilt_new_content' }
sub runstate {
    my ($build_status, $abort_status, $abort_target) = @_;
    my %x;
    $x{ABORT}        = $abort_target if defined($abort_status);
    $x{build_status} = $build_status if defined($build_status);
    return serialize(%x);
}

sub statsstate {
    my (@run_target) = @_;
    my %x;
    $x{run_count}   = scalar(@run_target) if @run_target;
    $x{run_targets} =       \@run_target  if @run_target;
    return serialize(%x);
}

{
    sub TRUE  { 1 }
    sub FALSE { 0 }
    my %target_rewritten = (
        ABORTED     ,=> FALSE,      # unmodified targets, no runstate left
        UNCHANGED   ,=> FALSE,
        WONT_OVERWR ,=> FALSE,
        SHELL_FAIL  ,=> FALSE,
        BUILD_FAIL  ,=> FALSE,
        KEPT_PREV   ,=> FALSE,
        REPL_ERASED ,=> TRUE,
        NEW_CONTENT ,=> TRUE,
    );
    sub run_fix_test {
        my %arg = @_;
        $arg{before} //= sub {};
        $arg{after}  //= sub {};
        die "run_fix_test() option 'exit' must be integer,"      if $arg{exit} !~ /^\d+$/;
        die "run_fix_test() option 'before' must be coderef,"    if ref($arg{before}) ne 'CODE';
        die "run_fix_test() option 'after' must be coderef,"     if ref($arg{after})  ne 'CODE';
        my %result = %{ $arg{result} // {} };
        my %source = %{ $arg{source} // {} };
        my @stats  = @{ $arg{stats}  // [] };
        my @args   = @{ $arg{args}   // [] };

        # write source files
        foreach (key %source) {
            write_file($_ => $source{$_}) if defined $source{$_};
        }

        my @file = do {
            my @tempfile = map { "$_--fixing" } keys %result;
            delete_file @tempfile;
            (keys %source, @tempfile, keys %result);
        };

        my %pre  = fingerprints(@file);
        $arg{before}();                        # run 'before' hook
        unshift(@args, '--stats');             # insert '--stats' option
        unshift(@{ $stats[0] }, '--stats') if @stats;
        note("Run: fix @args");                # run command
        note("Dir: $ENV{PWD}");
        my $exit = system("$fix @args 2> stderr.txt");

        if (my $caught = $exit & 127) {        # exit on Ctrl-C
            my %signame;                       #   (or any other signal)
            use Config '%Config';
            @signame{ split ' ', $Config{sig_num} }
                = split ' ', $Config{sig_name};
            warn " *** Killed by SIG" . $signame{ $caught } . "\n";
            exit;
        }

        my $stderr = read_file('stderr.txt');  # check stderr output
        #say STDERR $stderr;
        unlike($stderr, qr/Use of uninitialized value/,
               "No Perl warning 'uninitialized value'");
        delete_file('stderr.txt');

        is($exit >> 8, $arg{exit},             # check exit status
           "Exit status: $arg{exit}");

        $arg{after}();                         # run 'after' hook
        my %post = fingerprints(@file);

        # check statsfile
        if (@stats == 0) {
            ok(!-e $stats, "Statsfile non-existing: $stats");
        } else {
            ok( -e $stats, "Statsfile existing: $stats");
            my $gotten   = read_file($stats);
            my $expected = statsstate(@stats);
            is($gotten, $expected, "Statsfile content: $stats");
        }

        # check sourcefiles
        {
            foreach (key %source) {
                ok(! -f $_, "Sourcefile non-existing: $_")
                    if not defined $source{$_};
            }
            my @source = grep { defined $source{$_} } key(%source);
            ok(   -f $_,            "Sourcefile existing: $_" ) for @source;
            is($pre{$_}, $post{$_}, "Sourcefile unchanged: $_") for @source;
        }

        # check tempfiles
        {
            my @tempfile = (
                key(%source),
                grep { not defined $result{$_}{temp} } key(%result),
            );
            foreach (@tempfile) {
                my $file = "$_--fixing";
                ok(! -f $file, "Tempfile non-existing: $file");
            }
            @tempfile = grep { defined $result{$_}{temp} } key(%result);
            foreach (@tempfile) {
                my $file = "$_--fixing";
                ok(  -f $file, "Tempfile existing: $file");
            }
            foreach (@tempfile) {
                my $file = "$_--fixing";
                isnt($pre{$file}, $post{$file}, "Tempfile updated: $file");
            }
            foreach (@tempfile) {
                my $file = "$_--fixing";
                my $gotten   = read_file($file);
                my $expected = $result{$_}{temp};
                is($gotten, $expected, "Tempfile content: $file");
            }
        }

        # check targets
        {
            my @target;

            @target = grep { not defined $result{$_}{cont} } key(%result);
            ok(!-f $_, "Target non-existing: $_") for @target;

            @target = grep {     defined $result{$_}{cont} } key(%result);
            ok( -f $_, "Target existing: $_"    ) for @target;

            foreach (@target) {                # rewritten targets
                my $state = $result{$_}{state};
                isnt($pre{$_}, $post{$_}, "Target updated: $_")
                    if $target_rewritten{$state} == TRUE;
            }
            foreach (@target) {                # unmodified targets
                my $state = $result{$_}{state};
                is($pre{$_}, $post{$_}, "Target unchanged: $_")
                    if $target_rewritten{$state} == FALSE;
            }
            foreach (@target) {                # if modified, check content
                is(read_file($_), $result{$_}{cont}, "Target content: $_")
                    if $pre{$_} ne $post{$_};
            }
        }

        # check runstate
        my @runstate = grep { $result{$_}{state} ne ABORTED } key(%result);
        if (@runstate == 0) {                  # no targets generated
            ok(!-e $run, "Runstate dir non-existing: $run");
        } else {                               # targets were generated
            ok( -e $run, "Runstate dir existing: $run");
            foreach (key %result) {
                ok(!-f "$run/$_", "Runstate non-existing: $run/$_")
                    if $result{$_}{state} eq ABORTED;
            }
            foreach (@runstate) {
                ok( -f "$run/$_", "Runstate existing: $run/$_");
            }
            foreach (@runstate) {
                my $gotten   = read_file("$run/$_");
                my $expected = runstate(
                    $result{$_}{state},
                    ($result{$_}{abort} ? (ABORT => $result{$_}{abort}) : ()),
                );
                is($gotten, $expected, "Runstate content: $run/$_");
            }
        }

        # check keepstate
        if (@runstate == 0) {
            ok(!-e $keep, "Keepstate dir non-existing: $keep");
        } else {
            ok( -e $keep, "Keepstate dir existing: $keep");
            foreach (key %source) {
                my $gotten   = read_file("$keep/$_");
                my $expected = keepstate(SOURCE, $source{$_});
                is($gotten, $expected, "Keepstate content: $keep/$_");
            }
            foreach (key %result) {
                my $gotten   = read_file("$keep/$_");
                my $expected = keepstate(TARGET, $result{$_}{cont}, @{ $result{$_}{deps} });
                is($gotten, $expected, "Keepstate content: $keep/$_");
            }
        }
    }
}

###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################

# check if there is an 'exit' statement in this file
my $exit_statement_in_test_script = read_file(__FILE__) =~ /^\s*exit.*;/m;
my $testdir = make_tempdir($name);

###############################################################################
##                                                                           ##
##  Internal Tests (Testing Functions in the Program)                        ##
##                                                                           ##
###############################################################################
note
    "====================================\n" .
    " Internal Tests (Testing Functions)\n" .
    "====================================";

enter_dir("$testdir/internal-tests");

note 'split_path()';
# FIXME: What *should* split_path('.') return?
my @test = (
    [ qw( a/b/c     a/b     c ) ],
    [ qw( a/b/c/    a/b     c ) ],
    [ qw( a/b/c///  a/b     c ) ],
    [ qw( a/b//c/   a/b     c ) ],
    [ qw( a//b/c    a//b    c ) ],
    [ qw( /a/b/c    /a/b    c ) ],
    [ qw( a         .       a ) ],
    [ qw( /a        /       a ) ],
);
# We run the function twice, because it looks prettier to report basenames and
# dirnames separately in the output.
foreach my $test (@test) {
    my ($path, $expect_dir, undef) = @$test;
    my ($dir_result, undef) = Local::Modulino::split_path($path);
    is ($dir_result, $expect_dir, "Dirname: $path");
}
foreach my $test (@test) {
    my ($path, undef, $expect_file) = @$test;
    my (undef, $file_result) = Local::Modulino::split_path($path);
    is ($file_result, $expect_file, "Basename: $path");
}

note 'default_buildscripts()';
{
    my %tests = (
        'hej.a.b.c' => [
            'default.a.b.c.fix',
            'default.a.b.fix',
            'default.a.fix',
            'default.fix' ],
        'a' => [
            'default.fix' ],
    );
    for (key %tests) {
        my $expect = $tests{$_};
        is_deeply([ Local::Modulino::possible_buildscripts($_) ], $expect,
                  "Files: $_");
    }
}

note 'Local::Paths::relpath()';
{
    my @test = (
        [qw( /x/y/z.txt  /           x/y/z.txt )],
        [qw( /x/y/z.txt  /x            y/z.txt )],
        [qw( /x/y/z.txt  /x/y            z.txt )],
        [qw( /x/y/z.txt  /x/y/a       ../z.txt )],
        [qw( /x/y/z.txt  /x/y/a/b  ../../z.txt )],
        [qw( ../z.txt    .            ../z.txt )],
    );
    foreach (@test) {
        my ($file, $dir, $result) = @$_;
        my $got = Local::Paths::relpath($file, $dir);
        is($got, $result, "$result");
    }
}

note 'Local::Paths::clean()';
{
    my @test = (
        './a'        => 'a',
        '../a'       => '../a',
        '../../a'    => '../../a',
        '.'          => '.',
        './.'        => '.',
        './..'       => '..',
        './'         => '.',                   # odd corner case
        '/.'         => '/',                   # odd corner case
        '/'          => '/',
        '/a'         => '/a',
        '/a/..'      => '/',
        '/a/../..'   => '/',
        '/a/b/../..' => '/',
        'a'          => 'a',
        'a/'         => 'a',
        'a/../..'    => '..',
        'a/../../..' => '../..',
        'a/../b/c'   => 'b/c',
        'a/../../c'  => '../c',
        'a/./b'      => 'a/b',
        'a//b'       => 'a/b',
        'a/b'        => 'a/b',
        'a/b/../..'  => '.',
        'a/b/c/..'   => 'a/b',
    );
    while (@test) {
        my ($_, $expect) = splice(@test, 0, 2);
        is(Local::Paths::clean($_), $expect, "Path: $_");
    }
}

note "Local::Store, simple use";
{
    my $test = new Local::Store(dir => 'storage');
    my ($x, $y);

    $x = eval { $test->get('file'); 1 };
    is  ($x, undef, "get() without fields should die");
    like($@, qr/Missing arguments: No field names given/,
                    "get() without fields error message");

    $x = $test->get('file', 'foo');
    is  ($x, undef, "get() on non-existing field");
    $x = $test->set('file', foo => 'bar', apa => 'bepa');
    ok  ($x, "set() return status");
    for ('storage/file') {
        ok  ( -f $_, "set() file existence: $_");
        is  (read_file($_), serialize(foo => 'bar', apa => 'bepa'),
             "set() file content: $_");
    }

    ($x, $y) = $test->get('file', 'foo', 'apa');
    is  ($x, 'bar',  'get() with two existing fields, 1st field');
    is  ($y, 'bepa', 'get() with two existing fields, 2nd field');
    ($x, $y) = $test->get('file', 'apa', 'foo');
    is  ($x, 'bepa', 'get() with two existing fields in opposite order, 1st field');
    is  ($y, 'bar',  'get() with two existing fields in opposite order, 2nd field');

    my %expected = ( foo => 'bar', apa => 'bepa' );
    foreach (qw/foo apa/) {
        $x = $test->get('file', $_);
        is  ($x, $expected{$_}, "get() with one field in scalar context: $_");
    }
}

###############################################################################
##                                                                           ##
##  External Tests (Running the Program, Testing Build Results)              ##
##                                                                           ##
###############################################################################
note
    "========================================\n" .
    " External Tests (Testing Build Results)\n" .
    "========================================";

my (%source, %target, %target_deps);
my %c;                                         # Mnemonic: 'content'
enter_dir("$testdir/external-tests");

note "No '.fixrc'";
run_fix_test(
    exit => 254,
    args => [qw( 1 )],
);

write_file('.fixrc' => '');

###############################################################################

note "No argument given";
run_fix_test(
    exit => 254,
    args => [qw()],
);

note "Bad command line option";
run_fix_test(
    exit => 254,
    args => [qw( --BAD-OPTION )],
);

note "Non-existing buildscript";
{
    run_fix_test(
        exit   => 254,
        args   =>  [qw( NON-EXISTING-TARGET )],
        stats  => [[qw( NON-EXISTING-TARGET )]],
        source => {
            'NON-EXISTING-TARGET.fix' => undef,
        },
        result => {
            'NON-EXISTING-TARGET' => {
                state => ABORTED,
            },
        },
    );
}

write_file('../outside.fix', '');

note "Buildscript outside work tree";
run_fix_test(
    exit   => 254,
    args   =>  [qw( ../outside )],
    stats  => [[qw( ../outside )]],
    source => {
        '../outside.fix' => '',
    },
    result => {
        '../outside' => {
            state => ABORTED,
        },
    },
);

note "Buildscript with exit status = 1";
run_fix_test(
    exit   => 1,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo FIRST',
                      'exit 1',
                      'echo SECOND'),
    },
    result => {
        '1' => {
            state => BUILD_FAIL,
            deps  => [[ '1.fix' ]],
            temp  => nl('FIRST'),
        },
    },
);

note "Buildscript with exit status = 2";
run_fix_test(
    exit   => 2,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo FIRST',
                      'exit 2',
                      'echo SECOND'),
    },
    result => {
        '1' => {
            state => BUILD_FAIL,
            deps  => [[ '1.fix' ]],
            temp  => nl('FIRST'),
        },
    },
);

note "Buildscript with command returning false";
run_fix_test(
    exit   => 1,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo FIRST',
                      'false',
                      'echo SECOND'),
    },
    result => {
        '1' => {
            state => BUILD_FAIL,
            deps  => [[ '1.fix' ]],
            temp  => nl('FIRST'),
        },
    },
);

note "Buildscript with non-existing command";
run_fix_test(
    exit   => 127,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('NONEXISTING-SHELL-COMMAND'),
    },
    result => {
        '1' => {
            state => BUILD_FAIL,
            deps  => [[ '1.fix' ]],
            temp  => nl(),
        },
    },
);

###############################################################################

note 'First run of (working) buildscript, using "1.txt.fix" rule';
rmtree([ ".$name", '1.txt' ]);
run_fix_test(
    exit   => 0,
    args   =>  [qw( 1.txt )],
    stats  => [[qw( 1.txt )]],
    source => {
        '1.txt.fix' => nl('echo $1',
                          'echo $2'),
    },
    result => {
        '1.txt' => {
            state => NEW_CONTENT,
            deps  => [[ '1.txt.fix' ]],
            cont  => nl("$ENV{PWD}/1.txt--fixing",
                        "$ENV{PWD}/1.txt"),
        },
    },
);
rmtree([ ".$name", '1.txt', '1.txt.fix' ]);    # erase generated files

note 'First run of (working) buildscript, using "default.txt.fix" rule';
run_fix_test(
    exit   => 0,
    args   =>  [qw( 1.txt )],
    stats  => [[qw( 1.txt )]],
    source => {
        'default.txt.fix' => nl('echo $1',
                                'echo $2'),
    },
    result => {
        '1.txt' => {
            state => NEW_CONTENT,
            deps  => [[ 'default.txt.fix' ]],
            cont  => nl("$ENV{PWD}/1.txt--fixing",
                        "$ENV{PWD}/1.txt"),
        },
    },
);
rmtree([ ".$name", '1.txt', 'default.txt.fix' ]);  # erase generated files

note 'First run of (working) buildscript, using "default.fix" rule';
run_fix_test(
    exit   => 0,
    args   =>  [qw( 1.txt )],
    stats  => [[qw( 1.txt )]],
    source => {
        'default.fix' => nl('echo $1',
                            'echo $2'),
    },
    result => {
        '1.txt' => {
            state => NEW_CONTENT,
            deps  => [[ 'default.fix' ]],
            cont  => nl("$ENV{PWD}/1.txt--fixing",
                        "$ENV{PWD}/1.txt"),
        },
    },
);
rmtree([ ".$name", '1.txt', 'default.fix' ]);  # erase generated files

###############################################################################

note 'First run of (working) buildscript + $1 and $2';
rmtree([ '1', '1.fix' ]);  # erase generated files
run_fix_test(
    exit   => 0,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo $1',
                      'echo $2'),
    },
    result => {
        '1' => {
            state => NEW_CONTENT,
            deps  => [[ '1.fix' ]],
            cont  => nl("$ENV{PWD}/1--fixing",
                        "$ENV{PWD}/1"),
        },
    },
);

note "Rerun without changes";
run_fix_test(
    exit   => 0,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo $1',
                      'echo $2'),
    },
    result => {
        '1' => {
            state => UNCHANGED,
            deps  => [[ '1.fix' ]],
            cont  => nl("$ENV{PWD}/1--fixing",
                        "$ENV{PWD}/1"),
        },
    },
);

note "Rerun after target was externally modified";
# (Won't generate tempfile, since build isn't attempted at all.)
write_file('1', nl('XXX'));                    # modify target file
run_fix_test(
    exit   => 253,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo $1',
                      'echo $2'),
    },
    result => {
        '1' => {
            abort => '1',
            state => WONT_OVERWR,
            deps  => [[ '1.fix' ]],
            cont  => nl("$ENV{PWD}/1--fixing",
                        "$ENV{PWD}/1"),
        },
    },
);

note "Rerun after target was deleted";
delete_file('1');
run_fix_test(
    exit   => 0,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo $1',
                      'echo $2'),
    },
    result => {
        '1' => {
            state => REPL_ERASED,
            deps  => [[ '1.fix' ]],
            cont  => nl("$ENV{PWD}/1--fixing",
                        "$ENV{PWD}/1"),
        },
    },
);

note "Rerun after buildscript was changed, but give same output";
run_fix_test(
    exit   => 0,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('# COMMENT',
                      'echo $1',
                      'echo $2'),
    },
    result => {
        '1' => {
            state => KEPT_PREV,
            deps  => [[ '1.fix' ]],
            cont  => nl("$ENV{PWD}/1--fixing",
                        "$ENV{PWD}/1"),
        },
    },
);

note "Rerun after buildscript was changed, and give new output";
run_fix_test(
    exit   => 0,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo 1'),
    },
    result => {
        '1' => {
            state => NEW_CONTENT,
            deps  => [[ '1.fix' ]],
            cont  => nl('1'),
        },
    },
);

###############################################################################

note 'Writing to tempfile $1';
run_fix_test(
    exit   => 0,
    args   =>  [qw( test.txt )],
    stats  => [[qw( test.txt )]],
    source => {
        'test.txt.fix' => nl('echo test >$1'),
    },
    result => {
        'test.txt' => {
            state => NEW_CONTENT,
            deps  => [[ 'test.txt.fix' ]],
            cont  => nl('test'),
        },
    },
);

###############################################################################

note '=== Source Dependency ===';
note "Source dependency";
run_fix_test(
    exit   => 0,
    args   =>  [qw( indented.txt )],
    stats  => [[qw( indented.txt )], [qw( --source source.txt )]],
    source => {
        'indented.txt.fix' => nl('fix --source source.txt',
                                 'sed "s/^/> /" <source.txt'),
        'source.txt' => nl('some text'),
    },
    result => {
        'indented.txt' => {
            state => NEW_CONTENT,
            deps  => [[ 'indented.txt.fix' ], [ 'source.txt' ]],
            cont  => nl('> some text'),
        },
    },
);

note "Source dependency, rebuild without change";
run_fix_test(
    exit   => 0,
    args   =>  [qw( indented.txt )],
    stats  => [[qw( indented.txt )]],
    source => {
        'indented.txt.fix' => nl('fix --source source.txt',
                                 'sed "s/^/> /" <source.txt'),
        'source.txt' => nl('some text'),
    },
    result => {
        'indented.txt' => {
            state => UNCHANGED,
            deps  => [[ 'indented.txt.fix' ], [ 'source.txt' ]],
            cont  => nl('> some text'),
        },
    },
);

note "Source dependency, rebuild with source change";
run_fix_test(
    exit   => 0,
    args   =>  [qw( indented.txt )],
    stats  => [[qw( indented.txt )], [qw( --source source.txt )]],
    source => {
        'indented.txt.fix' => nl('fix --source source.txt',
                                 'sed "s/^/> /" <source.txt'),
        'source.txt' => nl('some other text'),
    },
    result => {
        'indented.txt' => {
            state => NEW_CONTENT,
            deps  => [[ 'indented.txt.fix' ], [ 'source.txt' ]],
            cont  => nl('> some other text'),
        },
    },
);

###############################################################################

note '=== Complex Dependencies ===';
rmtree([ ".$name", qw( 1 1.fix a ) ]);         # clear previously generated files

note "First run of buildscript with dependencies";
run_fix_test(
    exit   => 0,
    args   =>  [qw( ab12 )],
    stats  => [[qw( ab12 )], [qw(ab 12)], [qw(a b)], [qw(1 2)]],
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 2'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => NEW_CONTENT,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>2 )),
        },
        ab => {
            state => NEW_CONTENT,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b             )),
        },
        12 => {
            state => NEW_CONTENT,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >2 )),
        },
        a => {
            state => NEW_CONTENT,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                 )),
        },
        b => {
            state => NEW_CONTENT,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b             )),
        },
        1 => {
            state => NEW_CONTENT,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1     )),
        },
        2 => {
            state => NEW_CONTENT,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           2 )),
        },
    },
);

note "Rerun without change";
run_fix_test(
    exit   => 0,
    args   =>  [qw( ab12 )],
    stats  => [[qw( ab12 )]],
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 2'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => UNCHANGED,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>2 )),
        },
        ab => {
            state => UNCHANGED,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b             )),
        },
        12 => {
            state => UNCHANGED,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >2 )),
        },
        a => {
            state => UNCHANGED,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                 )),
        },
        b => {
            state => UNCHANGED,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b             )),
        },
        1 => {
            state => UNCHANGED,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1     )),
        },
        2 => {
            state => UNCHANGED,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           2 )),
        },
    },
);

note "Rerun after change of subtarget '2'";
run_fix_test(
    exit   => 0,
    args   =>  [qw( ab12 )],
    stats  => [[qw( ab12 )], [qw(1 2)], [qw(ab 12)]],
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 22'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => NEW_CONTENT,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>22 )),
        },
        ab => {
            state => UNCHANGED,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b              )),
        },
        12 => {
            state => NEW_CONTENT,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >22 )),
        },
        a => {
            state => UNCHANGED,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                  )),
        },
        b => {
            state => UNCHANGED,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b              )),
        },
        1 => {
            state => UNCHANGED,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1      )),
        },
        2 => {
            state => NEW_CONTENT,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           22 )),
        },
    },
);

note "Rerun after a dependency '12' was deleted";
delete_file('12');
run_fix_test(
    exit   => 0,
    args   =>  [qw( ab12 )],
    stats  => [[qw( ab12 )], [qw(1 2)]],
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 22'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => UNCHANGED,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>22 )),
        },
        ab => {
            state => UNCHANGED,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b              )),
        },
        12 => {
            state => REPL_ERASED,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >22 )),
        },
        a => {
            state => UNCHANGED,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                  )),
        },
        b => {
            state => UNCHANGED,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b              )),
        },
        1 => {
            state => UNCHANGED,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1      )),
        },
        2 => {
            state => UNCHANGED,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           22 )),
        },
    },
);

note "Rerun after a dependency '1' was deleted";
delete_file('1');
run_fix_test(
    exit   => 0,
    args   =>  [qw( ab12 )],
    stats  => [[qw( ab12 )]],
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 22'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => UNCHANGED,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>22 )),
        },
        ab => {
            state => UNCHANGED,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b              )),
        },
        12 => {
            state => UNCHANGED,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >22 )),
        },
        a => {
            state => UNCHANGED,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                  )),
        },
        b => {
            state => UNCHANGED,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b              )),
        },
        1 => {
            state => REPL_ERASED,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1      )),
        },
        2 => {
            state => UNCHANGED,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           22 )),
        },
    },
);

note "Rerun after dependency target '1' externally modified";
# (Won't generate tempfile, since build isn't attempted at all.)
# FIXME: When graceful abort is implemented, check runstate of ABORTED targets.
write_file('1', nl('XXX'));                    # modify target file
run_fix_test(
    exit   => 253,
    args   =>  [qw( ab12 )],
    stats  => [[qw( ab12 )]],
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 22'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => ABORTED,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>22 )),
        },
        ab => {
            state => UNCHANGED,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b              )),
        },
        12 => {
            state => ABORTED,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >22 )),
        },
        a => {
            state => UNCHANGED,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                  )),
        },
        b => {
            state => UNCHANGED,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b              )),
        },
        1 => {
            abort => '1',
            state => WONT_OVERWR,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1      )),
        },
        2 => {
            state => ABORTED,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           22 )),
        },
    },
);

###############################################################################

note '=== Target Outside Current Dir ===';
note "Building target in parent dir";
delete_file('1');
run_fix_test(
    exit   => 0,
    args   =>  [qw( ../ab12 )],
    stats  => [[qw(    ab12 )]],
    before => sub {
        mkdir('abc') && chdir('abc') || die "cannot cd to 'abc',";
    },
    after  => sub {
        chdir('..')  || die "cannot cd back from 'abc',";
        ok(! -e "abc/.fix", "Statedir non-existing in subdir: abc/.fix");
    },
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 22'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => UNCHANGED,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>22 )),
        },
        ab => {
            state => UNCHANGED,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b              )),
        },
        12 => {
            state => UNCHANGED,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >22 )),
        },
        a => {
            state => UNCHANGED,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                  )),
        },
        b => {
            state => UNCHANGED,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b              )),
        },
        1 => {
            state => REPL_ERASED,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1      )),
        },
        2 => {
            state => UNCHANGED,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           22 )),
        },
    },
);

note "Building target in subdir";
run_fix_test(
    exit   => 0,
    args   =>  [qw( abc/ab12 )],
    stats  => [[qw( abc/ab12      )],
               [qw( abc/ab abc/12 )],
               [qw( abc/a  abc/b  )],
               [qw( abc/1  abc/2  )]],
    after  => sub {
        ok(! -e "abc/.fix", "Statedir non-existing in subdir: abc/.fix");
    },
    source => {
        'abc/ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'abc/ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        'abc/12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'abc/b.fix'    => nl('echo b'),
        'abc/a.fix'    => nl('echo a'),
        'abc/2.fix'    => nl('echo 22'),
        'abc/1.fix'    => nl('echo 1'),
    },
    result => {
        'abc/ab12' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/ab12.fix' ], [qw( abc/ab abc/12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>22 )),
        },
        'abc/ab' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/ab.fix' ], [qw( abc/a  abc/b )]],
            cont  => nl(qw(      ab  >a  >b              )),
        },
        'abc/12' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/12.fix' ], [qw( abc/1  abc/2 )]],
            cont  => nl(qw(                  12  >1  >22 )),
        },
        'abc/a' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/a.fix' ]],
            cont  => nl(qw(           a                  )),
        },
        'abc/b' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/b.fix' ]],
            cont  => nl(qw(               b              )),
        },
        'abc/1' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/1.fix' ]],
            cont  => nl(qw(                       1      )),
        },
        'abc/2' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/2.fix' ]],
            cont  => nl(qw(                           22 )),
        },
    },
);

###############################################################################

END {
    done_testing();
    note
        "================================================\n" .
        " NOTA BENE! EXIT STATEMENT FOUND IN TESTSCRIPT!\n" .
        "================================================\n"
            if $exit_statement_in_test_script;
}

#[eof]
