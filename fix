#!/usr/bin/perl
# -*- ispell-dictionary: "american" -*-
package Local::Modulino; #[http://www.drdobbs.com/scripts-as-modules/184416165]
use strict;
use warnings;
use encoding::warnings 'FATAL';
use 5.10.0;
use utf8;
use open ':utf8';
binmode(STDOUT, ':utf8');

use File::Path qw/mkpath rmtree/;              # use 'mkpath' and 'rmtree'
use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse    = 1;

import Local::Paths qw( abspath relpath rebase_path find_parent_path );

###############################################################################
##                                                                           ##
##  Settings                                                                 ##
##                                                                           ##
###############################################################################

our $VERSION       = "0.8.1";
our $STORE_VERSION = "0.1";
our $YEAR          = "2012-2014";
our $NAME          = (split_path(__FILE__))[1];# last non-slash part of path
our ($Keep, $Run, %Opt);

###############################################################################
##                                                                           ##
##  Informational Functions                                                  ##
##                                                                           ##
###############################################################################

sub version {
    local $, = "\n";
    say "$NAME $VERSION",
        "Copyright (C) $YEAR zrajm <fix\@zrajm.org>",
        "License CC BY-SA v3.0: Creative Commons Attribution-Share Alike 3.0",
        "    <http://creativecommons.org/licenses/by-sa/3.0/>",
        "You are free to share and modify this program, as long as you use",
        "the same license, and give due credit to its original author.";
    exit;
}

sub pod2ansi {
    my ($_) = @_;
    return undef unless defined($_);
    my %char = (quot => '"', amp => '&', lt => '<', gt => '>');
    s#E<([^>]*)>#$char{lc $1}#g;               # HTML-like entity
    s#B<([^>]*)>#\e[1m$1\e[0m#g;               # bold
    s#[FI]<([^>]*)>#\e[4m$1\e[0m#g;            # italic / filename
    s#C<([^>]*)>#"$1"#g;                       # quoted code
    return $_;
}

# usage(SOURCE, MSG) -- display usage information from SOURCE + display MSG
sub usage {
    my ($_, $msg) = @_;
    my $out;
    $out .= m#^=head1 \s+ SYNOPSIS \s+ (.*)#mx
        ? "Usage: " . pod2ansi($1) . "\n" : "";
    $out .= m#^=head1 \s+ NAME \s+ [-\w]+ \s+-\s+ (.*)#mx ? "\u$1.\n" : "";
    $out .= "\n" if $out;
    { # list --options (from comments) -- sort by longopt name
        my @opt_doc = ();
        my $opt_length = 0;
        while (/^ \s*
                (?: (['"])                     # start quote
                    ([^\n'"=:|]*?)             #   longopt
                    (?:
                           \|([^\n'"=|:]*?)    #   keep first shortopt
                        (?:\| [^\n'"=|:]+)*    #     (ignore more shortopts)
                    )?
                    (?:\+|([:=])[^\n'"=]*)?    #   option argument
                    \1 [^#]*                   # end quote
                |.*?)?(?<!\#)\#\#\#\s+(.*)$/xmg) { # description
            my $long  = $2 ? "--$2"  : "";
            my $short = $3 ?  "-$3," : "";
            my $arg   = $4;
            my $desc  = $5;
            # if option takes arg, and 1st word in description is uppercase,
            # use that uppercase word in long description
            if ($arg and $desc =~ s/([A-Z0-9]+)\s*//) {
                $long .= $arg eq ":" ? "[=$1]" : "=$1";
            }
            push(@opt_doc, [ $short, $long, pod2ansi($desc) ]);
            my $length = length($long);
            $opt_length = $length if $length > $opt_length;
        }
        # length of longest option name
        if (@opt_doc) {
            $out .= join "", "Options:\n", map {
                sprintf "  %-3s %-${opt_length}s  %s\n", @$_
            } @opt_doc;
        }
    }
    print "$out\n" . pod2ansi($msg);
    exit;
}

sub help {
    usage(read_file(__FILE__), <<'EOF');
Fix wiki: [https://github.com/zrajm/fix/wiki]
EOF
    exit;
}

sub man {
    my $pid = open(STDOUT, '|-', qw/man -l -/);# filter STDOUT through man(1)
    die "Cannot run 'man': $!\n" unless defined $pid;
    system('pod2man', __FILE__);               # output manpage on STDOUT
    if ($? == -1) {                            # on exec FAILURE
        kill TERM => $pid;                     #   kill man child and die
        die "Cannot execute 'pod2man': $!\n";
    };
    close STDOUT;                              # don't make man wait for more
    wait();                                    # wait until user exits man
    exit;
}

###############################################################################
##                                                                           ##
##  State Storage Module                                                     ##
##                                                                           ##
###############################################################################

{
    package Local::Store;
    use File::Path qw/mkpath rmtree/;          # use 'mkpath' and 'rmtree'
    use Data::Dumper;
    $Data::Dumper::Indent   = 1;
    $Data::Dumper::Sortkeys = 1;
    $Data::Dumper::Terse    = 1;
    import Local::Paths 'abspath';

    # Usage: new Local::Store(dir => DIR, namefilter => CODEREF);
    #
    # DIR is the base of the directory tree used for storage. (It is created
    # when set() is first called, not when new() is invoked.)
    #
    # NAMEFILTER is a coderef, and if specified, it will be used to modify the
    # filename argument passed to get/set, before it is used. It will be called
    # with a single filename as argument, and is expected to return a relative
    # filename, without leading '..' components. (The name of the file
    # read/written by the get/set command.)
    sub new {
        my ($class, %opt) = @_;
        my $self = bless({
            dir        => $opt{dir},
            namefilter => $opt{namefilter} // sub { shift() },
            print      => {},
            state      => {},
        });
        die "new Local::Store() 'namefilter' value must be coderef,"
            if ref($self->{namefilter}) ne 'CODE';
        return $self;
    }

    # Read file stat fingerprint. If this is unchanged since a previous check,
    # know the file is unchanged. If fingerprint has changed, then we need to
    # look at the file content to determine whether that has changed or not.
    # The following lstat() properties are used:
    #
    #      1 ino      inode number
    #      2 mode     file mode (type and permissions)
    #      4 uid      numeric user ID of file's owner
    #      5 gid      numeric group ID of file's owner
    #      7 size     total size of file, in bytes
    #      9 mtime    last modify time in seconds since the epoch
    #     10 ctime    inode change time in seconds since the epoch (*)
    #
    # [http://www.kernel.org/pub/software/scm/git/docs/technical/racy-git.txt]
    #
    # Note: We can't use Time::HiRes here, since it only supports lstat() since
    # February 2013. [https://rt.cpan.org/Public/Bug/Display.html?id=83356]
    sub _read_file_fingerprint {
        my ($file) = @_;
        my @lstat = lstat($file) or die "Cannot lstat file '$file': $!\n";
        return join("-", @lstat[1, 2, 4, 5, 7, 9, 10]);
    }

    sub _read_file {
        my ($file) = @_;
        open(my $in, "<:utf8", $file)
            or die "Cannot open file '$file' for reading: $!\n";
        local $/ = undef;
        return <$in>;
    }

    sub _write_file {
        my ($file, @data) = @_;
        my $tempfile = "$file--writing";
        # create full path of file, before writing file
        if (my ($dir) = $tempfile =~ m#^(.*)/#) {
            die "Cannot create dir '$dir': File already exists\n"
                if -e $dir and not -d $dir;
            unless (-d $dir or mkpath($dir)) {
                die "Cannot create dir '$dir'\n";
            }
        }
        open(my $out, ">:utf8", $tempfile)
            or die "Cannot open tempfile '$tempfile' for writing: $!\n";
        print $out @data
            or die "Cannot write to tempfile '$tempfile': $!\n";
        close($out)
            or die "Cannot close tempfile '$tempfile' after writing: $!\n";
        rename($tempfile, $file)
            or die "Cannot rename tempfile '$tempfile' -> '$file': $!\n";
    }

    # Turn filename into storage path, return undef if outside store dir.
    sub _file_name {
        my ($self, $file) = @_;
        my $_ = abspath(
            $self->{namefilter}($file),
            $self->{dir}
        );
        return m#^\Q$self->{dir}/# ? $_ : undef;
    }

    # Reread state file if its stat fingerprint has changed last read/write.
    sub _read_state {
        my ($self, $file) = @_;
        my $full = $self->_file_name($file) // return {};
        my ($state, $print) = @$self{ qw/ state print / };
        if (-f $full) {                        # state file exists
            my $print2 = _read_file_fingerprint($full);
            if ($print2 ne ($print->{$file} // '')) {
                $print->{$file} = $print2;     #   read if modified
                $state->{$file} = eval _read_file($full);
            }
        }
        return $state->{$file} //= {};
    }

    sub _write_state {
        my ($self, $file) = @_;
        my $full = $self->_file_name($file) // return {};
        my ($state, $print) = @$self{ qw/ state print / };
        _write_file($full, Dumper($state->{$file}));
        $print->{$file} = _read_file_fingerprint($full);
    }

    sub get {
        my ($self, $file, @field) = @_;
        die "get(): Missing arguments: No field names given," if @field == 0;
        my $state = $self->_read_state($file);
        return wantarray()
            ? map { $state->{$_} } @field
            : $state->{ $field[0] };
    }

    # If a value is a coderef, then that will be invoked with the original
    # value, and whatever it returns will be stored in its stead.
    #
    # Will create directories (and subdirectories) as needed).
    sub set {
        my ($self, $file, %arg) = @_;
        return if $file eq '';
        my $state = $self->_read_state($file);
        foreach my $field (keys %arg) {
            $state->{$field} =
                ref($arg{$field}) eq 'CODE'    # run callback
                    ? $arg{$field}->($state->{$field})
                    : $arg{$field};            #   or use literal value
        }
        $self->_write_state($file);
    }

    # Deletes named files. Use single argument '.' to delete entire storage.
    sub delete {
        my ($self, @file) = @_;
        if (@file ~~ [ '.' ]) {
            rmtree($self->{dir});
        } else {
            foreach (@file) {
                my $full = $self->_file_name($_);
                rmtree($full);
            }
        }
        return $self;
    }
}

###############################################################################
##                                                                           ##
##  Cwd Wrapper Module                                                       ##
##                                                                           ##
###############################################################################

# Package used here to contain Cwd functions from leaking out into the 'main::'
# namespace, where it would be very easy to accidentally use it. We don't want
# cwd()! It gives *physical* instead of *logical* paths! (Bugs ahoy!) :(
{
    package Local::Paths;
    BEGIN {
        use Exporter 'import';
        our @ISA       = qw(Exporter);
        our @EXPORT_OK = qw(abspath relpath rebase_path find_parent_path);
    }
    # Current working directory. Returns environment variable '$PWD' (= logical
    # path) if available, and falls back to returning Perl's cwd() if that
    # fails. (NOT EXPORTED: Use abspath(".") from outside module.)
    sub current { $ENV{PWD} // do { use Cwd; Cwd::cwd() } }
    BEGIN {
        *CORE::GLOBAL::chdir = sub {
            my $dir = abspath(shift());
            return 1 if $dir eq $ENV{PWD};
            CORE::chdir($dir) and $ENV{PWD} = $dir;
        };
    }
    # Clean up a path without looking at the file system.
    sub clean {
        my ($path) = @_;
        my @newpart;
        foreach my $part (split m#/+#, $path) {
            next if $part eq '.';              # skip '.' components
            if ($part eq '..') {               # remove previous component
                if (@newpart > 0               #   unless at beginning
                        and $newpart[-1] ne '..') {# or preceded by '..'
                    pop @newpart;
                    next;
                }
            }
            push(@newpart, $part);
        }
        my $newpath = join '/', @newpart;
        return ($newpath eq '')                # if path is '', then look at
            ? (($path =~ m#^/#) ? '/' : '.')   #   original path to see if it
            : $newpath;                        #   started with '/'
    }
    # Return absolute path ($path is relative to $basedir, or current dir).
    sub abspath {
        my ($path, $basedir) = @_;
        return current() if not defined($path);
        $basedir //= current();
        clean($path =~ m#^/# ? $path : join('/', $basedir, $path));
    }
    # Return relative path (relative to $basedir, or current dir). $path and
    # $basedir may be absolute or relative (to the current dir).
    sub relpath {
        my ($path, $basedir) = @_;
        return '.' if not defined($path);
        my @path = split('/', abspath($path),                 -1);
        my @base = split('/', abspath($basedir // current()), -1);
        while (@path and @base                 # remove all identical dirs
                and $path[0] eq $base[0]) {
            shift(@path);
            shift(@base);
        }
        pop @base if @base and $base[-1] eq '';# happens if $basedir = '/'
        return join('/', ('..') x scalar(@base), @path);
    }
    # Return absolute path after rewriting $path, so that is is relative to
    # $new_basedir, instead of $old_basedir.
    sub rebase_path {
        my ($path, $old_basedir, $new_basedir) = @_;
        return ($old_basedir eq $new_basedir)
            ? abspath($path)
            : abspath(relpath($path, $old_basedir), $new_basedir);
    }
    # Searches for each of the named files, first in DIR, then the dir above
    # that, etc. all the way up to the specified CEILING_DIR. Return name of
    # found file, or empty string on failure.
    sub find_parent_path {
        my ($dir, $ceiling_dir, @file) = @_;
        ($dir, $ceiling_dir) = (abspath($dir), abspath($ceiling_dir));
        die "Start dir '$dir' must be inside top dir '$ceiling_dir'\n"
            unless $ceiling_dir eq '/' or $dir =~ m#^\Q$ceiling_dir\E($|/)#;
        while (1) {
            foreach (@file) {                  # look for each file
                my $file = "$dir/$_";
                return $file if -e $file;
            }
            return '' if $dir eq $ceiling_dir;
            $dir = do {
                my $next = clean("$dir/..");
                return '' if $dir eq $next;
                $next;
            };
        }
    }
}

###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

sub TRUE  { 1 }
sub FALSE { 0 }

sub SOURCE { 'source' }
sub TARGET { 'target' }

sub PLAIN { 0 }                                # loglevel for msg()
sub BOLD  { 1 }

sub ERROR   { 4 }                              # red
sub WARN    { 2 }                              # yellow
sub INFO    { 3 }                              # green
sub VERBOSE { 3 }                              # green
sub DEBUG   { 0 }                              # plain
{
    my @ansi = ("\e[m", "\e[1m", "\e[33m", "\e[32m", "\e[31m");
    # Return indented and colorized message.
    sub msg {
        my ($loglevel, $message) = @_;
        die "msg(): missing loglevel" unless defined $ansi[$loglevel];
        chomp $message;
        return "$ansi[$loglevel]$NAME " . ("  " x ($Opt{level} - 1)) .
            $ansi[BOLD] . $message . $ansi[PLAIN] . "\n";
    }
}
sub info {
    my ($msg) = @_;
    say STDERR "\e[32m$NAME " . ("  " x ($Opt{level} - 1)) . "\e[1m$msg\e[m";
}
# Display verbose msg in mother process or all processes with --verbose/--debug
sub verb { (is_child() or $Opt{debug} or $Opt{verbose}) and info @_ }
sub debug {
    return unless $Opt{debug};
    my ($msg) = @_;
    say STDERR "$NAME " . ("  " x ($Opt{level} - 1)) . $msg;
}
sub quit {
    ($!, my $msg) = @_;
    die $msg // "", "\n";
}

sub is_child { $Opt{parent} ne '' }
sub store_version_on_disk {
    my $file = "$Opt{fixdir}/store_version";
    if (-e $Opt{fixdir}) {
        return read_file($file) if -e $file;
        return '';
    }
    write_file($file, $STORE_VERSION);
    return $STORE_VERSION;
}

sub  strip_worktree { relpath(shift(), $Opt{worktree}) }
sub prefix_worktree { abspath(shift(), $Opt{worktree}) }

# Set runstate value for '--stats'. If value already set, don't change it.
sub did {
    return unless $Opt{stats};
    my ($name, $value) = @_;
    $Run->set($name, build_status => sub { shift() // $value });
}

# Take a list of dependencies as expressed in the keepstate, and turn it into a
# list of arrayrefs suitable for feeding into update_targets().
#
# Keepstate format is: (FILE1:CHECKSUM2, FILE2:CHECKSUM2...).
sub get_keepstate_deps {
    return map {
        my ($file, $checksum) = m#^(.*):([A-Za-z0-9+/]{27})$#;
        [ prefix_worktree($file) => $checksum ];
    } @_;
}

sub keepstate_deps {
    my @file = @_;
    map { join ':', strip_worktree($_), checksum_file($_) } @file;
}

sub add_deps {
    my ($target, @dep) = @_;
    $Keep->set($target, deps => sub {
        [ @{ shift() // [] }, [ keepstate_deps(@dep) ]];
    });
}

sub set_source_state {
    my ($source) = @_;
    $Keep->set($source,
        type     => SOURCE,
        checksum => checksum_file($source),
    );
}

# Returns a __DIE__ handler function, which reinstates previously existing
# __DIE__ handler before it calls die() itself. Take coderef as argument.
# Whatever is returned by coderef function will be the error message.
sub subdie {
    my $code = shift();
    my $old  = $SIG{__DIE__};
    return sub {
        chomp(my @arg = @_);
        local $SIG{__DIE__} = $old;
        $code->(@arg);
    };
}

sub read_file {
    my ($file) = @_;
    open(my $in, "<:utf8", $file)
        or die "Cannot open file '$file' for reading: $!\n";
    local $/ = undef;
    return <$in>;
}

sub write_file {
    my ($file, @data) = @_;
    my $tempfile = "$file--writing";
    # create full path of file, before writing file
    if (my $dir = split_path($tempfile)) {
        die "Cannot create dir '$dir': File already exists\n"
            if -e $dir and not -d $dir;
        unless (-d $dir or mkpath($dir)) {
            warn "Cannot create dir '$dir'\n";
            return undef;
        }
    }
    open(my $out, ">:utf8", $tempfile)
        or die "Cannot open tempfile '$tempfile' for writing: $!\n";
    print $out @data
        or die "Cannot write to tempfile '$tempfile': $!\n";
    close($out)
        or die "Cannot close tempfile '$tempfile' after writing: $!\n";
    rename($tempfile, $file)
        or die "Cannot rename tempfile '$tempfile' -> '$file': $!\n";
}

sub rename_file {
    my ($file1, $file2) = @_;
    rename($file1, $file2) or "Cannot rename '$file1' -> '$file2': $!\n";
}

sub checksum_file {
    my ($file) = @_;
    return '' unless -f $file;
    use Encode qw(encode_utf8);
    use Digest::SHA qw(sha1_base64);
    sha1_base64(encode_utf8(read_file($file)));
}

{
    # Simple git escape codes.
    my %x = ('"' => '"', '\\' => '\\', 'n' => "\n", 't' => "\t", 'b' => "\b");
    my $double = qr{"((?:[^\"\\]|\\.)*)"};
    my $word   = qr{([A-Za-z][A-Za-z0-9-]*)};

    sub unesc { my $_ = shift(); s{\\(.)}{ $x{$1} // $1 }gex; $_ }
    sub trim  { my $_ = shift(); s{\s+$}{};                   $_ }

    # Read .ini style config file, return hashref with its content.
    sub read_config {
        my ($file) = @_;
        open(my $cfg, "<:utf8", $file)
            or die "Cannot open config file '$file' for reading: $!\n";
        local $SIG{__DIE__} = subdie(sub {
            $! = 254;
            die "Bad config '" . relpath($file, $Opt{pwd}) . "': " .
                "@_ in line $.\n";
        });
        my ($s, %cfg);
      LINE: while (<$cfg>) {
            chomp;
            my ($len, $n) = length($_);        # line length, property name
          START: {
                m{\G \s*               }gcx;
                pos() == $len               and              next LINE;
                m{\G [#;]              }gcx and              next LINE;
                m{\G       $word       }gcx and $n = lc($1), goto ASSIGN;
                m{\G \[\s* $word \s*\] }gcx and $s = lc($1), goto START;
                die "Neither '[section]' nor 'variable = value'\n";
            }
          ASSIGN: {
                defined $s           or  die "No '[section]' found\n";
                m{\G \s*        }gcx;
                pos() == $len        and $cfg{$s}{$n} =       '1', goto EOF;
                m{\G \s* \= \s* }gcx or  die "Not 'variable = value'\n";
                m{\G $double    }gcx and $cfg{$s}{$n} = unesc($1), goto EOF;
                m{\G ([^;#]*)   }gcx and $cfg{$s}{$n} =  trim($1), goto EOF;
                die "This cannot happen\n";
            }
          EOF: {
                m{\G \s*  }gcx;
                pos() == $len  and next LINE;
                m{\G [#;] }gcx and next LINE;
                die "Unknown stuff after '[section]' or 'variable = value'\n";
            }
        }
        return %cfg;
    }
}

# Add the currently running fix instance to (first dir in) $PATH (which is
# inherited by all child processes). -- This makes sure that all subsequent
# buildscripts that calls to fix will find it, even when fix wasn't in the
# user's $PATH to begin with.
#
# To do this, a '.fix/bin' directory is created, and a symlink to the currently
# running fix instance is placed there. Thereafter this dir is tucked onto the
# beginning of the $PATH environment variable (which is inherited by our
# children).
sub add_fix_to_path {
    my ($dir)  = @_;
    my $bindir = "$dir/bin";
    my $link   = "$dir/bin/$NAME";             # name of link to create
    if (not -l $link) {                        # if missing '.fix/bin/fix'
        if (not -d $bindir) {                  #   make sure '.fix/bin' exists
            mkpath($bindir)
                or die "$NAME: Cannot create dir '$bindir'\n";
        }
        symlink($Opt{cmd}, $link)
            or die "$NAME: Cannot create symlink '$link': $!\n";
    }
    my $full = abspath($bindir);
    # FIXME: A directory in $PATH *cannot* contain a colon (stupid, I know).
    # Therefore the cwd cannot contain a colon (we could fix this by having
    # this stuff in /tmp, I guess).
    if ($full =~ /:/) {                        # guard for stupid system bug
        die "$NAME: Colon not allowed in current dir path " .
            "('" . abspath() . "')\n";
    }
    $ENV{PATH} = "$full:$ENV{PATH}";           # add dir to path
}

# Redirect standard output to FILE. Return hashref suitable for passing to
# restore_stdout(), or die() on failure.
sub redirect_stdout {
    my ($file) = @_;
    my $prev = { flush => $|, handle => undef, file => $file };
    open($prev->{handle}, '>&', 'STDOUT')
        or die "Cannot copy old STDOUT before redirect to '$file': $!\n";
    if (not -d (my $dir = split_path($file))) {
        mkpath($dir)
            or die "Cannot create dir '$dir' for STDOUT redirect: $!\n";
    }
    open(STDOUT, '>', $file)
        or die "Cannot redirect STDOUT to file '$file': $!\n";
    select STDOUT;
    local $| = 1;                              # turn off buffering
    return $prev;
}

# Restore standard output after redirect_stdout(). PREV is the hashref returned
# by redirect_stdout(). Die()s on failure.
sub restore_stdout {
    my ($prev) = @_;
    close(STDOUT);
    open(STDOUT, '>&', $prev->{handle})
        or die "Cannot restore STDOUT after redirect " .
            "to file '$prev->{file}': $!\n";
    close($prev->{handle});
    select STDOUT;
    local $| = $prev->{flush};                 # restore buffering
}

# Redirect standard output to FILE, execute CODEREF, then restore STDOUT.
# CODEREF is passed a single argument containing FILE.
sub redir_stdout {
    my ($file, $coderef) = @_;
    my $oldout = redirect_stdout($file);
    my @result = &$coderef($file);
    restore_stdout($oldout);
    return wantarray() ? @result : $result[0];
}

# Return substrings, or in scalar context, substring count.
sub substrings {
    my ($str, $substr) = @_;
    my @match = $str =~ m/$substr/g;
    return @match;
}

# FIXME: What *should* split_path('.') return?
sub split_path {
    my ($_) = @_;
    my @x = (
        m#^ (.*?) /+ ([^/]+) /* $#x
            ? (($1 eq '' ? '/' : $1), $2)
            : ('.', $_)
    );
    return wantarray() ? @x : $x[0];
}

# Given the basename of a target return a list of possible buildscript
# basenames. The following list will result from 'target.tar.gz' as input:
#
#     default.tar.gz.fix
#     default.tar.fix
#     default.fix
#
sub possible_buildscripts {
    my ($file) = @_;
    my @p = split m#\.+#, $file;
    $p[0] = 'default';
    map { join('.', @p[ 0 .. $_ ]) . '.fix' } reverse 0 .. $#p;
}

# Returns (relative) path of buildscript for the specified target, or empty
# string if no buildscript could be found.
#
# If 'TARGET.fix' couldn't be found, this will look for each possible default
# buildscript, first in the current directory, then in directory above that,
# etc. until we reach root. (The last file looked at is '/default.fix' which is
# probably a bit naive.)
sub find_buildscript {
    my ($target) = @_;
    my $script = rebase_path("$target.fix", $Opt{worktree}, $Opt{scripttree});
    return $script if -e $script;
    my $dir         = split_path($script);
    my $ceiling_dir = $Opt{scripttree} // $Opt{worktree};
    my @possible    = possible_buildscripts($target);
    return find_parent_path($dir, $ceiling_dir, @possible);
}

# NB: $file must exist for has_changed() to give meaningful result
sub has_changed {
    my ($file) = @_;
    my $checksum = $Keep->get($file, 'checksum') // '';
    return checksum_file($file) eq $checksum ? 0 : 1;
}

# build_target($level, $target);
#
# Builds TARGET by executing its buildscript. Return TRUE if the content of
# TARGET was modified because of the (re)build, FALSE if target was not
# modified. Die()s on error.
#
# NOTE: If a target was rebuilt, but the target content remained the same after
# the rebuild, then that target does not count as updated. (This can happen
# e.g. when the build file was modified in a way that did not change its output
# [e.g. a comment was added to it] or if a deleted target with unmodified
# dependencies was rebuilt.)
sub build_target {
    my ($level, $buildscript, $target) = @_;
    debug("Building target: $target");
    info(strip_worktree($target));
    if (-f $target and has_changed($target)) {
        $Run->set($target,      ABORT => strip_worktree($target));
        $Run->set($Opt{parent}, ABORT => strip_worktree($target))
            if is_child();
        did($target, 'wont_overwrite');
        quit(253, strip_worktree($target) .
            ": Target externally modified, aborting");
    }
    # clear dependency information (rebuilt each run)
    $Keep->set($target,
        type => TARGET,
        deps => [[ keepstate_deps($buildscript) ]],
    );

    my $builddir = split_path($buildscript);
    chdir($builddir)
        or die "Cannot change dir to buildscript dir '$builddir': $!\n";

    my $outfile = "$target--fixing";
    my ($close, $exit, $errno) = redir_stdout($outfile, sub {
        local $ENV{FIX_PARENT} = $target;
        local $ENV{FIX_LEVEL}  = $level;
        no warnings 'exec';                    # disable "can't exec" warnings
        open(my $fh, '|-', $buildscript, $outfile, $target)
            or die "Cannot execute buildscript '",
                strip_worktree($buildscript), "': $!\n";
        return (close($fh), $?, $!);
    });

    # NOTE: outfile is kept on failure (so user may inspect it)
    #
    # - Except when a dependency completely failed to run (e.g. its output file
    #   was externally modified) in which case we remove the outfile.
    if (not $close) {
        $exit >>= 8;
        if ($errno != 0) {
            did($target, 'shell_error');
            die "Cannot run buildscript '",
                strip_worktree($buildscript), "': $errno\n";
        }
        my $aborted_target = $Run->get($target, 'ABORT') // '';
        if ($aborted_target eq '') {           # buildscript returned non-zero
            did($target, 'buildscript_error');
            quit($exit, strip_worktree($target) . ": exit status $exit");
        }
        # a dependency failed to run
        unlink($outfile);                      #   erase outfile and
        $Run->set(                             #     and tell our parent that
            $Opt{parent},                      #     that we failed, too
            ABORT => $aborted_target,
        ) if is_child();
        did($target, 'buildscript_error');
        exit $exit;
    }

    my $old_checksum = $Keep->get($target, 'checksum') // '';
    my $new_checksum = checksum_file($outfile);
    if ($new_checksum eq $old_checksum) {      # target unmodified
        if (-e $target) {                      #   if target exist
            unlink($outfile);
            did($target, 'rebuilt_but_kept_previous');
        } else {                               #   if target was deleted
            rename_file($outfile, $target);
            did($target, 'rebuilt_replaced_deleted');
        }
        return FALSE;
    }
    rename_file($outfile, $target);            # target modified
    $Keep->set($target, checksum => $new_checksum);
    did($target, 'rebuilt_new_content');
    return TRUE;
}

# update_targets($level, [ $target => $checksum ]...);
#
# Make sure all TARGET(s) are up-to-date, rebuilding them if necessary. Return
# TRUE if the content one or more TARGET(s) was modified because of a rebuild,
# FALSE if no targets were modified. Die()s on error.
#
# NOTE: If a target was rebuilt, but the target content remained the same after
# the rebuild, then that target does not count as updated. (This can happen
# e.g. when the build file was modified in a way that did not change its output
# [e.g. a comment was added to it] or if a deleted target with unmodified
# dependencies was rebuilt.)
sub update_targets {
    my ($level, @target) = @_;
    local $Opt{level} = $level;
    my $changed  = FALSE;
  TARGET: foreach my $target (@target) {
        my ($target, $checksum) = @$target;
        debug("Updating target: $target");
        if ($target !~ m#^\Q$Opt{worktree}\E($|/)#) {
            quit(254, "Target '" . strip_worktree($target) . "' is outside " .
                     "fix's worktree");
        }
        my ($type, $dep_clusters) = $Keep->get($target, 'type', 'deps');
        $type //= '';
        # buildscript source
        if ($type eq SOURCE) {                 # buildscript source
            if (has_changed($target)) {
                set_source_state($target);
                $changed = TRUE;
            }
            next TARGET;
        }
        my $buildscript = find_buildscript($target);
        if (not -f $buildscript) {
            quit(254, "No rule to make target '" .
                strip_worktree($target) . "'");
        }
        if ($type eq '') {                     # target is not known by fix
            set_source_state($buildscript);
            build_target($level, $buildscript, $target)
                and $changed = TRUE;
        } elsif ($type eq TARGET) {            # file previously seen by fix
            info(strip_worktree($target) . " (previously built)");
            my $deps_changed = FALSE;
            foreach my $deps (@$dep_clusters) {#   check deps
                update_targets($level + 1, get_keepstate_deps(@$deps))
                    and $deps_changed = TRUE;
            }
            if ($deps_changed or (not -e $target) or has_changed($target)) {
                build_target($level, $buildscript, $target)
                    and $changed = TRUE;
            } else {
                did($target, 'wont_rebuild');
                my $old_checksum = $Keep->get($target, 'checksum') // '';
                $changed = TRUE if $checksum ne $old_checksum;
            }
        }
    }
    return $changed;
}

###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################

# In this function we use very plain die() and warn() messages (not colorized,
# as in rest of fix).
sub getopts {
    my @arg = (my @orgarg) = @_;
    %Opt = (
        cmd        =>   $ENV{FIX_CMD},         # set by mother
        debug      => !!$ENV{FIX_DEBUG},
        fixdir     =>   $ENV{FIX_DIR},         # set by mother
        # force    => !!$ENV{FIX_FORCE},
        level      =>   $ENV{FIX_LEVEL}  += 1,
        parent     =>   $ENV{FIX_PARENT} // '',
        pid        =>   $ENV{FIX_PID},         # set by mother
        pwd        =>   $ENV{FIX_PWD},         # set by mother
        scripttree =>   $ENV{FIX_SCRIPT_TREE}, # set by mother
        source     =>   0,
        stats      => !!$ENV{FIX_STATS},
        verbose    => !!$ENV{FIX_VERBOSE},
        worktree   =>   $ENV{FIX_WORK_TREE},   # set by mother
    );
    use Getopt::Long qw(
        GetOptionsFromArray :config
        posix_default bundling gnu_compat no_ignore_case permute
    );
    # Modify Getopt::Long's error messages:
    #   'Option <OPT> requires an argument' and 'Unknown option: <OPT>',
    #   should have "'--option'" or "'-o'" rather than just "option" or "o".
    my $warn = FALSE;
    local $SIG{__WARN__} = sub {
        my ($_) = @_;
        $warn = TRUE;
        s{(\boption[: ]+)([-\w]+)}{
            my $x = length($2) == 1 ? '-' : '--';
            "$1'$x$2'";
        }ie;
        warn "$NAME: $_";
    };
    my @execpath;
    GetOptionsFromArray(\@arg,
        'debug|D'  => sub {           ### debug output + verbose buildscripts
            $Opt{debug} = $ENV{FIX_DEBUG} = TRUE;
        },
        'exec-path=s' => sub {        ### DIR add DIR to $PATH before building
            push @execpath, abspath(pop(@_), $Opt{pwd});
        },
        # 'force|f'  => sub {         ## overwrite manually edited files
        #     $Opt{force} = $ENV{FIX_FORCE} = TRUE;
        # },
        'help|h|?'  => \$Opt{help},   ### display this help and exit
        'man|M'     => \$Opt{man},    ### display program manpage and exit
        'source'    => \$Opt{source}, ### declare source dependencies
        'script-tree=s'               ### DIR script tree root for build project
            => \$Opt{scripttree},
        'stats'     => sub {          ##  save stats in .fix dir (for testing)
            $Opt{stats} = $ENV{FIX_STATS} = TRUE;
        },
        'verbose|v' => sub {          ### output status info while building
            $Opt{verbose} = $ENV{FIX_VERBOSE} = TRUE;
        },
        'version|V' => \$Opt{version},### output version information and exit
    );
    quit(254, "Try '$NAME --help' for more information.") if $warn;
    foreach (qw( help man version )) { eval $_ if $Opt{$_} }
    warn "No target specified\n" if @arg == 0;
    if (not is_child()) {
        warn "Option '--source' can only be used inside buildscript\n"
            if $Opt{source};
        $Opt{pid} = $ENV{FIX_PID} = $$;
        $Opt{pwd} = $ENV{FIX_PWD} = abspath();
        $Opt{cmd} = $ENV{FIX_CMD} = abspath(__FILE__);
        $Opt{scripttree} = abspath($Opt{scripttree}) if defined $Opt{scripttree};
        if (defined $Opt{fixdir}) {            # fixdir set by user
            $Opt{fixdir}   = abspath($Opt{fixdir});
            $Opt{worktree} = abspath($Opt{worktree});
        } else {                               # fixdir not set by user
            if (my $rcfile = find_parent_path('.', '/', '.fixrc')) {
                my $dir        = split_path($rcfile);
                $Opt{fixdir}   = "$dir/.fix";
                $Opt{worktree} = "$dir";
            } else {
                warn "Current dir not in a fix worktree\n",
                    "(Use 'touch .fixrc' where you want the worktree root.)\n";
            }
        }
        if ($Opt{fixdir} and store_version_on_disk() ne $STORE_VERSION) {
            warn "State storage disk format has changed, full rebuild needed\n",
                "(Erase '.fix' directory in worktree root and run again.)\n";
        }
        push(@execpath, abspath(delete $ENV{FIX_EXEC_PATH}, $Opt{pwd}))
            if exists $ENV{FIX_EXEC_PATH};
        if ($Opt{worktree}) {
            eval {
                my %cfg = read_config("$Opt{worktree}/.fixrc");
                if (defined(my $execpath = delete $cfg{core}{execpath})) {
                    push @execpath, abspath($execpath, $Opt{worktree});
                }
                if (defined(my $scripttree = delete $cfg{core}{scripttree})) {
                    $Opt{scripttree} //= abspath($scripttree, $Opt{worktree});
                }
                # Check for unknown config variables
                foreach my $section (sort keys %cfg) {
                    foreach my $var (sort keys %{ $cfg{$section} }) {
                        warn "Unknown variable '$var' in section [$section]\n"
                            if exists $cfg{$section}{$var};
                    }
                }
            };
            if ($@) { warn $@ }
        }
    }
    quit(254, "Try '$NAME --help' for more information.") if $warn;
    $ENV{PATH}            = join(':', @execpath, $ENV{PATH});
    $ENV{FIX_DIR}         = $Opt{fixdir};
    $ENV{FIX_SCRIPT_TREE} = $Opt{scripttree} //= $Opt{worktree};
    $ENV{FIX_WORK_TREE}   = $Opt{worktree};
    $Run = new Local::Store(
        dir        => "$Opt{fixdir}/run",
        namefilter => \&strip_worktree,
    );
    $Keep = new Local::Store(
        dir        => "$Opt{fixdir}/keep",
        namefilter => \&strip_worktree,
    );
    if ($Opt{stats}) {                         # write '--stats'
        my $stats = new Local::Store(dir => $Opt{fixdir});
        $stats->delete('stats')                #   mother deletes earlier stats
            unless is_child();
        $stats->set('stats',                   #   count fix invocations
            run_count   => sub { (shift() // 0) + 1 },
            run_targets => sub {               #   save args for each call
                my @arg = map {
                    m#^-# ? $_ : relpath($_, $Opt{worktree});
                } @orgarg;
                [ @{ shift() // [] }, \@arg ];
            },
        );
    }
    return map { abspath($_) } @arg;
}

###############################################################################
##                                                                           ##
##  Main                                                                     ##
##                                                                           ##
###############################################################################

# run after all globals etc. has been set up properly
__PACKAGE__->run(@ARGV) unless caller();

sub run {
    my ($class, @target) = @_;
    @target = getopts(@target);
    if ($Opt{source}) {                        #   '--source' = don't build
        set_source_state($_) foreach @target;
        add_deps($Opt{parent}, @target);
        exit 0;
    }
    %SIG = (
        __WARN__ => sub { warn msg(WARN,  @_) },
        __DIE__  => sub { die  msg(ERROR, @_) },
    );
    unless (is_child()) {                      # MOTHER PROCESS
        $Run->delete('.');                     #   delete previous runstate
        add_fix_to_path($Opt{fixdir});
    }
    my @dep = map { [ $_ => $Keep->get($_, 'checksum') // '' ] } @target;
    update_targets($Opt{level}, @dep);
    add_deps($Opt{parent}, @target) if is_child();
}

__END__

=head1 NAME

fix - Efficiently build (and rebuild) TARGET(s) based on dependencies

=head1 SYNOPSIS

B<fix> [I<OPTION>]... I<TARGET>...

B<fix> [I<OPTION>]... B<--source> I<FILE>...

=head1 DESCRIPTION

B<Fix> is a build system. As such, it uses B<buildscripts> to generate output
B<target>s (automatically keeping track said targets' dependencies), and when
invoked it performs the minimal action required to make sure the specified
targets are up-to-date, taking into account all changes in dependencies and
buildscripts since it was called last.

If that sounds vague, it is simply because a build system can do B<so much> -
it can be used to compile large software projects, generate HTML for a web page
(e.g. using Markdown source code, and template pages) or just about anything
else where you need to keep track of a long chain of dependencies, and B<update
I<only> those parts of the project which currently I<need> updating>.

B<Fix> is better than B<make> in that is does atomic updates of its targets, it
uses checksums (not timestamps) to figure out when a file has been modified,
and it has no problems with space (or any other weird character) in filenames.
Also, a failing build will not overwrite the a target generated by a previous,
successful build.

=head1 OPTIONS

Fix's behavior can specified using config file variables, by environment
variables, and by options on the command line. (The latter takes precedence
over the former.) Not all forms are applicable to all options.

=cut

# Mandatory arguments for long options are mandatory for short options too.

=over 4

=cut

# =item B<-a>, B<--always>
#
# Assume that all dependencies are dirty, and rebuild B<everything>.

# =item B<-c>, B<--clean>
#
# Remove all generated targets (except manually modified ones). Manually
# modified targets are listed separately, so that you might take care of them.
# If used with B<--force> files are clean regardless of whether or not they
# have been updated.

=item B<-D>, B<--debug>

Enable debug mode. This makes B<fix> to print quite a lot of diagnostics
messages throughout its run (more than B<--verbose>).

This option can also be enabled by setting the environment variable $FIX_DEBUG
(to anything except empty or zero). Regardless of whether B<--debug> or
$FIX_DEBUG was used, this causes the $FIX_DEBUG to be set inside all run
buildscripts (which is how this setting is passed down to all child instances
of B<fix> run from within those buildscripts).

=item B<--exec-path>=I<DIR>[:...]

This option prepends one or more I<DIR>(s) to the environment variable $PATH
(more than one path may be specified by separating them with ':'). Option may
also be used multiple times, in which case all the paths are added in the order
of occurrence. I<DIR> may be absolute or relative to the current working
directory.

Can also be set by config file variable B<core.execPath>, or environment
variable $FIX_EXEC_PATH. (These, unlike the command line option, can only be
specified only once.) If all three are used, they are put in the following
order in $PATH: B<--exec-path>, $FIX_EXEC_PATH, B<core.execPath>.

This option is useful when you have scripts or programs that do not reside in
your normal $PATH (e.g. scripts specific to one build project). You never need
to add fix itself, as this is done automatically. This option is similar, but
not quite the same as git's B<--exec-path>.

=cut

# =item B<-f>, B<--force>
#
# Normally, if you have edited (or otherwise modified) a file that B<fix> is
# trying to rebuild, you'll get an error and the build is interrupted. When you
# use B<--force>, B<fix> will be a lot less careful, and will overwrite these
# files instead. This is useful when you just don't care about these previous
# files for some reason. (Maybe you're doing fully automated rebuilds on a
# continuous integration server?)
#
# If you want to be careful about such cleanups, take a look at B<--clean> and
# B<--list> instead.
#
# Option is similar to git-checkout --force which "is used to throw away local
# changes."

=item B<-h>, B<--help>

Output a brief description of options etc on standard output, then exit.

=item B<-M>, B<--man>

Display this manpage, then exit. This option extracts the Perl POD (Plain Old
Documentation) documentation from the program and displays it using man(1).

=item B<--script-tree>=I<DIR> (Default: $FIX_WORK_TREE)

Set root path to the directory tree containing the buildscripts (the C<*.fix>
files). I<DIR> may be absolute or relative to the current working directory.
(This value may also be set using config file variable B<core.scriptTree> or
environment variable $FIX_SCRIPT_TREE.)

B<NOTA BENE>: The build metadata currently does not track changes in scripttree
very well. As long as you the same value for all invocations (and delete the
F<.fix> directory, and do a full rebuild whenever you change it) you should be
fine.

=item B<--source>

Can only be used inside buildscripts to register B<source dependencies>. With
this option, the arguments given on the command line refer to source files to
register as dependencies, instead of targets to be built. (See also
C<Dependencies> below.)

=item B<--stats>

Write some global build statistics to F<.fix/stats>, and also add
'build_status' information for each processed file in the runstate directory
(F<.fix/run/>). This is primarily intended for testing, and should not normally
be used. (For brevity this option is not included in the B<--help> info.)

This option can also be enabled by setting the environment variable $FIX_STATS
(to anything except empty or zero). Regardless of whether B<--verbose> or
$FIX_STATS was used, this causes the $FIX_STATS to be set inside all run
buildscripts (which is how this setting is passed down to all child instances
of B<fix> run from within those buildscripts).

=item B<-v>, B<--verbose>

Enable verbose mode, causing B<fix> to print some diagnostics messages
throughout its run (less than B<--debug>).

This option can also be enabled by setting the environment variable
$FIX_VERBOSE (to anything except empty or zero). Regardless of whether
B<--verbose> or $FIX_VERBOSE was used, this causes the $FIX_VERBOSE to be set
inside all run buildscripts (which is how this setting is passed down to all
child instances of B<fix> run from within those buildscripts).

=item B<-V>, B<--version>

Output program version information on standard output, then exit.

=back

=head1 EXIT STATUS

B<NOTE: Any buildscript can terminate with exit status 253-255, in which case
its return code is indistinguishable from the below cases!>

=over 4

=item B<0>

All targets and their dependencies were successfully built. (This is the only
exit status which is 100% reliable.)

=item B<E<gt>0>

Build failed. This usually means than one or more target failed to build. The
exact exit status will be the same as the exit status of the failing
buildscript.

=item B<253>

One or more targets were externally modified, and were not overwritten by
B<fix>.

=cut

# (You run the command again with the option B<--force> to force the targets
# overwritten).

=item B<254>

An early error occurred before even attempting to build. (Command line option
parsing error, a non-existing target specified on the command line etc.)

=item B<255>

Some basic file operation failed, e.g. a file could not be renamed, standard
output could not be redirected, a new shell could not be executed, or a
statefile was found to contain unintelligible data etc.

=back

=head1 USAGE

=head2 The Worktree Root

The worktree directory, with a F<.fixrc> file at the top level, is where all of
a project's build files reside. B<Fix> will never attempt to write anything
outside of the worktree.

The worktree is defined by the F<.fixrc> file, but B<fix> will also write its
statedir (containing all build metadata) in a directory called F<.fix>, in the
top level of the worktree. If this metadata is ever lost, B<fix> will do a full
rebuild, when next invoked, to reconstruct it.

=head1 BUILDSCRIPTS

The core of B<fix> is the B<buildscript>. Each buildscript is responsible for
building a single target, and the target's dependencies.

A buildscript is a small program. It should be executable (C<chmod +x FILE>),
and if it is a script of some kind (shell, Perl, whatever) it is must have the
appropriate shebang line (e.g. C<#!/bin/dash>).

=head2 Buildscript Output

Build output is written to temporary file, and only upon a upon a successful
build will fix (atomically) rename the tempfile to the actual target. If a
build fails, the tempfile is left as-is, so that the user may inspect it (in
trying to determine what went wrong). This also means that a fail rebuild will
not overwrite output generated by a previous (and successful) build.

For this scheme to work a buildscript must produce its output by either:

=over 4

=over 3

=item B<a)>

writing to its standard output (preferred method), or

=item B<b)>

writing to a tempfile (the name of which is determined by B<fix>, and passed in
as the first argument [C<$1> in most shells] to the buildscript).

=back

=back

B<NOTA BENE: Mixing the two methods will most likely lead to garbled output.>
(So don't do that.)

=head2 Buildscript Invocation

When a buildscript in invoked it is passed the following arguments:

=over 4

=over 4

=item B<$1> - (full path to) temporary output file

=item B<$2> - (full path to) target file buing built

=back

=back

=head2 Default Buildscripts

Buildscript are sought first based on target name, then by successively
removing file name extensions, then lastly by looking in parent directories.
Given the target C<TARGET.A.B>, this would entail looking for the following
files:

    TARGET.A.B.fix
    default.A.B.fix
    default.A.fix
    default.fix
    ../default.A.B.fix
    ../default.A.fix
    ../default.fix
    ../../default.A.B.fix
    ../../default.A.fix
    ../../default.fix

The search stops at the root of the worktree.

=head2 Declaring Target Dependencies

Dependencies are declared by invoking B<fix>, inside the buildscript, for each
of the dependencies. Fix thereafter keep track of these dependencies, and
rebuilds the target if any of the dependencies (or its buildscript) are
modified. There are two types of dependencies:

=over 4

=item B<source dependencies>

A dependency on a source file written by the user, not one built by B<fix>.
Declared (inside buildscript) using: C<B<fix --source> I<FILE>...>.

=item B<target dependencies>

A dependency on a target generated by B<fix>. Declared (inside the buildscript)
using: C<B<fix> I<TARGET>...> (without the B<--source> option).

=back

=head2 Example Buildscript

Here is a small example buildscript, called F<index.html.fix> (though it could
also have been called F<default.html.fix>). This buildscript first declare a
source dependency on the files F<head.md> and F<foot.md>, then builds
F<index.md>, then finally concatenates all these files and run them through
C<markdown> in order to produce HTML output.

    #!/bin/dash
    fix --source head.md foot.md
    fix index.md
    cat head.md index.md foot.md | markdown --html

After this buildscript has run, the target file (F<index.html>) will have been
built, and fix will have registered its source dependencies (F<head.md>,
F<foot.md>, and the buildscript itself, F<index.html.fix>) and target
dependencies (F<index.md> plus any dependencies F<index.md> itself might have,
recursively).

=cut

# =head2 About Target Files
#
# When a target file is built B<fix> records a SHA1 sum of the generated file.
# Upon rebuilding the same target B<fix> uses this SHA1 sum to determine if it
# is okay to overwrite the previous file as follows:
#
# =over 4
#
# =item B<Target file is non-existing or unmodified since last built>
#
# If a previously built target already exist but was written by B<fix> (and has
# not been modified since), B<fix> will do whatever it pleases with the file
# (delete it, overwrite it, whatever).
#
# =item B<Target file has been modified since last built>
#
# If a target file already exists but is unknown to B<fix>, or if the file is
# known but the content of the file has been modified in some way after B<fix>
# wrote it, then B<fix> will refuse to modify it and abort with an error
# message. (Use B<--force> to override this, and have B<fix> overwrite all
# target files.)
#
# B<NOTE:> B<fix> never cares about file timestamps, but only the I<content>.
# (So if you modify the timestamp, will not influence B<fix>'s decision of
# whether or not to overwrite the file.)
#
# =back
#
# =head1 DIAGNOSTICS
#
# [[ FIXME: The general rule of thumb is that errors printed to C<STDOUT> or
# C<STDERR> and intended for the end user are documented in DIAGNOSTICS while
# errors passed internal to the calling program and intended for other
# programmers are documented in ERRORS. When documenting a function that sets
# errno, a full list of the possible errno values should be given here. ]]
#
# =head1 EXAMPLES
#
# FIXME: Should include some useful examples!

=head1 ENVIRONMENT VARIABLES

The following variables are exported by B<fix> and are available for use by the
buildscripts. B<A buildscript should never change the content of these
variables> - though in most cases (all but $FIX_PARENT) it is fine to set these
variables from the command line when invoking B<fix>.

=head2 User Settable Environment Variables

Some environment variables may be set by user, before invoking fix. (It is not
recommended to change any $FIX_* variables from inside a buildscripts.)

=over 4

=item B<$FIX_DIR>

If $FIX_DIR is set it specifies a path to for the build metadata directory use
instead of the default F<.fix/>. It may be specified using an absolute or
relative path.

When $FIX_DIR is set, then $FIX_WORK_TREE defaults to the current directory
(unless that is explicitly set, too).

The mother process will make sure $FIX_DIR is an absolute path before passing
it on to its children. Note that B<fix> does whatever it damn well pleases with
this directory (including deleting parts or whole of its content) so don't
point $FIX_DIR to a directory where you have valuable data.

=item B<$FIX_DEBUG>

See B<--debug>.

=item B<$FIX_EXEC_PATH>

See B<--exec-path>. (May be absolute path, or path relative to the current
working directory.)

=cut

# =item B<$FIX_FORCE>
#
# See B<--force>.

=pod

=item B<$FIX_SCRIPT_TREE>

See B<--script-tree>. This variable is always set, but if scriptdir hasn't been
explicitly set by the user it will have the same value as $FIX_WORK_TREE.

=item B<$FIX_STATS>

See B<--stats>.

=item B<$FIX_VERBOSE>

See B<--verbose>.

=item B<$FIX_WORK_TREE>

If $FIX_WORK_TREE is set it specifies a path to use instead of the default
working tree root. It can be an absolute path, or a path relative to the
current working directory.

This value can only be specified $FIX_DIR is also set. If unset $FIX_WORK_TREE
defaults to the current directory.

The mother process makes sure $FIX_WORK_TREE is an absolute path before passing
it on to its children.

=back

=head2 Set by Fix Itself

These variables should not be set by the user, but their content may be
inspected from inside buildscripts.

=over 4

=item B<$FIX_CMD>

This environment variable contains the full path of the currently running
B<fix> executable. Normally, you do not need to use $FIX_CMD, since B<fix>
always makes sure that its binary can be found in the first dir in $PATH.

You can use this as a command in your buildscripts, to recursively invoke
B<fix>. A buildscript could, for example, look like this:

    $FIX_CMD a b
    cat a b | sed 's/^/>/'

The first line invokes C<fix a b> (thereby declaring F<a> and F<b> to be
dependencies of this script). The second line outputs the content of F<a> and
F<b>, and adds a C<E<gt>> sign to the beginning of each line.

If you started B<fix> by executing a symlink to B<fix>, rather than the actual
B<fix> program, then the name of the symlink will be the name in this variable.

=item B<$FIX_LEVEL>

Indicating the 'depth' of the current fix process. For the mother process
$FIX_LEVEL is set to '1', but it is incremented by each invoked child. (I.e.
$FIX_LEVEL '2' is a child of the mother process, '3' the grandchild etc.) This
is chiefly used to set the indentation level in status messages. (Analogous to
the shell's $SHLVL.)

=item B<$FIX_PARENT>

Set inside a buildscript that is a dependency of another buildscript.
$FIX_PARENT will contain the target for the buildscript that invoked it (for
the mother process this will be empty).

NB: The $FIX_PARENT variable is used internally to determine whether the
running instance of fix is the mother process or not, so this variable is
especially sensitive and might cause breakage if accidentally set.

=item B<$FIX_PID>

The process identification number of the mother process.

=item B<$FIX_PWD>

Absolute (logical) path of the user's current directory, as it was when fix was
invoked on the command line. This intentionally does not change during
recursive invocations of fix (and hence, from inside a buildscript this can
quite often differ from $PWD). Filenames in status output and error messages
are all be expressed as relative paths, relative to this directory.

=back

=head1 CONFIGURATION FILE

When first invoked, fix looks for a F<.fixrc> file in the current dir, then in
successive parent directories, in order to find the worktree root. If the root
of the filesystem (C</>) is reached without a F<.fixrc> file being found, fix
aborts with an error message (telling the user to create the file).

The config file intentionally B<does not> reside inside F<.fix> dir (used for
build metadata). This is to separate the essential F<.fixrc> file, from the
non-essential F<.fix> dir. (Deleting the F<.fix> directory will lead to nothing
worse than a slow build next time - full rebuild is forced), while deleting
F<.fixrc> will stop your project from being built at all.

If you're using git, you should commit F<.fixrc> to your repository, and add a
line saying C</.fix> to your F<.gitignore> file.

The config file format is the same as for git (a simple C<.ini> type format).
The variables are divided into sections, each containing variables and their
values. It is perfectly valid to have an empty config file.

=head2 Syntax

Here is an sample config file:

    # .fixrc
    [core]
        ; Some recommended values.
        scripttree = fix
        targettree = build
        execpath   = bin

Whitespace (and indentation and blank lines) are ignored (except for spaces
inside quoted strings). Comments may be put anywhere, begin with C<;> or C<#>
and continues to the end of the line.

B<Section and variable names> look the same, they are not case-sensitive, may
only contain alphanumeric characters and C<->, and must start with an
alphabetic character. Some variables may appear multiple times.

B<Sections> starts with the section name in square brackets, and continues
until the next section begins.

B<Subsections> exists in git (see git-config(1)) but are not used with fix.

B<Variables> must belong to a section (meaning that a config file must always
start with a section name). A variable is set by a line in the form C<name =
value> (or just C<name>, without any equal sign, in which case the value is set
to C<true>). A variable may be set more than once (= multi-valued variable).

B<Unquoted variable values> will have leading and trailing whitespace trimmed,
but whitespace within the value is kept as-is.

B<Double quoted variable values> preserves all space, and comment characters
(i.e. C<#> or C<;>) inside the value, and may also, double quoted values may
contain the following special escape characters:

   \\ -- backslash
   \" -- double quote
   \n -- newline (NL)
   \t -- horizontal tabulation (HT, TAB)
   \b -- backspace

   (No other escape characters are implemented.)

=head2 Variables

Config file values can be overridden by the corresponding environment variable
or command line option.

In the config file, paths specified may be absolute or relative to the worktree
root. (Relative paths in environment variables or command line options, on the
other hand, are counted as relative to user's current directory).

=over 4

=item B<core.execPath>

See B<--exec-path>.

=item B<core.scriptTree>

See B<--script-tree>.

=back

=head1 FILES

=head2 Build Project Directory Structure

All of the files belonging to a build project resides in fix's worktree. This
worktree may (or may not) have separate sub-trees for:

=over 3

=item a) source files

=item c) buildscript files (C<.fix> files)

=item b) target files

=back

Let's look at a very simple sample project, with only one buildscript,
F<default.html.fix>, which generates HTML from Markdown; and one source file,
F<index.md>, which contains some Markdown source. After running C<fix
index.html> your worktree would look like this (ignoring the dotfiles for
brevity):

    work/
     \_ default.html.fix
     \_ index.html
     \_ index.md

Sources, buildscripts and targets all reside in the same directory -- as your
project grows, this one dir may grow cluttered, and uncomfortable for you. If
you decide to try to clean stuff up a bit, you can add the following to your
(previously empty) F<.fixrc> file:

    # .fixrc
    [core]
        scripttree = fix
        targettree = build

Fix now expects to find source files in the worktree (just like before), but
buildscripts are expected to reside in the subdir F<fix/>, and targets will be
written to F<build/>.

So this is what your worktree would look like after erasing F<index.html>,
moving F<default.html.fix> into the new buildscript dir, F<fix/>, and
re-running C<fix index.html>.

    work/
     \_ index.md
     \_ fix/
         \_ default.html.fix
     \_ build/
         \_ index.html

Neat, eh?

=cut

# FIXME: Flesh this out

# [[FIXME: All files used by the program or function, normally presented as a
# list, and what it uses them for. File names should be enclosed in F<>.
# It's particularly important to document files that will be potentially
# modified. ]]

# =head1 CAVEATS
#
# [[ FIXME: Things to take special care with, sometimes called WARNINGS. ]]

=head1 BUGS

If you find any bugs, please report them using the GitHub issue tracker:
<https://github.com/zrajm/fix/issues>.

If that option isn't available for you, you instead send an email to
<fix@zrajm.org>.

=cut

# =head1 RESTRICTIONS
#
# [[ FIXME: Bugs you don't plan to fix.  :-) ]]

# =head1 NOTES
#
# [[ FIXME: Miscellaneous commentary. ]]

=head1 AUTHOR

Written by zrajm <fix@zrajm.org>, 2012-2014.

This program is distributed under a Creative Commons Attribution-ShareAlike 3.0
license (CC BY-SA 3.0) [http://creativecommons.org/licenses/by-sa/3.0/].

You are allowed to copy, sell and change the program in any way you like, as
long as you still give due credit to its author (B<zrajm>) and release your
program under the same license.

=head1 SEE ALSO

More information about fix can be found on the fix wiki
<https://github.com/zrajm/fix/wiki>.

The current version of this program is always available from its GitHub
repository at <https://github.com/zrajm/fix>.

Info on milestones and bugs: <https://github.com/zrajm/fix/issues>.

=cut

#[eof]
