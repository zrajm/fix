#!/usr/bin/perl
use strict;
use warnings;
use 5.10.1;
END {
    warn
        "# #################################\n" .
        "# ##  THERE WERE FAILING TESTS!  ##\n" .
        "# #################################\n" if $?;
}
use Test::More;
use Cwd qw/cwd realpath/;
use File::Path 'rmtree';
use Carp 'confess';
$SIG{__DIE__} = \&Carp::confess;

our $Dir;
BEGIN {
    ($Dir) = realpath(__FILE__) =~ m#^(.*)/#;
    require "$Dir/fix";                        # load 'fix' as a module
    Local::Modulino->import();
    *subtest = sub {                           # compatibility replacement
        my ($name, $code) = @_;                #   for Test::More's subtest()
        $code->();
        note $name;
    } unless exists &subtest;
}

our $name  = 'fix';
our $keep  = ".$name/keep";                     # keepstate directory
our $run   = ".$name/run";                      # runstate directory
our $stats = ".$name/stats";
our $fix   = "$Dir/fix";

###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

# Delete file(s). Ignore errors if file is gone in the end.
sub delete_file {
    my (@file) = @_;
    foreach my $file (@file) {
        next unless -e $file;
        unlink($file) or die "Failed to delete file '$file': $!,";
    }
}

# Write to a temporary file, so that we know the inode number will change when
# a file is rewritten (which guarantees that a newly written file will have a
# different stat fingerprint, even if it have the same content). Thus we know
# don't have to use Time::HiRes to get sub-second resolution in the
# fingerprinting.
sub write_file {
    my %arg = @_;
    foreach my $file (keys %arg) {
        my $outfile = "$file--tmp";
        open(my $out, '>', $outfile)
            or die "Cannot open file '$outfile' for writing: $!,";
        print $out $arg{$file};
        close($out)
            or die "Cannot close file '$outfile' after writing: $!,";
        rename($outfile, $file)
            or die "Cannot rename file '$outfile' -> '$file' after writing: $!,";
    }
}

sub read_file {
    my ($file) = @_;
    open(my $in, '<', $file)
        or die "Failed to open file '$file' for reading: $!,";
    local $/ = undef;
    return <$in>;
}

# Return stat fingerprint (or empty string if file doesn't exist).
#
# Note: We can't use Time::HiRes here, since it only supports lstat() since
# February 2013. [https://rt.cpan.org/Public/Bug/Display.html?id=83356]
sub read_file_fingerprint {
    my ($file) = @_;
    my @stat = lstat($file);
    return join("-", @stat ? @stat[1, 2, 4, 5, 7, 9, 10] : ());
}

# Return hash of filenames (as keys) and stat fingerprints (as values).
sub fingerprints {
    my (@file) = @_;
    return map {
        $_ => read_file_fingerprint($_);
    } @file;
}

sub make_tempdir {
    my ($name) = @_;
    my $tempdir = `mktemp -td $name-XXXXXX`;
    chomp($tempdir);
    return $tempdir;
}

sub enter_dir {
    my ($dir) = @_;
    mkdir($dir) or die "Cannot create '$dir': $!,";
    chdir($dir) or die "Cannot cd to '$dir': $!,";
    $ENV{PWD} = $dir;
}

sub nl { join "", map "$_\n", @_ }

sub sha1 {
    my ($data) = @_;
    use Digest::SHA qw(sha1_hex);
    use Encode qw(encode_utf8);
    sha1_hex(encode_utf8($data));
}

# Return keys in hash, sorted by first by length, then alphabetically.
sub key(\%) {
    sort { length($a) <=> length($b) or $a cmp $b } keys %{ shift() };
}

sub serialize {
    my (%x) = @_;
    use Data::Dumper;
    local $Data::Dumper::Indent   = 1;
    local $Data::Dumper::Sortkeys = 1;
    local $Data::Dumper::Terse    = 1;
    return Dumper \%x;
}

# for use with keepstate()
sub SOURCE { 'source' }
sub TARGET { 'target' }
sub keepstate {
    my ($type, $content, $deps, $source, $result) = @_;
    # Add checksum from keepstate to each dependency.
    @$deps = map {
        [ map {
            my $checksum = sha1(
                exists $result->{$_}
                    ? $result->{$_}{cont}
                    : $source->{$_},
            );
            join(':', $_, $checksum);
        } @$_ ];
    } @{ $deps // [] };
    my %x;
    $x{type}     = $type;
    $x{deps}     = [ @$deps ] if @$deps;
    $x{checksum} = sha1($content) if defined $content;
    return serialize(%x);
}

# for use with run_fix_test() and runstate()
sub NO_RUNSTATE { 'aborted' }
sub UNCHANGED   { 'wont_rebuild' }
sub WONT_OVERWR { 'wont_overwrite' }
sub SHELL_FAIL  { 'shell_error' }
sub BUILD_FAIL  { 'buildscript_error' }
sub KEPT_PREV   { 'rebuilt_but_kept_previous' }
sub REPL_ERASED { 'rebuilt_replaced_deleted' }
sub NEW_CONTENT { 'rebuilt_new_content' }
sub runstate {
    my ($build_status, $abort_status, $abort_target) = @_;
    my %x;
    $x{ABORT}        = $abort_target if defined($abort_status);
    $x{build_status} = $build_status if defined($build_status);
    return serialize(%x);
}

sub statsstate {
    my (@run_target) = @_;
    my %x;
    $x{run_count}   = scalar(@run_target) if @run_target;
    $x{run_targets} =       \@run_target  if @run_target;
    return serialize(%x);
}

{
    sub TRUE  { 1 }
    sub FALSE { 0 }
    my %target_rewritten = (
        NO_RUNSTATE ,=> FALSE,      # unmodified targets, no runstate generated
        UNCHANGED   ,=> FALSE,
        WONT_OVERWR ,=> FALSE,
        SHELL_FAIL  ,=> FALSE,
        BUILD_FAIL  ,=> FALSE,
        KEPT_PREV   ,=> FALSE,
        REPL_ERASED ,=> TRUE,
        NEW_CONTENT ,=> TRUE,
    );
    sub run_fix_test {
        my %arg = @_;
        $arg{before} //= sub {};
        $arg{after}  //= sub {};
        $arg{name}   //= 'NONE';
        die "run_fix_test() option 'name' must be string," if ref($arg{name});
        die "run_fix_test() option 'exit' must be integer,"
            if $arg{exit} !~ /^\d+$/;
        die "run_fix_test() option 'before' must be coderef,"
            if ref($arg{before}) ne 'CODE';
        die "run_fix_test() option 'after' must be coderef,"
            if ref($arg{after})  ne 'CODE';
        my %result = %{ $arg{result} // {} };
        my %source = %{ $arg{source} // {} };
        my @stats  = @{ $arg{stats}  // [] };
        my @args   = @{ $arg{args}   // [] };

        # write source files
        foreach (key %source) {
            write_file($_ => $source{$_}) if defined $source{$_};
        }

        my @file = do {
            my @tempfile = map { "$_--fixing" } keys %result;
            delete_file @tempfile;
            (keys %source, @tempfile, keys %result);
        };

        my %pre  = fingerprints(@file);
        $arg{before}();                        # run 'before' hook
        unshift(@args, '--stats');             # insert '--stats' option
        unshift(@{ $stats[0] }, '--stats') if @stats;
        my $exit = system("$fix @args 2> stderr.txt");

        if (my $caught = $exit & 127) {        # exit on Ctrl-C
            my %signame;                       #   (or any other signal)
            use Config '%Config';
            @signame{ split ' ', $Config{sig_num} }
                = split ' ', $Config{sig_name};
            warn " *** Killed by SIG" . $signame{ $caught } . "\n";
            # Block around exit is to hide it from 'exit' detector thingy.
            { exit }
        }

        my $stderr = read_file('stderr.txt');  # check stderr output
        delete_file('stderr.txt');
        subtest "$arg{name}\n" . "Ran: fix @args\n" . "Dir: $ENV{PWD}" => sub {

            unlike($stderr, qr/Use of uninitialized value/,
                "No Perl warning 'uninitialized value'");

            is($exit >> 8, $arg{exit},         # check exit status
                "Exit status");

            if (defined $arg{errmsg}) {        # check any error message
                my $info = nl("Try '$name --help' for more information.");
                is($stderr, $arg{errmsg} . $info, "Error message");
            }

            $arg{after}();                     # run 'after' hook
            my %post = fingerprints(@file);

            # check statsfile
            if (@stats == 0) {
                ok(!-e $stats, "Statsfile non-existing: $stats");
            } else {
                ok( -e $stats, "Statsfile existing: $stats");
                my $gotten   = read_file($stats);
                my $expected = statsstate(@stats);
                is($gotten, $expected, "Statsfile content: $stats");
            }

            # check sourcefiles
            {
                foreach (key %source) {
                    ok(! -f $_, "Sourcefile non-existing: $_")
                        if not defined $source{$_};
                }
                my @source = grep { defined $source{$_} } key(%source);
                ok(   -f $_,            "Sourcefile existing: $_" ) for @source;
                is($pre{$_}, $post{$_}, "Sourcefile unchanged: $_") for @source;
            }

            # check tempfiles
            {
                my @tempfile = (
                    key(%source),
                    grep { not defined $result{$_}{temp} } key(%result),
                );
                foreach (@tempfile) {
                    my $file = "$_--fixing";
                    ok(! -f $file, "Tempfile non-existing: $file");
                }
                @tempfile = grep { defined $result{$_}{temp} } key(%result);
                foreach (@tempfile) {
                    my $file = "$_--fixing";
                    ok(  -f $file, "Tempfile existing: $file");
                }
                foreach (@tempfile) {
                    my $file = "$_--fixing";
                    isnt($pre{$file}, $post{$file}, "Tempfile updated: $file");
                }
                foreach (@tempfile) {
                    my $file = "$_--fixing";
                    my $gotten   = read_file($file);
                    my $expected = $result{$_}{temp};
                    is($gotten, $expected, "Tempfile content: $file");
                }
            }

            # check targets
            {
                my @target;
                @target = grep { not defined $result{$_}{cont} } key(%result);
                ok(!-f $_, "Target non-existing: $_") for @target;
                @target = grep {     defined $result{$_}{cont} } key(%result);
                ok( -f $_, "Target existing: $_"    ) for @target;
                foreach (@target) {            # rewritten targets
                    my $state = $result{$_}{state};
                    isnt($pre{$_}, $post{$_}, "Target updated: $_")
                        if $target_rewritten{$state} == TRUE;
                }
                foreach (@target) {            # unmodified targets
                    my $state = $result{$_}{state};
                    is($pre{$_}, $post{$_}, "Target unchanged: $_")
                        if $target_rewritten{$state} == FALSE;
                }
                foreach (@target) {            # if modified, check content
                    is(read_file($_), $result{$_}{cont}, "Target content: $_")
                        if $pre{$_} ne $post{$_};
                }
            }

            # check runstate
            my @runstate = grep { $result{$_}{state} ne NO_RUNSTATE } key(%result);
            if (@runstate == 0) {              # no targets generated
                ok(!-e $run, "Runstate dir non-existing: $run");
            } else {                           # targets were generated
                ok( -e $run, "Runstate dir existing: $run");
                foreach (key %result) {
                    ok(!-f "$run/$_", "Runstate non-existing: $run/$_")
                        if $result{$_}{state} eq NO_RUNSTATE;
                }
                foreach (@runstate) {
                    ok( -f "$run/$_", "Runstate existing: $run/$_");
                }
                foreach (@runstate) {
                    my $gotten   = read_file("$run/$_");
                    my $expected = runstate(
                        $result{$_}{state},
                        ($result{$_}{abort} ? (ABORT => $result{$_}{abort}) : ()),
                    );
                    is($gotten, $expected, "Runstate content: $run/$_");
                }
            }

            # check keepstate
            if (@runstate == 0) {
                ok(!-e $keep, "Keepstate dir non-existing: $keep");
            } else {
                ok( -e $keep, "Keepstate dir existing: $keep");
                foreach (key %source) {
                    my $gotten   = read_file("$keep/$_");
                    my $expected = keepstate(SOURCE, $source{$_});
                    is($gotten, $expected, "Keepstate content: $keep/$_");
                }
                foreach (key %result) {
                    my $gotten   = read_file("$keep/$_");
                    my $expected = keepstate(TARGET,
                        $result{$_}{cont},
                        $result{$_}{deps},
                        \%source, \%result
                    );
                    is($gotten, $expected, "Keepstate content: $keep/$_");
                }
            }
        };
    }
}

###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################

# check if there is an 'exit' statement in this file
my $exit_statement_in_test_script = read_file(__FILE__) =~ /^\s*exit.*;/m;
my $testdir = make_tempdir($name);

###############################################################################
##                                                                           ##
##  White-Box Tests (Testing Functions in the Program)                       ##
##                                                                           ##
###############################################################################
note
    "======================================\n" .
    " White-Box Tests (Internal Functions)\n" .
    "======================================";

enter_dir("$testdir/01-internal-tests");

subtest 'split_path()' => sub {
    # FIXME: What *should* split_path('.') return?
    my @test = (
        [ qw( a/b/c     a/b     c ) ],
        [ qw( a/b/c/    a/b     c ) ],
        [ qw( a/b/c///  a/b     c ) ],
        [ qw( a/b//c/   a/b     c ) ],
        [ qw( a//b/c    a//b    c ) ],
        [ qw( /a/b/c    /a/b    c ) ],
        [ qw( a         .       a ) ],
        [ qw( /a        /       a ) ],
    );
    # We run the function twice, because it looks prettier to report basenames and
    # dirnames separately in the output.
    foreach my $test (@test) {
        my ($path, $expect_dir, undef) = @$test;
        my ($dir_result, undef) = Local::Modulino::split_path($path);
        is ($dir_result, $expect_dir, "Dirname: $path");
    }
    foreach my $test (@test) {
        my ($path, undef, $expect_file) = @$test;
        my (undef, $file_result) = Local::Modulino::split_path($path);
        is ($file_result, $expect_file, "Basename: $path");
    }
};

subtest 'default_buildscripts()' => sub {
    my %tests = (
        'hej.a.b.c' => [
            'default.a.b.c.fix',
            'default.a.b.fix',
            'default.a.fix',
            'default.fix' ],
        'a' => [
            'default.fix' ],
    );
    for (key %tests) {
        my $expect = $tests{$_};
        is_deeply([ Local::Modulino::possible_buildscripts($_) ], $expect,
                  "Files: $_");
    }
};

subtest 'Local::Paths::relpath()' => sub {
    my @test = (
        [qw( /x/y/z.txt  /           x/y/z.txt )],
        [qw( /x/y/z.txt  /x            y/z.txt )],
        [qw( /x/y/z.txt  /x/y            z.txt )],
        [qw( /x/y/z.txt  /x/y/a       ../z.txt )],
        [qw( /x/y/z.txt  /x/y/a/b  ../../z.txt )],
        [qw( ../z.txt    .            ../z.txt )],
    );
    foreach (@test) {
        my ($file, $dir, $result) = @$_;
        my $got = Local::Paths::relpath($file, $dir);
        is($got, $result, "$result");
    }
};

subtest 'Local::Paths::clean()' => sub {
    my @test = (
        './a'        => 'a',
        '../a'       => '../a',
        '../../a'    => '../../a',
        '.'          => '.',
        './.'        => '.',
        './..'       => '..',
        './'         => '.',                   # odd corner case
        '/.'         => '/',                   # odd corner case
        '/'          => '/',
        '/a'         => '/a',
        '/a/..'      => '/',
        '/a/../..'   => '/',
        '/a/b/../..' => '/',
        'a'          => 'a',
        'a/'         => 'a',
        'a/../..'    => '..',
        'a/../../..' => '../..',
        'a/../b/c'   => 'b/c',
        'a/../../c'  => '../c',
        'a/./b'      => 'a/b',
        'a//b'       => 'a/b',
        'a/b'        => 'a/b',
        'a/b/../..'  => '.',
        'a/b/c/..'   => 'a/b',
    );
    while (@test) {
        my ($_, $expect) = splice(@test, 0, 2);
        is(Local::Paths::clean($_), $expect, "Path: $_");
    }
};

subtest "Local::Store, simple use" => sub {
    my $test = new Local::Store(dir => 'storage');
    my ($x, $y);

    $x = eval { $test->get('file'); 1 };
    is  ($x, undef, "get() without fields should die");
    like($@, qr/Missing arguments: No field names given/,
                    "get() without fields error message");

    $x = $test->get('file', 'foo');
    is  ($x, undef, "get() on non-existing field");
    $x = $test->set('file', foo => 'bar', apa => 'bepa');
    ok  ($x, "set() return status");
    for ('storage/file') {
        ok  ( -f $_, "set() file existence: $_");
        is  (read_file($_), serialize(foo => 'bar', apa => 'bepa'),
             "set() file content: $_");
    }

    ($x, $y) = $test->get('file', 'foo', 'apa');
    is  ($x, 'bar',  'get() with two existing fields, 1st field');
    is  ($y, 'bepa', 'get() with two existing fields, 2nd field');
    ($x, $y) = $test->get('file', 'apa', 'foo');
    is  ($x, 'bepa', 'get() with two existing fields in opposite order, 1st field');
    is  ($y, 'bar',  'get() with two existing fields in opposite order, 2nd field');

    my %expected = ( foo => 'bar', apa => 'bepa' );
    foreach (qw/foo apa/) {
        $x = $test->get('file', $_);
        is  ($x, $expected{$_}, "get() with one field in scalar context: $_");
    }
};

###############################################################################
##                                                                           ##
##  Grey-Box Tests (Testing Build Results & State Storage Content)           ##
##                                                                           ##
###############################################################################
note
    "================================================\n" .
    " Grey-Box Tests (Build Results + State Storage)\n" .
    "================================================";

note '=== Passing Bad Args ===';
enter_dir("$testdir/02-external-passing-bad-args");

run_fix_test(
    name   => "No '.fixrc'",
    exit   => 254,
    errmsg => nl("fix: Current dir not in a fix worktree",
                 "(Use 'touch .fixrc' where you want your worktree root.)"),
    args   => [qw( 1 )],
);

write_file('.fixrc' => '');

run_fix_test(
    name   => "No argument given",
    exit   => 254,
    errmsg => nl("fix: No target specified"),
    args   => [qw()],
);

run_fix_test(
    name   => "Bad command line option",
    exit   => 254,
    errmsg => nl("fix: Unknown option: '--BAD-OPTION'",
                 "fix: No target specified"),
    args   => [qw( --BAD-OPTION )],
);

run_fix_test(
    name   => "Two bad command line options",
    exit   => 254,
    errmsg => nl("fix: Unknown option: '--BAD-OPTION'",
                 "fix: Unknown option: '--BAD-OPTION-2'",
                 "fix: No target specified"),
    args   => [qw( --BAD-OPTION --BAD-OPTION-2 )],
);

run_fix_test(
    name   => "Option '--source' on command line",
    exit   => 254,
    errmsg => nl("fix: Cannot use '--source' outside buildscript"),
    args   => [qw( --source NON-EXISTING-TARGET )],
);

# FIXME: Test output on standard error
run_fix_test(
    name   => "Non-existing buildscript",
    exit   => 254,
    args   =>  [qw( NON-EXISTING-TARGET )],
    stats  => [[qw( NON-EXISTING-TARGET )]],
    source => {
        'NON-EXISTING-TARGET.fix' => undef,
    },
    result => {
        'NON-EXISTING-TARGET' => {
            state => NO_RUNSTATE,
        },
    },
);

write_file('../outside.fix', '');
# FIXME: Test output on standard error
run_fix_test(
    name   => "Buildscript outside work tree",
    exit   => 254,
    args   =>  [qw( ../outside )],
    stats  => [[qw( ../outside )]],
    source => {
        '../outside.fix' => '',
    },
    result => {
        '../outside' => {
            state => NO_RUNSTATE,
        },
    },
);

# FIXME: Test output on standard error
run_fix_test(
    name   => "Buildscript with exit status = 1",
    exit   => 1,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo FIRST',
                      'exit 1',
                      'echo SECOND'),
    },
    result => {
        '1' => {
            state => BUILD_FAIL,
            deps  => [[ '1.fix' ]],
            temp  => nl('FIRST'),
        },
    },
);

# FIXME: Test output on standard error
run_fix_test(
    name   => "Buildscript with exit status = 2",
    exit   => 2,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo FIRST',
                      'exit 2',
                      'echo SECOND'),
    },
    result => {
        '1' => {
            state => BUILD_FAIL,
            deps  => [[ '1.fix' ]],
            temp  => nl('FIRST'),
        },
    },
);

# FIXME: Test output on standard error
run_fix_test(
    name   => "Buildscript with command returning false",
    exit   => 1,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo FIRST',
                      'false',
                      'echo SECOND'),
    },
    result => {
        '1' => {
            state => BUILD_FAIL,
            deps  => [[ '1.fix' ]],
            temp  => nl('FIRST'),
        },
    },
);

# FIXME: Test output on standard error
run_fix_test(
    name   => "Buildscript with non-existing command",
    exit   => 127,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('NONEXISTING-SHELL-COMMAND'),
    },
    result => {
        '1' => {
            state => BUILD_FAIL,
            deps  => [[ '1.fix' ]],
            temp  => nl(),
        },
    },
);

###############################################################################

note '=== Building with Default Buildscripts ===';
enter_dir("$testdir/03-external-default-buildscripts");
write_file('.fixrc' => '');

run_fix_test(
    name   => "Build using '1.txt.fix' rule",
    exit   => 0,
    args   =>  [qw( 1.txt )],
    stats  => [[qw( 1.txt )]],
    source => {
        '1.txt.fix' => nl('echo $1',
                          'echo $2'),
    },
    result => {
        '1.txt' => {
            state => NEW_CONTENT,
            deps  => [[ '1.txt.fix' ]],
            cont  => nl("$ENV{PWD}/1.txt--fixing",
                        "$ENV{PWD}/1.txt"),
        },
    },
);
rmtree([ ".$name", '1.txt', '1.txt.fix' ]);    # erase generated files

run_fix_test(
    name   => "Build using 'default.txt.fix' rule",
    exit   => 0,
    args   =>  [qw( 1.txt )],
    stats  => [[qw( 1.txt )]],
    source => {
        'default.txt.fix' => nl('echo $1',
                                'echo $2'),
    },
    result => {
        '1.txt' => {
            state => NEW_CONTENT,
            deps  => [[ 'default.txt.fix' ]],
            cont  => nl("$ENV{PWD}/1.txt--fixing",
                        "$ENV{PWD}/1.txt"),
        },
    },
);
rmtree([ ".$name", '1.txt', 'default.txt.fix' ]);  # erase generated files

run_fix_test(
    name   => "Build using 'default.fix' rule",
    exit   => 0,
    args   =>  [qw( 1.txt )],
    stats  => [[qw( 1.txt )]],
    source => {
        'default.fix' => nl('echo $1',
                            'echo $2'),
    },
    result => {
        '1.txt' => {
            state => NEW_CONTENT,
            deps  => [[ 'default.fix' ]],
            cont  => nl("$ENV{PWD}/1.txt--fixing",
                        "$ENV{PWD}/1.txt"),
        },
    },
);
rmtree([ ".$name", '1.txt', 'default.fix' ]);  # erase generated files

###############################################################################

note '=== Building with No Explicit Dependencies ===';
enter_dir("$testdir/04-external-no-explicit-deps");
write_file('.fixrc' => '');

rmtree([ '1', '1.fix' ]);  # erase generated files
run_fix_test(
    name   => "Buildscript outputting \$1 + \$2",
    exit   => 0,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo $1',
                      'echo $2'),
    },
    result => {
        '1' => {
            state => NEW_CONTENT,
            deps  => [[ '1.fix' ]],
            cont  => nl("$ENV{PWD}/1--fixing",
                        "$ENV{PWD}/1"),
        },
    },
);

run_fix_test(
    name   => "Rerun without changes",
    exit   => 0,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo $1',
                      'echo $2'),
    },
    result => {
        '1' => {
            state => UNCHANGED,
            deps  => [[ '1.fix' ]],
            cont  => nl("$ENV{PWD}/1--fixing",
                        "$ENV{PWD}/1"),
        },
    },
);

# (Won't generate tempfile, since build isn't attempted at all.)
write_file('1', nl('XXX'));                    # modify target file
run_fix_test(
    name   => "Rerun after target was externally modified",
    exit   => 253,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo $1',
                      'echo $2'),
    },
    result => {
        '1' => {
            abort => '1',
            state => WONT_OVERWR,
            deps  => [[ '1.fix' ]],
            cont  => nl("$ENV{PWD}/1--fixing",
                        "$ENV{PWD}/1"),
        },
    },
);

delete_file('1');
run_fix_test(
    name   => "Rerun after target was deleted",
    exit   => 0,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo $1',
                      'echo $2'),
    },
    result => {
        '1' => {
            state => REPL_ERASED,
            deps  => [[ '1.fix' ]],
            cont  => nl("$ENV{PWD}/1--fixing",
                        "$ENV{PWD}/1"),
        },
    },
);

run_fix_test(
    name   => "Rerun after buildscript was changed, but give same output",
    exit   => 0,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('# COMMENT',
                      'echo $1',
                      'echo $2'),
    },
    result => {
        '1' => {
            state => KEPT_PREV,
            deps  => [[ '1.fix' ]],
            cont  => nl("$ENV{PWD}/1--fixing",
                        "$ENV{PWD}/1"),
        },
    },
);

run_fix_test(
    name   => "Rerun after buildscript was changed, and give new output",
    exit   => 0,
    args   =>  [qw( 1 )],
    stats  => [[qw( 1 )]],
    source => {
        '1.fix' => nl('echo 1'),
    },
    result => {
        '1' => {
            state => NEW_CONTENT,
            deps  => [[ '1.fix' ]],
            cont  => nl('1'),
        },
    },
);

run_fix_test(
    name   => "Writing to tempfile explicitly (not STDOUT)",
    exit   => 0,
    args   =>  [qw( test.txt )],
    stats  => [[qw( test.txt )]],
    source => {
        'test.txt.fix' => nl('echo test >$1'),
    },
    result => {
        'test.txt' => {
            state => NEW_CONTENT,
            deps  => [[ 'test.txt.fix' ]],
            cont  => nl('test'),
        },
    },
);

###############################################################################

note '=== Source Dependencies ===';
enter_dir("$testdir/05-external-source-deps");
write_file('.fixrc' => '');

run_fix_test(
    name   => "Source dependency",
    exit   => 0,
    args   =>  [qw( indented.txt )],
    stats  => [[qw( indented.txt )], [qw( --source source.txt )]],
    source => {
        'indented.txt.fix' => nl('fix --source source.txt',
                                 'sed "s/^/> /" <source.txt'),
        'source.txt' => nl('some text'),
    },
    result => {
        'indented.txt' => {
            state => NEW_CONTENT,
            deps  => [[ 'indented.txt.fix' ], [ 'source.txt' ]],
            cont  => nl('> some text'),
        },
    },
);

run_fix_test(
    name   => "Source dependency, rebuild without change",
    exit   => 0,
    args   =>  [qw( indented.txt )],
    stats  => [[qw( indented.txt )]],
    source => {
        'indented.txt.fix' => nl('fix --source source.txt',
                                 'sed "s/^/> /" <source.txt'),
        'source.txt' => nl('some text'),
    },
    result => {
        'indented.txt' => {
            state => UNCHANGED,
            deps  => [[ 'indented.txt.fix' ], [ 'source.txt' ]],
            cont  => nl('> some text'),
        },
    },
);

run_fix_test(
    name   => "Source dependency, rebuild with source change",
    exit   => 0,
    args   =>  [qw( indented.txt )],
    stats  => [[qw( indented.txt )], [qw( --source source.txt )]],
    source => {
        'indented.txt.fix' => nl('fix --source source.txt',
                                 'sed "s/^/> /" <source.txt'),
        'source.txt' => nl('some other text'),
    },
    result => {
        'indented.txt' => {
            state => NEW_CONTENT,
            deps  => [[ 'indented.txt.fix' ], [ 'source.txt' ]],
            cont  => nl('> some other text'),
        },
    },
);

###############################################################################

note '=== Checksum-Based Dependencies (a.txt -> b.txt) ===';
enter_dir("$testdir/06-external-dep-checksums");
write_file('.fixrc' => '');

run_fix_test(
    name   => "Initial build from 'a.txt'",
    exit   => 0,
    args   =>  [qw( a.txt )],
    stats  => [[qw( a.txt )], [qw( b.txt )]],
    source => {
        'a.txt.fix' => nl('fix b.txt',
                          'echo "AAA"',
                          'sed "s/^/>/" <b.txt'),
        'b.txt.fix' => nl('echo "BBB"'),
    },
    result => {
        'a.txt' => {
            state => NEW_CONTENT,
            deps  => [['a.txt.fix'], ['b.txt']],
            cont  => nl('AAA',
                        '>BBB'),
        },
        'b.txt' => {
            state => NEW_CONTENT,
            deps  => [['b.txt.fix']],
            cont  => nl('BBB'),
        },
    },
);

run_fix_test(
    name   => "Rebuild of modified 'b.txt'",
    exit   => 0,
    args   =>  [qw( b.txt )],
    stats  => [[qw( b.txt )]],
    source => {
        'b.txt.fix' => nl('echo "BBB BBB"'),
    },
    result => {
        'b.txt' => {
            state => NEW_CONTENT,
            deps  => [['b.txt.fix']],
            cont  => nl('BBB BBB'),
        },
    },
);

# This will fail unless dependencies include checksums.
run_fix_test(
    name   => "Rebuild from 'a.txt'",
    exit   => 0,
    args   =>  [qw( a.txt )],
    stats  => [[qw( a.txt )], [qw( b.txt )]],
    source => {
        'a.txt.fix' => nl('fix b.txt',
                          'echo "AAA"',
                          'sed "s/^/>/" <b.txt'),
        'b.txt.fix' => nl('echo "BBB BBB"'),
    },
    result => {
        'a.txt' => {
            state => NEW_CONTENT,
            deps  => [['a.txt.fix'], ['b.txt']],
            cont  => nl('AAA',
                        '>BBB BBB'),
        },
        'b.txt' => {
            state => UNCHANGED,
            deps  => [['b.txt.fix']],
            cont  => nl('BBB BBB'),
        },
    },
);

###############################################################################

note '=== Multiple Dependencies ===';
enter_dir("$testdir/07-external-multiple-deps");
write_file('.fixrc' => '');

run_fix_test(
    name   => "First run of buildscript with dependencies",
    exit   => 0,
    args   =>  [qw( ab12 )],
    stats  => [[qw( ab12 )], [qw(ab 12)], [qw(a b)], [qw(1 2)]],
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 2'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => NEW_CONTENT,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>2 )),
        },
        ab => {
            state => NEW_CONTENT,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b             )),
        },
        12 => {
            state => NEW_CONTENT,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >2 )),
        },
        a => {
            state => NEW_CONTENT,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                 )),
        },
        b => {
            state => NEW_CONTENT,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b             )),
        },
        1 => {
            state => NEW_CONTENT,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1     )),
        },
        2 => {
            state => NEW_CONTENT,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           2 )),
        },
    },
);

run_fix_test(
    name   => "Rerun without change",
    exit   => 0,
    args   =>  [qw( ab12 )],
    stats  => [[qw( ab12 )]],
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 2'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => UNCHANGED,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>2 )),
        },
        ab => {
            state => UNCHANGED,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b             )),
        },
        12 => {
            state => UNCHANGED,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >2 )),
        },
        a => {
            state => UNCHANGED,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                 )),
        },
        b => {
            state => UNCHANGED,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b             )),
        },
        1 => {
            state => UNCHANGED,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1     )),
        },
        2 => {
            state => UNCHANGED,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           2 )),
        },
    },
);

run_fix_test(
    name   => "Rerun after change of subtarget '2'",
    exit   => 0,
    args   =>  [qw( ab12 )],
    stats  => [[qw( ab12 )], [qw(1 2)], [qw(ab 12)]],
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 22'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => NEW_CONTENT,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>22 )),
        },
        ab => {
            state => UNCHANGED,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b              )),
        },
        12 => {
            state => NEW_CONTENT,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >22 )),
        },
        a => {
            state => UNCHANGED,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                  )),
        },
        b => {
            state => UNCHANGED,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b              )),
        },
        1 => {
            state => UNCHANGED,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1      )),
        },
        2 => {
            state => NEW_CONTENT,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           22 )),
        },
    },
);

delete_file('12');
run_fix_test(
    name   => "Rerun after a dependency '12' was deleted",
    exit   => 0,
    args   =>  [qw( ab12 )],
    stats  => [[qw( ab12 )], [qw(1 2)]],
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 22'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => UNCHANGED,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>22 )),
        },
        ab => {
            state => UNCHANGED,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b              )),
        },
        12 => {
            state => REPL_ERASED,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >22 )),
        },
        a => {
            state => UNCHANGED,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                  )),
        },
        b => {
            state => UNCHANGED,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b              )),
        },
        1 => {
            state => UNCHANGED,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1      )),
        },
        2 => {
            state => UNCHANGED,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           22 )),
        },
    },
);

delete_file('1');
run_fix_test(
    name   => "Rerun after a dependency '1' was deleted",
    exit   => 0,
    args   =>  [qw( ab12 )],
    stats  => [[qw( ab12 )]],
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 22'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => UNCHANGED,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>22 )),
        },
        ab => {
            state => UNCHANGED,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b              )),
        },
        12 => {
            state => UNCHANGED,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >22 )),
        },
        a => {
            state => UNCHANGED,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                  )),
        },
        b => {
            state => UNCHANGED,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b              )),
        },
        1 => {
            state => REPL_ERASED,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1      )),
        },
        2 => {
            state => UNCHANGED,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           22 )),
        },
    },
);

# (Won't generate tempfile, since build isn't attempted at all.)
# FIXME: When graceful abort is added, check runstate of NO_RUNSTATE targets.
write_file('1', nl('XXX'));                    # modify target file
run_fix_test(
    name   => "Rerun after dependency target '1' externally modified",
    exit   => 253,
    args   =>  [qw( ab12 )],
    stats  => [[qw( ab12 )]],
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 22'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => NO_RUNSTATE,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>22 )),
        },
        ab => {
            state => UNCHANGED,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b              )),
        },
        12 => {
            state => NO_RUNSTATE,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >22 )),
        },
        a => {
            state => UNCHANGED,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                  )),
        },
        b => {
            state => UNCHANGED,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b              )),
        },
        1 => {
            abort => '1',
            state => WONT_OVERWR,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1      )),
        },
        2 => {
            state => NO_RUNSTATE,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           22 )),
        },
    },
);

###############################################################################

note '=== Target Outside Current Dir ===';
delete_file('1');

run_fix_test(
    name   => "Building target in parent dir",
    exit   => 0,
    args   =>  [qw( ../ab12 )],
    stats  => [[qw(    ab12 )]],
    before => sub {
        mkdir('abc') && chdir('abc') || die "cannot cd to 'abc',";
    },
    after  => sub {
        chdir('..')  || die "cannot cd back from 'abc',";
        ok(! -e "abc/.fix", "Statedir non-existing in subdir: abc/.fix");
    },
    source => {
        'ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        '12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'b.fix'    => nl('echo b'),
        'a.fix'    => nl('echo a'),
        '2.fix'    => nl('echo 22'),
        '1.fix'    => nl('echo 1'),
    },
    result => {
        ab12 => {
            state => UNCHANGED,
            deps  => [[ 'ab12.fix' ], [qw( ab 12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>22 )),
        },
        ab => {
            state => UNCHANGED,
            deps  => [[ 'ab.fix' ], [qw( a  b )]],
            cont  => nl(qw(      ab  >a  >b              )),
        },
        12 => {
            state => UNCHANGED,
            deps  => [[ '12.fix' ], [qw( 1  2 )]],
            cont  => nl(qw(                  12  >1  >22 )),
        },
        a => {
            state => UNCHANGED,
            deps  => [[ 'a.fix' ]],
            cont  => nl(qw(           a                  )),
        },
        b => {
            state => UNCHANGED,
            deps  => [[ 'b.fix' ]],
            cont  => nl(qw(               b              )),
        },
        1 => {
            state => REPL_ERASED,
            deps  => [[ '1.fix' ]],
            cont  => nl(qw(                       1      )),
        },
        2 => {
            state => UNCHANGED,
            deps  => [[ '2.fix' ]],
            cont  => nl(qw(                           22 )),
        },
    },
);

run_fix_test(
    name   => "Building target in subdir",
    exit   => 0,
    args   =>  [qw( abc/ab12 )],
    stats  => [[qw( abc/ab12      )],
               [qw( abc/ab abc/12 )],
               [qw( abc/a  abc/b  )],
               [qw( abc/1  abc/2  )]],
    after  => sub {
        ok(! -e "abc/.fix", "Statedir non-existing in subdir: abc/.fix");
    },
    source => {
        'abc/ab12.fix' => nl('$FIX_CMD ab 12', 'echo ab12', 'cat ab 12 | sed "s/^/>/"'),
        'abc/ab.fix'   => nl('$FIX_CMD a b',   'echo ab',   'cat  a  b | sed "s/^/>/"'),
        'abc/12.fix'   => nl('$FIX_CMD 1 2',   'echo 12',   'cat  1  2 | sed "s/^/>/"'),
        'abc/b.fix'    => nl('echo b'),
        'abc/a.fix'    => nl('echo a'),
        'abc/2.fix'    => nl('echo 22'),
        'abc/1.fix'    => nl('echo 1'),
    },
    result => {
        'abc/ab12' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/ab12.fix' ], [qw( abc/ab abc/12 )]],
            cont  => nl(qw(ab12 >ab >>a >>b >12 >>1 >>22 )),
        },
        'abc/ab' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/ab.fix' ], [qw( abc/a  abc/b )]],
            cont  => nl(qw(      ab  >a  >b              )),
        },
        'abc/12' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/12.fix' ], [qw( abc/1  abc/2 )]],
            cont  => nl(qw(                  12  >1  >22 )),
        },
        'abc/a' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/a.fix' ]],
            cont  => nl(qw(           a                  )),
        },
        'abc/b' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/b.fix' ]],
            cont  => nl(qw(               b              )),
        },
        'abc/1' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/1.fix' ]],
            cont  => nl(qw(                       1      )),
        },
        'abc/2' => {
            state => NEW_CONTENT,
            deps  => [[ 'abc/2.fix' ]],
            cont  => nl(qw(                           22 )),
        },
    },
);

###############################################################################

chdir $Dir;
SKIP: {
    skip("\$VERSION test - since no .git dir was found", 1) unless -d '.git';
    # get latest major & minor version numbers from last version tag in git
    my ($major, $minor) = (`git tag --list 'v*'`)[-1] =~ m#^v(\d+)\.(\d+)\n$#;
    # patch number = number of commits since last version tag
    my $patch =()= `git log --follow --oneline "v$major.$minor".. fix`;
    # check if 'fix' has been modified since last commit
    my $modified = system("git diff --quiet HEAD fix");
    if ($modified) {
        my $expect1 = "$major.$minor." . ($patch + 1);
        my $expect2 = "$major." . ($minor + 1) . ".0";
        my $expect3 = ($major + 1) . ".0.0";
        ok($Local::Modulino::VERSION ~~ [$expect1, $expect2, $expect3],
            "fix \$VERSION number")
            or note
                "         got: '$Local::Modulino::VERSION'\n" .
                "    expected: '$expect1', '$expect2' or '$expect3'";
    } else {
        my $expect = "$major.$minor.$patch";
        is($Local::Modulino::VERSION, $expect, "fix \$VERSION number");
    }
}

###############################################################################

END {
    done_testing();
    note
        "================================================\n" .
        " NOTA BENE! EXIT STATEMENT FOUND IN TESTSCRIPT!\n" .
        "================================================\n"
            if $exit_statement_in_test_script;
}

#[eof]
