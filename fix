#!/usr/bin/perl
package Local::Modulino; #[http://www.drdobbs.com/scripts-as-modules/184416165]
use strict;
use warnings;
use encoding::warnings 'FATAL';
use 5.10.0;
use utf8;
use open ':utf8';
binmode(STDOUT, ':utf8');

use File::Path qw/mkpath rmtree/;              # use 'mkpath' and 'rmtree'
use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse    = 1;

import Local::Paths qw( abspath relpath find_parent_path );

###############################################################################
##                                                                           ##
##  Settings                                                                 ##
##                                                                           ##
###############################################################################

our $VERSION = "0.3";
our $YEAR    = "2012-2014";
our ($NAME)  = __FILE__ =~ m#([^/]*)$#;        # last non-slash part of path
our ($Keep, $Run);
our %Opt = (
    debug     => !!$ENV{FIX_DEBUG},            # -D/--debug $FIX_DEBUG
    fix_cmd   =>   $ENV{FIX_CMD}       //= abspath(__FILE__),
    fix_dir   =>   $ENV{FIX_DIR}       // '',  # '.fix' dir
    work_tree =>   $ENV{FIX_WORK_TREE} // '',  # worktree root
    # force   => !!$ENV{FIX_FORCE},            # -f/--force $FIX_FORCE
    level     =>   $ENV{FIX_LEVEL}     += 1,   # child level (mother = 1)
    parent    =>   $ENV{FIX_PARENT}    // '',  # parent target
    pid       =>   $ENV{FIX_PID}       //= $$, # PID of mother process
    shell     =>   '/bin/dash',
    source    =>   0,
    stats     => !!$ENV{FIX_STATS},            # --stats $FIX_STATS
    xtrace    => !!$ENV{FIX_XTRACE},           # -x/--xtrace $FIX_XTRACE
    verbose   => !!$ENV{FIX_VERBOSE},          # -v/--verbose $FIX_VERBOSE
);

###############################################################################
##                                                                           ##
##  Informational Functions                                                  ##
##                                                                           ##
###############################################################################

sub version {
    print "$NAME $VERSION\n",
        "Written $YEAR by zrajm <zrajm\@klingonska.org>\n",
        "License CC BY-SA 3.0: Creative Commons Attribution-Share Alike 3.0\n",
        "    <http://creativecommons.org/licenses/by-sa/3.0/>\n";
    exit;
}

sub pod2ansi {
    my ($_) = @_;
    return undef unless defined($_);
    my %char = (quot => '"', amp => '&', lt => '<', gt => '>');
    s#E<([^>]*)>#$char{lc $1}#g;     # HTML-like entity
    s#B<([^>]*)>#\e[1m$1\e[0m#g;     # bold
    s#[FI]<([^>]*)>#\e[4m$1\e[0m#g;  # italic / filename
    s#C<([^>]*)>#"$1"#g;             # quoted code
    return $_;
}

# usage(SOURCE, MSG) -- display usage information from SOURCE + display MSG
sub usage {
    my ($_, $msg) = @_;
    my $out;
    $out .= m#^=head1 \s+ SYNOPSIS \s+ (.*)#mx
        ? "Usage: " . pod2ansi($1) . "\n" : "";
    $out .= m#^=head1 \s+ NAME \s+ [-\w]+ \s+-\s+ (.*)#mx ? "\u$1.\n" : "";
    $out .= "\n" if $out;
    { # list --options (from comments) -- sort by longopt name
        my @opt_doc = ();
        my $opt_length = 0;
        while (/^ \s*
                (?: (['"])                     # start quote
                    ([^\n'"=:|]*?)             #   longopt
                    (?:
                           \|([^\n'"=|:]*?)    #   keep first shortopt
                        (?:\| [^\n'"=|:]+)*    #     (ignore more shortopts)
                    )?
                    (?:\+|([:=])[^\n'"=]*)?    #   optarg
                    \1 [^#]*                   # end quote
                |.*?)?(?<!\#)\#\#\#\s+(.*)$/xmg) { # description
            my $long  = $2 ? "--$2"  : "";
            my $short = $3 ?  "-$3," : "";
            my $arg   = $4;
            my $desc  = $5;
            # if option takes arg, and 1st word in description is uppercase,
            # use that uppercase word in long description description
            if ($arg and $desc =~ s/([A-Z0-9]+)\s*//) {
                $long .= $arg eq ":" ? "[=$1]" : "=$1";
            }
            push(@opt_doc, [ $short, $long, pod2ansi($desc) ]);
            my $length = length($long);
            $opt_length = $length if $length > $opt_length;
        }
        # length of longest option name
        if (@opt_doc) {
            $out .= join "", "Options:\n", map {
                sprintf "  %-3s %-${opt_length}s  %s\n", @$_
            } @opt_doc;
        }
    }
    print "$out\n" . pod2ansi($msg);
    exit;
}

sub help {
    usage(read_file(__FILE__), <<'EOF');
EOF
    exit;
}

sub man {
    my $pid = open(STDOUT, '|-', qw/man -l -/);# filter STDOUT through man(1)
    die "Cannot run 'man': $!\n" unless defined $pid;
    system('pod2man', __FILE__);               # output manpage on STDOUT
    if ($? == -1) {                            # on exec FAILURE
        kill 'TERM', $pid;                     #   kill man(1) child and die()
        die "Cannot execute 'pod2man': $!\n";
    };
    close STDOUT;                              # don't make man(1) wait for more
    wait();                                    # wait until user exits man(1)
    exit;
}

###############################################################################
##                                                                           ##
##  State Storage Module                                                     ##
##                                                                           ##
###############################################################################

{
    package Local::Store;
    use File::Path qw/mkpath rmtree/;          # use 'mkpath' and 'rmtree'
    use Data::Dumper;
    $Data::Dumper::Indent   = 1;
    $Data::Dumper::Sortkeys = 1;
    $Data::Dumper::Terse    = 1;

    # Usage: new Local::Store(dir => DIR, namefilter => CODEREF);
    #
    # DIR is the base of the directory tree used for storage. (It is created
    # when set() is first called, not when new() is invoked.)
    #
    # NAMEFILTER is a coderef, and if specified, it will be used to modify the
    # filename argument passed to get/set, before it is used. It will be called
    # with a single filename as argument, and is expected to return a relative
    # filename, without leading '..' components. (The name of the file
    # read/written by the get/set command.)
    sub new {
        my ($class, %opt) = @_;
        my $self = bless({
            dir        => $opt{dir},
            namefilter => $opt{namefilter} // sub { shift() },
            print      => {},
            state      => {},
        });
        die "new Local::Store() 'namefilter' value must be coderef,"
            if ref($self->{namefilter}) ne 'CODE';
        return $self;
    }

    # Read file stat fingerprint. If this is unchanged since a previous check,
    # know the file is unchanged. If fingerprint has changed, then we need to
    # look at the file content to determine whether that has changed or not.
    # The following lstat() properties are used:
    #
    #      1 ino      inode number
    #      2 mode     file mode (type and permissions)
    #      4 uid      numeric user ID of file's owner
    #      5 gid      numeric group ID of file's owner
    #      7 size     total size of file, in bytes
    #      9 mtime    last modify time in seconds since the epoch
    #     10 ctime    inode change time in seconds since the epoch (*)
    #
    # [http://www.kernel.org/pub/software/scm/git/docs/technical/racy-git.txt]
    #
    # Note: We can't use Time::HiRes here, since it only supports lstat() since
    # February 2013. [https://rt.cpan.org/Public/Bug/Display.html?id=83356]
    sub _read_file_fingerprint {
        my ($file) = @_;
        my @stat = lstat($file) or die "Cannot stat file '$file': $!\n";
        return join("-", @stat[1, 2, 4, 5, 7, 9, 10]);
    }

    sub _read_file {
        my ($file) = @_;
        open(my $in, "<:utf8", $file)
            or die "Cannot open file '$file' for reading: $!\n";
        local $/ = undef;
        return <$in>;
    }

    sub _write_file {
        my ($file, @data) = @_;
        my $tmpfile = "$file--writing";
        # create full path of file, before writing file
        if (my ($dir) = $tmpfile =~ m#^(.*)/#) {
            die "Cannot create dir '$dir': File already exists\n"
                if -e $dir and not -d $dir;
            unless (-d $dir or mkpath($dir)) {
                die "Cannot create dir '$dir'\n";
            }
        }
        open(my $out, ">:utf8", $tmpfile)
            or die "Cannot open tempfile '$tmpfile' for writing: $!\n";
        print $out @data
            or die "Cannot write to tempfile '$tmpfile': $!\n";
        close($out)
            or die "Cannot close tempfile '$tmpfile' after writing: $!\n";
        rename($tmpfile, $file)
            or die "Cannot rename tempfile '$tmpfile' -> '$file': $!\n";
    }

    # Reread state file if its stat fingerprint has changed last read/write.
    sub _read_state {
        my ($self, $file) = @_;
        my $full = "$self->{dir}/" . $self->{namefilter}($file);
        my ($state, $print) = @$self{ qw/ state print / };
        if (-f $full) {                        # state file exists
            my $print2 = _read_file_fingerprint($full);
            if ($print2 ne ($print->{$file} // '')) {
                $print->{$file} = $print2;     #   read if modified
                $state->{$file} = eval _read_file($full);
            }
        }
        return $state->{$file} //= {};
    }

    sub _write_state {
        my ($self, $file) = @_;
        my $full = "$self->{dir}/" . $self->{namefilter}($file);
        my ($state, $print) = @$self{ qw/ state print / };
        _write_file($full, Dumper($state->{$file}));
        $print->{$file} = _read_file_fingerprint($full);
    }

    sub get {
        my ($self, $file, @field) = @_;
        die "get(): Missing arguments: No field names given," if @field == 0;
        my $state = $self->_read_state($file);
        return wantarray()
            ? map { $state->{$_} } @field
            : $state->{ $field[0] };
    }

    # If a value is a coderef, then that will be invoked with the original
    # value, and whatever it returns will be stored in its stead.
    #
    # Will create directories (and subdirectories) as needed).
    sub set {
        my ($self, $file, %arg) = @_;
        return if $file eq '';
        my $state = $self->_read_state($file);
        foreach my $field (keys %arg) {
            $state->{$field} =
                ref($arg{$field}) eq 'CODE'    # run callback
                    ? $arg{$field}->($state->{$field}) # run callback
                    : $arg{$field};            #   or use literal value
        }
        $self->_write_state($file);
    }

    # Deletes named files. Give argument '' to delete entire storage.
    sub delete {
        my ($self, @file) = @_;
        rmtree("$self->{dir}/$_") foreach @file;
        return $self;
    }
}

###############################################################################
##                                                                           ##
##  Cwd Wrapper Module                                                       ##
##                                                                           ##
###############################################################################

# Package used here to contain Cwd functions from leaking out into the 'main::'
# namespace, where it would be very easy to accidentaly use it. We don't want
# cwd()! It gives *physical* insteado of *logical* paths! (Bugs ohoy!) :(
{
    package Local::Paths;
    BEGIN {
        use Exporter 'import';
        our @ISA       = qw(Exporter);
        our @EXPORT_OK = qw(abspath relpath find_parent_path);
    }
    # Current working directory. Returns environment variable '$PWD' (= logical
    # path) if available, and falls back to returning Perl's cwd() if that
    # fails. (NOT EXPORTED: Use abspath(".") from outside module.)
    sub current { $ENV{PWD} // do { use Cwd; Cwd::cwd() } }
    BEGIN {
        *CORE::GLOBAL::chdir = sub {
            my $dir = abspath(shift());
            return 1 if $dir eq $ENV{PWD};
            CORE::chdir($dir) and $ENV{PWD} = $dir;
        };
    }
    # Clean up a path without looking at the file system.
    sub clean {
        my ($path) = @_;
        my @newpart;
        foreach my $part (split m#/+#, $path) {
            next if $part eq '.';              # skip '.' components
            if ($part eq '..') {               # remove previous component
                if (@newpart > 0               #   unless at beginning
                        and $newpart[-1] ne '..') {# or preceded by '..'
                    pop @newpart;
                    next;
                }
            }
            push(@newpart, $part);
        }
        my $newpath = join '/', @newpart;
        return ($newpath eq '')                # if path is '', then look at
            ? (($path =~ m#^/#) ? '/' : '.')   #   original path to see if it
            : $newpath;                        #   started with '/'
    }
    # Return absolute path ($path is relative to $basedir, or current dir).
    sub abspath {
        my ($path, $basedir) = @_;
        $basedir //= current();
        clean($path =~ m#^/# ? $path : join('/', $basedir, $path));
    }
    # Return relative path (relative to $basedir, or current dir). $path and
    # $basedir may be absolute or relative (to the current dir).
    sub relpath {
        my ($path, $basedir) = map { abspath($_) } @_;
        $basedir //= current();
        my @path = split('/', $path,    -1);
        my @base = split('/', $basedir, -1);
        while (@path and @base                 # remove all identical dirs
                and $path[0] eq $base[0]) {
            shift(@path);
            shift(@base);
        }
        pop @base if @base and $base[-1] eq '';# happens if $basedir = '/'
        return join('/', ('..') x scalar(@base), @path);
    }
    # Searches for each of the named files, first in DIR, then the dir above
    # that, etc. all the way up to the specified TOPDIR. Return name of found
    # file, or empty string on failure.
    sub find_parent_path {
        my ($dir, $topdir, @file) = @_;
        ($dir, $topdir) = (abspath($dir), abspath($topdir));
        die "Start dir '$dir' must be inside top dir '$topdir'\n"
            unless $topdir eq '/' or $dir =~ m#^\Q$topdir\E($|/)#;
        while (1) {
            foreach (@file) {                  # look for each file
                my $file = "$dir/$_";
                return $file if -e $file;
            }
            return '' if $dir eq $topdir;
            $dir = do {
                my $next = clean("$dir/..");
                return '' if $dir eq $next;
                $next;
            };
        }
    }
}

###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################

sub TRUE  { 1 }
sub FALSE { 0 }

sub SOURCE { 'source' }
sub TARGET { 'target' }

sub PLAIN { 0 }                                # loglevel for msg()
sub BOLD  { 1 }

sub ERROR   { 4 }                              # red
sub WARN    { 2 }                              # yellow
sub INFO    { 3 }                              # green
sub VERBOSE { 3 }                              # green
sub DEBUG   { 0 }                              # plain
{
    my @ansi = ("\e[m", "\e[1m", "\e[33m", "\e[32m", "\e[31m");
    # Return indented and colorized message.
    sub msg {
        my ($loglevel, $message) = @_;
        die "msg(): missing loglevel" unless defined $ansi[$loglevel];
        chomp $message;
        return "$ansi[$loglevel]$NAME " . ("  " x ($Opt{level} - 1)) .
            $ansi[BOLD] . $message . $ansi[PLAIN] . "\n";
    }
}
sub info {
    my ($msg) = @_;
    say STDERR "\e[32m$NAME " . ("  " x ($Opt{level} - 1)) . "\e[1m$msg\e[m";
}
# Display verbose msg in mother process, or all processes with --verbose/--debug
sub verb { (is_child() or $Opt{debug} or $Opt{verbose}) and info @_ }
sub debug {
    return unless $Opt{debug};
    my ($msg) = @_;
    say STDERR "$NAME " . ("  " x ($Opt{level} - 1)) . $msg;
}
sub quit {
    ($!, my $msg) = @_;
    die $msg // "", "\n";
}

sub is_child { $Opt{parent} ne '' }

sub  strip_worktree { relpath(shift(), $Opt{work_tree}) }
sub prefix_worktree { abspath(shift(), $Opt{work_tree}) }

# Set runstate value for '--stats'. If value already set, don't change it.
sub did {
    return unless $Opt{stats};
    my ($name, $value) = @_;
    $Run->set($name, build_status => sub { shift() // $value });
}

sub add_deps {
    my ($target, @dep) = @_;
    $Keep->set($target, deps => sub { #   targets are deps to parent
        [ @{ shift() // [] }, [ map { strip_worktree($_) } @dep ]];
    });
}

sub set_source_state {
    my ($source) = @_;
    $Keep->set($source,
        type     => SOURCE,
        checksum => checksum_file($source),
    );
}

sub read_file {
    my ($file) = @_;
    open(my $in, "<:utf8", $file)
        or die "Cannot open file '$file' for reading: $!\n";
    local $/ = undef;
    return <$in>;
}

sub write_file {
    my ($file, @data) = @_;
    my $tmpfile = "$file--writing";
    # create full path of file, before writing file
    if (my ($dir) = $tmpfile =~ m#^(.*)/#) {
        die "Cannot create dir '$dir': File already exists\n"
            if -e $dir and not -d $dir;
        unless (-d $dir or mkpath($dir)) {
            warn "Cannot create dir '$dir'\n";
            return undef;
        }
    }
    open(my $out, ">:utf8", $tmpfile)
        or die "Cannot open tempfile '$tmpfile' for writing: $!\n";
    print $out @data
        or die "Cannot write to tempfile '$tmpfile': $!\n";
    close($out)
        or die "Cannot close tempfile '$tmpfile' after writing: $!\n";
    rename($tmpfile, $file)
        or die "Cannot rename tempfile '$tmpfile' -> '$file': $!\n";
}

sub rename_file {
    my ($file1, $file2) = @_;
    rename($file1, $file2) or "Cannot rename '$file1' -> '$file2': $!\n";
}

sub checksum_file {
    my ($file) = @_;
    return '' unless -f $file;
    use Encode qw(encode_utf8);
    use Digest::SHA qw(sha1_hex);
    sha1_hex(encode_utf8(read_file($file)));
}

# Add the currently running fix instance to (first dir in) $PATH (which is
# inherited by all child processes). -- This makes sure that all subsequent
# buildscripts that calls to fix will find it, even when fix wasn't in the
# user's $PATH to begin with.
#
# To do this, a '.fix/bin' directory is created, and a symlink to the currently
# running fix instance is placed there. Thereafter this dir is tucked onto the
# beginning of the $PATH environment variable (which is inherited by our
# children).
sub add_fix_to_path {
    my ($dir)  = @_;
    my $bindir = "$dir/bin";
    my $link   = "$dir/bin/$NAME";         # name of link to create
    if (not -l $link) {                    # if missing '.fix/bin/fix'
        if (not -d $bindir) {              #   make sure '.fix/bin' exists
            mkpath($bindir)
                or die "$NAME: Cannot create dir '$bindir'\n";
        }
        symlink($Opt{fix_cmd}, $link)
            or die "$NAME: Cannot create symlink '$link': $!\n";
    }
    my $full = abspath($bindir);
    # FIXME: A directory in $PATH *cannot* contain a colon (stupid, I know).
    # Therefore the cwd cannot contain a colon (we could fix this this by
    # having this stuff in /tmp, I guess).
    if ($full =~ /:/) {                    # guard for stupid system bug
        die "$NAME: Colon not allowed in current dir path ('" .
            abspath('.') . "')\n";
    }
    $ENV{PATH} = "$full:$ENV{PATH}";       # add dir to path
}

# Redirect standard output to FILE. Return hashref suitable for passing to
# restore_stdout(), or die() on failure.
sub redirect_stdout {
    my ($file) = @_;
    my $prev = { flush => $|, handle => undef, file => $file };
    open($prev->{handle}, '>&', 'STDOUT')
        or die "Cannot copy old STDOUT before redirect to '$file': $!\n";
    open(STDOUT, '>', $file)
        or die "Cannot redirect STDOUT to file '$file': $!\n";
    select STDOUT;
    local $| = 1;                              # turn off buffering
    return $prev;
}

# Restore standard output after redirect_stdout(). PREV is the hashref returned
# by redirect_stdout(). Die()s on failure.
sub restore_stdout {
    my ($prev) = @_;
    close(STDOUT);
    open(STDOUT, '>&', $prev->{handle})
        or die "Cannot restore STDOUT after redirect to file '$prev->{file}': $!\n";
    close($prev->{handle});
    select STDOUT;
    local $| = $prev->{flush};                 # restore buffering
}

# Redirect standard output to FILE, execute CODEREF, then restore STDOUT.
# CODEREF is passed a single argument containing FILE.
sub redir_stdout {
    my ($file, $coderef) = @_;
    my $oldout = redirect_stdout($file);
    my @result = &$coderef($file);
    restore_stdout($oldout);
    return wantarray() ? @result : $result[0];
}

# Return substrings, or in scalar context, substring count.
sub substrings {
    my ($str, $substr) = @_;
    my @match = $str =~ m/$substr/g;
    return @match;
}

# FIXME: What *should* split_path('.') return?
sub split_path {
    my ($_) = @_;
    my @x = (
        m#^ (.*?) /+ ([^/]+) /* $#x
            ? (($1 eq '' ? '/' : $1), $2)
            : ('.', $_)
    );
    return wantarray() ? @x : $x[0];
}

# Given the basename of a target return a list of possible buildscript
# basenames. The following list will result from 'target.tar.gz' as input:
#
#     default.tar.gz.fix
#     default.tar.fix
#     default.fix
#
sub possible_buildscripts {
    my ($file) = @_;
    my @p = split m#\.+#, $file;
    $p[0] = 'default';
    map { join('.', @p[ 0 .. $_ ]) . '.fix' } reverse 0 .. $#p;
}

# Returns (relative) path of fixfile for the specified target, or empty string
# if no fixfile could be found.
#
# If 'TARGET.fix' couldn't be found, this will look for each possible default
# fixfile, first in the current directory, then in directory above that, etc.
# until we reach root. (The last file looked at is '/default.fix' which is
# probably a bit naive.)
sub find_buildscript {
    my ($target) = @_;
    return "$target.fix" if -e "$target.fix";
    return find_parent_path(
        '.', $Opt{work_tree}, possible_buildscripts($target),
    );
}

# build_target($level, $target);
#
# Builds TARGET by executing its buildscript. Return TRUE if the content of
# TARGET was modified because of the (re)build, FALSE if target was not
# modified. Die()s on error.
#
# NOTE: If a target was rebuilt, but the target content remained the same after
# the rebuild, then that target does not count as updated. (This can happen
# e.g. when the build file was modified in a way that did not change its output
# [e.g. a comment was added to it] or if a deleted target with unmodified
# dependencies was rebuilt.)
sub build_target {
    my ($level, $buildscript, $target) = @_;
    debug("Building target: $target");
    info(strip_worktree($target));
    if (-f $target and has_changed($Keep, $target)) {
        $Run->set($target,      ABORT => strip_worktree($target));
        $Run->set($Opt{parent}, ABORT => strip_worktree($target)) if is_child();
        did($target, 'wont_overwrite');
        quit(253, strip_worktree($target) .
            ": Target externally modified, aborting");
    }
    # clear dependency information (rebuilt each run)
    $Keep->set($target,
        type => TARGET,
        deps => [[ strip_worktree($buildscript) ]],
    );

    my $builddir = split_path($buildscript);
    chdir($builddir) or die "Cannot cd to buildscript dir '$builddir': $!\n";

    my $outfile = "$target--fixing";
    my ($close, $exit, $errno) = redir_stdout($outfile, sub {
        local $ENV{FIX_PARENT} = $target;
        local $ENV{FIX_LEVEL}  = $level;
        my @arg = (
            $Opt{xtrace} ? '-x' : (),
            $Opt{debug}  ? '-v' : (),
            $buildscript,
            $outfile,
            $target,
        );
        open(my $shell, '|-', $Opt{shell}, '-e', @arg)
            or die "Cannot execute shell '$Opt{shell}': $!\n";
        return (close($shell), $?, $!);
    });

    # NOTE: outfile is kept on failure (so user may inspect it)
    #
    # - Except when a dependency completely failed to run (e.g. its output file
    #   was externally modified) in which case we remove the outfile.
    if (not $close) {
        $exit >>= 8;
        if ($errno != 0) {
            did($target, 'shell_error');
            die "Cannot run buildscript '$buildscript': $errno\n";
        }
        my $aborted_target = $Run->get($target, 'ABORT') // '';
        if ($aborted_target eq '') {           # buildscript returned non-zero
            did($target, 'buildscript_error');
            quit($exit, strip_worktree($target) . ": exit status $exit");
        }
        # a dependency failed to run
        unlink($outfile);                  #   erase outfile and
        $Run->set(                         #     and tell our parent that
            $Opt{parent},                  #     that we failed, too
            ABORT => $aborted_target,
        ) if is_child();
        did($target, 'buildscript_error');
        exit $exit;
    }

    my $old_checksum = $Keep->get($target, 'checksum') // '';
    my $new_checksum = checksum_file($outfile);
    if ($new_checksum eq $old_checksum) {      # target unmodified
        if (-e $target) {                      #   if target exist
            unlink($outfile);
            did($target, 'rebuilt_but_kept_previous');
        } else {                               #   if target was deleted
            rename_file($outfile, $target);
            did($target, 'rebuilt_replaced_deleted');
        }
        return FALSE;
    }
    rename_file($outfile, $target);            # target modified
    $Keep->set($target, checksum => $new_checksum); # store new checksum
    did($target, 'rebuilt_new_content');
    return TRUE;
}

# NB: $file must exist for has_changed() to give meaningful result
sub has_changed {
    my ($self, $file) = @_;
    my $checksum = $self->get($file, 'checksum') // '';
    return checksum_file($file) eq $checksum ? 0 : 1;
}

# update_targets($level, @target);
#
# Make sure all TARGET(s) are up-to-date, rebuilding them if necessary. Return
# TRUE if the content one or more TARGET(s) was modified because of a rebuild,
# FALSE if no targets were modified. Die()s on error.
#
# NOTE: If a target was rebuilt, but the target content remained the same after
# the rebuild, then that target does not count as updated. (This can happen
# e.g. when the build file was modified in a way that did not change its output
# [e.g. a comment was added to it] or if a deleted target with unmodified
# dependencies was rebuilt.)
sub update_targets {
    my ($level, @target) = @_;
    local $Opt{level} = $level;
    my $changed  = FALSE;
  TARGET: foreach my $target (@target) {
        debug("Updating target: $target");
        if ($target !~ m#^\Q$Opt{work_tree}\E($|/)#) {
            quit(254, "Target '$target' is outside fix's work tree");
        }
        my ($type, $dep_clusters) = $Keep->get($target, 'type', 'deps');
        $type //= '';
        # buildscript source
        if ($type eq SOURCE) {                 # buildscript source
            if (has_changed($Keep, $target)) {
                set_source_state($target);
                $changed = TRUE;
            }
            next TARGET;
        }
        my $buildscript = find_buildscript($target);
        if (not -f $buildscript) {
            quit(254, "No rule to make target '" .
                strip_worktree($target) . "'");
        }
        if ($type eq '') {                     # target is not known by fix
            set_source_state($buildscript);
            build_target($level, $buildscript, $target)
                and $changed = TRUE;
        } elsif ($type eq TARGET) {            # file previously seen by fix
            info(strip_worktree($target) . " (previously built)");
            my $deps_changed = FALSE;
            foreach my $deps (@$dep_clusters) {#   check deps
                update_targets($level + 1, map { prefix_worktree($_) } @$deps)
                    and $deps_changed = TRUE;
            }
            if ($deps_changed or (not -e $target) or has_changed($Keep, $target)) {
                build_target($level, $buildscript, $target)
                    and $changed = TRUE;
            } else {
                did($target, 'wont_rebuild');
            }
        }
    }
    return $changed;
}

###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################

# In this function we use very plain die() and warn() messages (not colorized,
# as in rest of fix).
sub getopts {
    my @arg = (my @orgarg) = @_;
    use Getopt::Long qw(
        GetOptionsFromArray :config
        posix_default bundling gnu_compat no_ignore_case permute
    );

    # Modify Getopt::Long's error messages:
    #   'Option <OPT> requires an argument' and 'Unknown option: <OPT>',
    #   should have "'--option'" or "'-o'" rather than just "option" or "o".
    local $SIG{__DIE__}  = sub { $! = 254; die "$NAME: @_" };
    local $SIG{__WARN__} = sub {
        my ($_) = @_;
        s{(\boption[: ]+)(\S+)}{
            my $x = length($2) == 1 ? '-' : '--';
            "$1'$x$2'";
        }ie;
        warn "$NAME: $_";
    };
    GetOptionsFromArray(\@arg,
        'debug|D'  => sub {           ### debug output + make build shells verbose
            $Opt{debug} = $ENV{FIX_DEBUG} = TRUE;
        },
        # 'force|f'  => sub {         ## overwrite manually edited files
        #     $Opt{force} = $ENV{FIX_FORCE} = TRUE;
        # },
        'help|h|?'  => \&help,        ### display this help and exit
        'man|M'     => \&man,         ### display program manpage and exit
        'source'    => \$Opt{source}, ### declare source dependencies
        'stats'     => sub{           ##  save stats in .fix dir
            $Opt{stats} = $ENV{FIX_STATS} = TRUE;
        },
        'verbose|v' => sub {          ### output status info while building
            $Opt{verbose} = $ENV{FIX_VERBOSE} = TRUE;
        },
        'version|V' => \&version,     ### output version information and exit
        'xtrace|x'  => sub {          ### use xtrace for build shells
            $Opt{xtrace} = $ENV{FIX_XTRACE} = TRUE;
        },
    ) or exit 254;
    if (not is_child()) {
        die "Cannot use '--source' outside buildscript\n" if $Opt{source};

        if ($Opt{fix_dir} eq '') {             # set FIX_DIR and WORK_TREE
            my $rcfile = find_parent_path('.', '/', '.fixrc') or do {
                die "Current dir not in a fix worktree\n" .
                    "(Use 'touch .fixrc' where you want your worktree root.)\n";
            };
            my $dir = split_path($rcfile);
            $Opt{work_tree} = $ENV{FIX_WORK_TREE} = "$dir";
            $Opt{fix_dir}   = $ENV{FIX_DIR}       = "$dir/.fix";
        } else {
            $Opt{work_tree} = $ENV{FIX_WORK_TREE} = abspath('.')
                if $Opt{work_tree} eq '';
            $Opt{fix_dir}   = $ENV{FIX_DIR}       = abspath($Opt{fix_dir});
        }
    }
    if (@arg == 0) {
        die "No target specified\n" .
            "Try '$NAME --help' for more information.\n";
    }
    $Run = new Local::Store(
        dir        => "$Opt{fix_dir}/run",
        namefilter => \&strip_worktree,
    );
    $Keep = new Local::Store(
        dir        => "$Opt{fix_dir}/keep",
        namefilter => \&strip_worktree,
    );
    if ($Opt{stats}) {                         # write '--stats'
        my $stats = new Local::Store(dir => $Opt{fix_dir});
        $stats->delete('stats')                #   mother deletes earlier stats
            unless is_child();
        $stats->set('stats',                   #   count fix invocations
            run_count   => sub { (shift() // 0) + 1 },
            run_targets => sub {               #   save args for each call
                my @arg = map {
                    m#^-# ? $_ : relpath($_, $Opt{work_tree});
                } @orgarg;
                [ @{ shift() // [] }, \@arg ];
            },
        );
    }
    return map { abspath($_) } @arg;
}

###############################################################################
##                                                                           ##
##  Main                                                                     ##
##                                                                           ##
###############################################################################

# run after all globals etc. has been set up properly
__PACKAGE__->run(@ARGV) unless caller();

sub run {
    my ($class, @target) = @_;
    @target = getopts(@target);
    %SIG = (
        __WARN__ => sub { warn msg(WARN,  @_) },
        __DIE__  => sub { die  msg(ERROR, @_) },
    );
    if (is_child()) {                          # CHILD PROCESSES
        if ($Opt{source}) {                    #   '--source' = don't build
            set_source_state($_) foreach @target;
            add_deps($Opt{parent}, @target);
            exit 0;
        }
        add_deps($Opt{parent}, @target);
    } else {                                   # MOTHER PROCESS
        $Run->delete('');                      #   delete previous runstate
        add_fix_to_path($Opt{fix_dir});
    }
    update_targets($Opt{level}, @target);
}

__END__

=head1 NAME

fix - Efficiently build (and rebuild) TARGET(s) based on dependencies

=head1 SYNOPSIS

B<fix> [I<OPTION>]... I<TARGET>...

B<fix> [I<OPTION>]... B<--source> I<FILE>...

=head1 DESCRIPTION

B<Fix> is a build system. As such, it uses B<buildscripts> to generate output
B<target>s (automatically keeping track said targets' dependencies), and when
invoked it performs the minimal action required to make sure the specified
targets are up-to-date, taking into account all changes in dependencies and
buildscripts since it was called last.

If that sounds vague, it is simply because a build system can do B<so much> -
it can be used to compile large software projects, generate HTML for a web page
(e.g. using Markdown source code, and template pages) or just about anything
else where you need to keep track of a long chain of dependencies, and B<update
I<only> those parts of the project which currently I<need> updating>.

B<Fix> is better than B<make> in that is does atomic updates of its targets, it
uses checksums (not timestamps) to figure out when a file has been modified,
and it has no problems with space (or any other weird character) in filenames.
Also, a failing build will not overwrite the a target generated by a previous,
successful build.

=head1 OPTIONS

=cut

# Mandatory arguments for long options are mandatory for short options too.

=over 8

=cut

# =item B<-a>, B<--always>
#
# Assume that all dependencies are dirty, and rebuild B<everything>.

# =item B<-c>, B<--clean>
#
# Remove all generated targets (except manually modified ones). Manually
# modified targets are listed separately, so that you might take care of them.
# If used with B<--force> files are clean regardless of whether or not they
# have been updated.

=item B<-D>, B<--debug>

Enable debug mode. This makes B<fix> to print quite a lot of diagnostics
messages throughout its run (more than B<--verbose>).

This will also pass the option C<-v> to the shell of each buildscript. (This
usually causes the shell to print each I<line> of the script before running it.
The output usually I<unexpanded>; i.e. variables are shown by name, not by
content.) Useful when debugging. See also B<--verbose>.

This option can also be enabled by setting the environment variable $FIX_DEBUG
(to anything except empty or zero). Regardless of whether B<--debug> or
$FIX_DEBUG was used, this causes the $FIX_DEBUG to be set inside all run
buildscripts (which is how this setting is passed down to all child instances
of B<fix> run from within those buildscripts).

=cut

# =item B<-f>, B<--force>
#
# Normally, if you have edited (or otherwise modified) a file that B<fix> is
# trying to rebuild, you'll get an error and the build is interrupted. When you
# use B<--force>, B<fix> will be a lot less careful, and will overwrite these
# files instead. This is useful when you just don't care about these previous
# files for some reason. (Maybe you're doing fully automated rebuilds on a
# continuous integration server?)
#
# If you want to be careful about such cleanups, take a look at B<--clean> and
# B<--list> instead.

=item B<-h>, B<--help>

Output a brief description of options etc on standard output, then exit.

=item B<-M>, B<--manpage>

Display this manpage, then exit. This option extracts the Perl POD (Plain Old
Documentation) documentation from the program and displays it using man(1).

=item B<--source>

Used in buildscripts to register B<source dependencies> (it cannot be used
outside buildscripts). With this option, the arguments given on the command
line refer to source files to register as dependencies, instead of targets to
be built. (See also C<Dependencies> below.)

=item B<--stats>

Write some global build statistics to F<.fix/stats>, and also add
'build_status' information for each processed file in the runstate directory
(F<.fix/run/>). This is primarily intended for testing, and should not normally
be used. (For brevity this option is not included in the B<--help> info.)

=item B<-v>, B<--verbose>

Enable verbose mode, causing B<fix> to print some diagnostics messages
throughout its run (less than B<--debug>).

This option can also be enabled by setting the environment variable
$FIX_VERBOSE (to anything except empty or zero). Regardless of whether
B<--verbose> or $FIX_VERBOSE was used, this causes the $FIX_VERBOSE to be set
inside all run buildscripts (which is how this setting is passed down to all
child instances of B<fix> run from within those buildscripts).

=item B<-V>, B<--version>

Output program version information on standard output, then exit.

=item B<-x>, B<--xtrace>

Pass the option C<-x> to the shell of each buildscript. (This usually causes
the shell to print, preceded by C<+ >, each I<command> of the script before
running it. The output usually I<expanded>; i.e. variables are replaced by
their content.) Useful when debugging. See also B<--verbose>.

This option can also be enabled by setting the environment variable $FIX_XTRACE
(to anything but the empty string or zero). Regardless of whether B<--xtrace>
or $FIX_XTRACE was used, this causes the $FIX_XTRACE to be set inside all run
buildscripts (which is how this setting is passed down to all child instances
of B<fix> run from within those buildscripts).

=back

=head1 DISCUSSION

=head2 Buildscripts

For building to be atomic, build files should produce output by either

=over 3

=item a)

writing to standard output (preferred method), or

=item b)

writing to a tempfile (the name is determined by B<fix> and passed in as the
third argument, B<$3>, to the buildscript). When using this method anything
written to standard output will be ignored.

=back

=cut

# FIXME: Method B is required when generating anything but a standard file
# (i.e. when a buildscript generate a pipe, symlink or directory). Also note
# that target updating will only be atomic when generating a single file.

=head1 EXIT STATUS

B<NOTE: Any buildscript can terminate with exit status 253-255, in which case
its return code is indistinguishable from the below cases!>

=over 4

=item B<0>

All targets and their dependencies were successfully built. (This is the only
exit status which is 100% reliable.)

=item B<E<gt>0>

Build failed. This usually means than one or more target failed to build. The
exact exit status will be the same as the exit status of the failing
buildscript.

=item B<253>

One or more targets were externally modified, and were not overwritten by
B<fix>.

=cut

# (You run the command again with the option B<--force> to force the targets
# overwritten).

=item B<254>

An early error occurred before even attempting to build. (Command line option
parsing error, a non-existing target specified on the command line etc.)

=item B<255>

Some basic file operation failed, e.g. a file could not be renamed, standard
output could not be redirected, a new shell could not be executed, or a
statefile was found to contain unintelligible data etc.

=back

=head1 USAGE

=head2 The Work Tree Root

The work tree directory, with a F<.fixrc> file at the top level, is where all
of a project's build files reside. B<Fix> will never attempt to write anything
outside of the work tree.

The work tree is defined by the F<.fixrc> file, but B<fix> will also write its
statedir (containing all build metadata) in a directory called F<.fix>, in the
top level of the work tree. If this metadata is ever lost, B<fix> will do a
full rebuild, when next invoked, to reconstruct it.

=head2 Buildscripts

The core of B<fix> is the B<buildscript>. Each buildscript is responsible for
building a single target, and for declaring its dependencies. Its written as a
shell script, and called with two arguments:

=over 4

=item B<$1> - path to a temporary output file

=item B<$2> - path to the target

=back

A buildscript is expected to write its target's content either to standard
output, or to the tempfile given in $1. (Upon a successful build the tempfile
is atomically renamed to the target, if the build fail the tempfile is kept
around so that you may inspect it.)

Dependencies are declared by invoking B<fix>, inside the buildscript, for each
of the dependencies. B<Fix> thereafter keep track of these dependencies, and
rebuilds the target if any of the dependencies (or its buildscript) are
modified.

Buildscript are sought first based on target name, then by successively
removing file name extensions, then lastly by looking in parent directories.
Given the target 'TARGET', this would entail looking for the following files:

    TARGET.A.B.fix
    default.A.B.fix
    default.A.fix
    default.fix
    ../default.A.B.fix
    ../default.A.fix
    ../default.fix
    ../../default.A.B.fix
    ../../default.A.fix
    ../../default.fix

The search stops at the root of the work tree (similar to git).

The $FIX_* environment variables discussed below are all set inside the
buildscripts. You should not modify them, but you're free to read their content
for whatever purpose.

=head2 Dependencies

There are two types of dependencies:

=over 4

=item B<Source dependencies>

A dependency on a source file written by the user, not one built by B<fix>.
Declared (inside buildscript) using: C<B<fix --source> I<FILE>...>.

=item B<Target dependencies>

A dependency on a target generated by B<fix>. Declared (inside the buildscript)
using: C<B<fix> I<TARGET>...> (without the B<--source> option).

=back

=cut

# =head2 About Target Files
#
# When a target file is built B<fix> records a SHA1 sum of the generated file.
# Upon rebuilding the same target B<fix> uses this SHA1 sum to determine if it
# is okay to overwrite the previous file as follows:
#
# =over 4
#
# =item B<Target file is non-existing or unmodified since last built>
#
# If a previously built target already exist but was written by B<fix> (and has
# not been modified since), B<fix> will do whatever it pleases with the file
# (delete it, overwrite it, whatever).
#
# =item B<Target file has been modified since last built>
#
# If a target file already exists but is unknown to B<fix>, or if the file is
# known but the content of the file has been modified in some way after B<fix>
# wrote it, then B<fix> will refuse to modify it and abort with an error
# message. (Use B<--force> to override this, and have B<fix> overwrite all
# target files.)
#
# B<NOTE:> B<fix> never cares about file timestamps, but only the I<content>.
# (So if you modify the timestamp, will not influence B<fix>'s decision of
# whether or not to overwrite the file.)
#
# =back

=head1 DIAGNOSTICS

=cut

# [[ FIXME: The general rule of thumb is that errors printed to C<STDOUT> or
# C<STDERR> and intended for the end user are documented in DIAGNOSTICS while
# errors passed internal to the calling program and intended for other
# programmers are documented in ERRORS. When documenting a function that sets
# errno, a full list of the possible errno values should be given here. ]]

=head2 Tips on Debugging

If you enable B<--xtrace> or B<--verbose> for an entire project, the output can
be quite a mess. The trick is to re-invoke B<fix>, after your build has died
with an error message, and build only the failing file using B<--xtrace> or
B<--verbose>. Because the file has previously failed to build, B<fix> is
guaranteed to try to rebuild it, and because B<fix> is bottom-up, the build is
guaranteed to be exactly identical to whatever you would've gotten by building
the entire tree of dependencies.

=cut

# =head1 EXAMPLES
#
# FIXME: Should include some useful examples!

=head1 ENVIRONMENT VARIABLES

The following variables are exported by B<fix> and are available for use by the
buildscripts. B<A buildscript should never change the content of these
variables> - though in most cases (all but $FIX_PARENT) it is fine to set these
variables from the command line when invoking B<fix>.

=over 4

=item B<$FIX_CMD>

Normally, you do not need to use this environment variable, since B<fix>, when
invoked, always makes sure that that it's binary is first in $PATH, but this
variable contains the name, and full path, of the currently running B<fix>
instance.

You can use this as a command in your buildscripts, to recursively invoke
B<fix>. A buildscript could, for example, look like this:

    $FIX_CMD a b
    cat a b | sed 's/^/>/'

The first line invokes C<fix a b> (thereby declaring F<a> and F<b> to be
dependencies of this script). The second line outputs the content of F<a> and
F<b>, and adds a C<E<gt>> sign to the beginning of each line.

If you started B<fix> by executing a symlink to B<fix>, rather than the actual
B<fix> program, then the name of the symlink will be the name in this variable.

=item B<$FIX_DIR>

If $FIX_DIR is set it specifies a path to for the build metadata directory use
instead of the default F<.fix/>. It may be specified using an absolute or
relative path.

When $FIX_DIR is set, then $FIX_WORK_TREE defaults to the current directory
(unless that is explicitly set, too).

The mother process will make sure $FIX_DIR is an absolute path before passing
it on to its children. Note that B<fix> does whatever it damn well pleases with
this directory (including deleting parts or whole of its content) so don't
point $FIX_DIR to a directory where you have valuable data.

=item B<$FIX_DEBUG>

See B<--debug>.

=item B<$FIX_LEVEL>

Incremented by one each time a build process is invoked (a dependency is
built). This is chiefly used to indent the output messages the proper amount.
(Analogous to the shell's $SHLVL.)

=item B<$FIX_PARENT>

The name of the parent target. All dependencies (i.e. all but the mother
process) will have this variable set to the name of its parent target.

=item B<$FIX_PID>

The process identification number of the mother process.

=item B<$FIX_VERBOSE>

See B<--verbose>.

=item B<$FIX_XTRACE>

See B<--xtrace>.

=item B<$FIX_WORK_TREE>

If $FIX_WORK_TREE is set it specifies a path to use instead of the default
working tree root. It can be an absolute path, or a path relative to the
current working directory.

This value can only be specified $FIX_DIR is also set. If unset $FIX_WORK_TREE
defaults to the current directory.

The mother process makes sure $FIX_WORK_TREE is an absolute path before passing
it on to its children.

=back

=head1 FILES

=head2 Buildscripts

A buildscript is simply a small shell script, which outputs something to
standard output.

=cut

# FIXME: Flesh this out

# [[FIXME: All files used by the program or function, normally presented as a
# list, and what it uses them for. File names should be enclosed in F<>.
# It's particularly important to document files that will be potentially
# modified. ]]

# =head1 CAVEATS
#
# [[ FIXME: Things to take special care with, sometimes called WARNINGS. ]]

# =head1 BUGS
#
# [[ FIXME: Things that are broken or just don't work quite right. ]]

# =head1 RESTRICTIONS
#
# [[ FIXME: Bugs you don't plan to fix.  :-) ]]

# =head1 NOTES
#
# [[ FIXME: Miscellaneous commentary. ]]

=head1 INTERNALS

You shouldn't need to read this, unless your modifying B<fix>, maybe.

=over 4

=item Pathnames

Internally all filenames are absolute, logical paths (see pwd(1) for more info
on logical vs. physical paths). Filenames are converted to absolute paths as
they're inputted (e.g. from the command line).

In the state storage all paths are relative to the working tree root.

=back

=head1 GLOSSARY

=over 4

=item B<buildscript>

A buildscript is a small shell script, whose name ends in C<.fix>. Each
buildscript is responsible for producing one B<target>, and declaring its
dependencies. The target as always called the same as the buildscript, but
without the C<.fix> ending.

=item B<build tree>

A build tree is a B<target> plus all of its dependencies. It is B<fix>'s job to
update a target's entire build tree, and make sure that both the target and all
of its dependencies are up-to-date. - This means that all missing dependencies
will be rebuilt, even if they are not directly mentioned on the command line.
Don't worry, if a rebuilt target hasn't changed since its last build, it will
not cause any of its parent targets to rebuild.

=item B<dependency>

A buildscript may declare any number of dependencies for its target (the
buildscript itself always considered a dependency of its own target, too). If a
dependency change then all targets depends on it will be considered B<dirty>,
until they are rebuilt.

=item B<dirty>

A state of unupdatedness in a target or dependency. That a target is C<dirty>,
then it means that content of that file disagrees with what B<fix> thinks it
should be, and the file will be rebuilt next time you invoke B<fix> on it.

=item B<mother process>

This is the process started by the user. The B<mother process> in turn, spawn
off subprocesses (one for each buildscript being run). The mother process is
the only process for which $FIX_PARENT is not set.

In the ideal case, where the entire build tree is already up-to-date, the
mother process is the only process started.

=item B<parent>

The opposite of a B<dependency>. If target F<a> depends on F<b>, then F<b> is
the dependency of F<a>, and F<a> is the parent of F<b>.

=item B<target>

A target, or a target file, is a file generated by a B<buildscript>. A target
can be a B<dependency> or a B<parent> (or both) of another target. Dependencies
can be both other targets (which need to be declared), and B<buildscripts>
(which are automatically figured out by B<fix>).

=back

=head1 AUTHOR

Written by Zrajm C Akfohg <zrajm@klingonska.org>, 2012-2014.

This program is distributed under a Creative Commons Attribution-ShareAlike 3.0
license (CC BY-SA 3.0) [http://creativecommons.org/licenses/by-sa/3.0/].

This means that you may copy, sell and change the program in any way you like,
as long as you still give attribute it to this author, B<zrajm>, and release
your version under the same license. - If you do this, zrajm would love to hear
from you, though!

=head1 HISTORY

My main reasons for writing B<fix> is that I wanted:

=over 2

=item *

Something small, self contained and fast - a single script file, easy move
about. Test suite, docs, everything should be in one file, so that one can
easily include it in any project (in my case for B<Klingonska Akademien>'s web
site [http://klingonska.org]).

=item *

Few dependencies. Everything you need come pre-installed on a standard
GNU/Linux system.

=item *

B<Git>-like behavior. As long as B<fix> is in your path, it works anywhere in
your build tree, it will find its own statedir and generally Just Work[TM], so
that you can write a thing like C<fix ../index.html> and it'll figure out what
to do.

=cut

# [[ FIXME: Make sure this is true. -- You can run it in any subdir under the
# build tree root (your rules will always run with the build tree root as the
# current dir). This is how B<git> works and I wanted my build tool and my
# versioning system to behave the same way. ]]

=back

=head1 SEE ALSO

B<Fix> is heavily inspired by djb's B<redo>, which has been a source of
inspiration for many others as well. I've tried to learn from all of the
implementations I could find, so it's not more than fair that I try to list
them here.

List is in chronological order, and dates are the first date of activity I
could find for each of the projects (date of first git commit, unless
explicitly stated below).

=over 4

=item djb B<redo> (October 13, 2003)

Daniel J. Bernstein's redo has never been released to the public, so all that
exists of it (outside of djb's own computer) are a couple of web pages
describing some of its properties, but nevertheless this has been enough to
fire the imagination of several other (including me). C<Rebuilding target files
when source files have changed> [http://cr.yp.to/redo.html].

=item Grosskurth B<redo> (April 10, 2006)

Alan Grosskurth's B<redo> is written in B<Bourne shell>, consists of 250 lines
of code, and was part of his master's thesis C<Purely top-down software
rebuilding> [http://grosskurth.ca/papers.html]. He also did a slide
presentation before that, C<Reliable software rebuilding>
[http://grosskurth.ca/talks.html]. (Date from slides.)

=item B<tup> (February 14, 2008)

Mike Shal's B<tup> is written in B<C>. It is a top-down building tool, but
differs from most other B<redo> inspired systems in that it uses a single
buildscript for all targets. He has written a paper on B<tup> called C<Build
System Rules and Algorithms> [http://gittup.org/tup/]. Source available on
GitHub [https://github.com/gittup/tup].

=item Apenwarr B<redo> (November 12, 2010)

Avery Pennarun's B<redo> is written in B<Python>, it is well documented and
feature-rich, and implements parallel builds and some other of that fine stuff.
Usually when I wanted to refresh my knowledge about some particular detail of
B<redo> I go to Apenwarr's documentation. Source available on GitHub
[https://github.com/apenwarr/redo].

=item Jekor B<redo> (March 31, 2013)

Chris Forno's B<redo> is written C<on-camera> in Haskell, videos of him writing
it is available on YouTube [http://youtu.be/zZ_nI9E9g0I], and source is
available on GitHub [https://github.com/jekor/redo]. It is written mostly as an
introduction to programming in Haskell, and is not the most feature rich
version of B<redo> out there, it is however instructive to listen to Jekor's
reasoning while he's writing it.

=item B<gup> (November 2, 2013)

Tim Cuthbertson's B<gup> is written in B<Python>, and tries to solve the
problem that B<redo> can be somewhat brittle at times, and fail to rebuild
stuff that it ought to rebuild [http://gfxmonk.net/]. Source available on
GitHub [https://github.com/gfxmonk/gup].

=back

=cut

#[eof]
